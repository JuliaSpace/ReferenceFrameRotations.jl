var documenterSearchIndex = {"docs":
[{"location":"man/conversions/#Conversions","page":"Conversions","title":"Conversions","text":"There are several functions available to convert between the different types of 3D rotation representations.","category":"section"},{"location":"man/conversions/#DCMs-to-Euler-Angles","page":"Conversions","title":"DCMs to Euler Angles","text":"A Direction Cosine Matrix (DCM) can be converted to Euler Angles using the following function:\n\nfunction dcm_to_angle(dcm::DCM, rot_seq=:ZYX)\n\nnote: Note\nGimbal-lock and special casesIf the rotations are about three different axes, e.g. :XYZ, :ZYX, etc., then a second rotation of pm 90^circ yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation and the angle of the third rotation is set to 0.If the rotations are about two different axes, e.g. :XYX, :YXY, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.\n\ndcm = DCM([1 0 0; 0 0 -1; 0 1 0])\n\ndcm_to_angle(dcm)\n\ndcm_to_angle(dcm, :XYZ)\n\nD = angle_to_dcm(1, -pi / 2, 2, :ZYX)\n\ndcm_to_angle(D, :ZYX)\n\nD = angle_to_dcm(1, :X) * angle_to_dcm(2, :X)\n\ndcm_to_angle(D, :XYX)","category":"section"},{"location":"man/conversions/#DCMs-to-Euler-Angle-and-Axis","page":"Conversions","title":"DCMs to Euler Angle and Axis","text":"A DCM can be converto to an Euler angle and axis representation using the following method:\n\nfunction dcm_to_angleaxis(dcm::DCM)\n\ndcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0])\n\nea  = dcm_to_angleaxis(dcm)","category":"section"},{"location":"man/conversions/#DCMs-to-Quaternions","page":"Conversions","title":"DCMs to Quaternions","text":"A DCM can be converted to quaternion using the following method:\n\nfunction dcm_to_quat(dcm::DCM)\n\ndcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0])\n\nq = dcm_to_quat(dcm)","category":"section"},{"location":"man/conversions/#Euler-Angle-and-Axis-to-DCMs","page":"Conversions","title":"Euler Angle and Axis to DCMs","text":"An Euler angle and axis representation can be converted to DCM using using these two methods:\n\nfunction angleaxis_to_dcm(a::Number, v::AbstractVector)\nfunction angleaxis_to_dcm(ea::EulerAngleAxis)\n\na = 60.0 * pi / 180;\n\nv = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3)/3]\n\nangleaxis_to_dcm(a, v)\n\nangleaxis = EulerAngleAxis(a, v)\n\nangleaxis_to_dcm(angleaxis)","category":"section"},{"location":"man/conversions/#Euler-Angle-and-Axis-to-Euler-Angles","page":"Conversions","title":"Euler Angle and Axis to Euler Angles","text":"An Euler angle and axis representation can be converto to Euler angles using these two methods:\n\nfunction angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)\nfunction angleaxis_to_angle(ea::EulerAngleAxis, rot_seq::Symbol)\n\na = 19.86 * pi / 180\n\nv = [0, 1, 0]\n\nangleaxis_to_angle(a, v, :XYX)\n\na = 60.0 * pi / 180\n\nv = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3]\n\nangleaxis = EulerAngleAxis(a, v)\n\nangleaxis_to_angle(angleaxis, :XYZ)\n\nangleaxis_to_angle(angleaxis, :ZYX)","category":"section"},{"location":"man/conversions/#Euler-Angle-and-Axis-to-Quaternions","page":"Conversions","title":"Euler Angle and Axis to Quaternions","text":"An Euler angle and axis representation can be converted to quaternion using these two methods:\n\nfunction angleaxis_to_quat(a::Number, v::AbstractVector)\nfunction angleaxis_to_quat(angleaxis::EulerAngleAxis)\n\na = 60.0 * pi / 180\n\nv = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3]\n\nangleaxis_to_quat(a,v)\n\nangleaxis = EulerAngleAxis(a,v)\n\nangleaxis_to_quat(angleaxis)","category":"section"},{"location":"man/conversions/#Euler-Angles-to-Direction-Cosine-Matrices","page":"Conversions","title":"Euler Angles to Direction Cosine Matrices","text":"Euler angles can be converted to DCMs using the following functions:\n\nfunction angle_to_dcm(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX)\nfunction angle_to_dcm(Θ::EulerAngles)\n\ndcm = angle_to_dcm(pi / 2, pi / 4, pi / 3, :ZYX)\n\nangles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX);\n\ndcm = angle_to_dcm(angles)\n\nSuppose the user desires to obtain the DCM that rotates the coordinate system about only one or two axes. In that case, it is better to use the following functions due to improved accuracy in some cases:\n\nfunction angle_to_dcm(θ₁::Number, rot_seq::Symbol)\nfunction angle_to_dcm(θ₁::Number, θ₂::Number, rot_seq::Symbol)\n\nangle_to_dcm(-pi / 4, :Z)\n\nangle_to_dcm(-pi / 4, pi / 7, :XY)","category":"section"},{"location":"man/conversions/#Euler-Angles-to-Euler-Angles","page":"Conversions","title":"Euler Angles to Euler Angles","text":"It is possible to change the rotation sequence of a set of Euler angles using the following functions:\n\nfunction angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)\nfunction angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)\n\nin which rot_seq_dest is the desired rotation sequence of the result.\n\nangle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)\n\nangle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)\n\nΘ = EulerAngles(1, 2, 3, :XYX)\n\nangle_to_angle(Θ, :ZYZ)","category":"section"},{"location":"man/conversions/#Euler-Angles-to-Euler-angle-and-axis","page":"Conversions","title":"Euler Angles to Euler angle and axis","text":"Euler angles can be converted to an Euler angle and axis using the following functions:\n\nfunction angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)\nfunction angle_to_angleaxis(Θ::EulerAngles)\n\nangle_to_angleaxis(1, 0, 0, :XYZ)\n\nΘ = EulerAngles(1, 1, 1, :XYZ)\n\nangle_to_angleaxis(Θ)","category":"section"},{"location":"man/conversions/#Euler-Angles-to-Quaternions","page":"Conversions","title":"Euler Angles to Quaternions","text":"Euler angles can be converted to quaternions using the following functions:\n\nfunction angle_to_quat(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX)\nfunction angle_to_quat(Θ::EulerAngles)\n\nq = angle_to_quat(pi / 2, pi / 4, pi / 3, :ZYX)\n\nangles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX)\n\nq = angle_to_quat(angles)\n\nSuppose the user desires to obtain the quaternion that rotates the coordinate system about only one or two axes. In that case, it is better to use the following functions due to improved accuracy in some cases:\n\nfunction angle_to_quat(θ₁::Number, rot_seq::Symbol)\nfunction angle_to_quat(θ₁::Number, θ₂::Number, rot_seq::Symbol)\n\nangle_to_quat(-pi / 4, :Z)\n\nangle_to_quat(-pi / 4, pi / 7, :XY)","category":"section"},{"location":"man/conversions/#Small-Euler-Angles-to-Direction-Cosine-Matrices","page":"Conversions","title":"Small Euler Angles to Direction Cosine Matrices","text":"Small Euler angles can be converted to DCMs using the following function:\n\nfunction smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)\n\nin which the resulting matrix will be orthonormalized if the keyword normalize is true.\n\ndcm = smallangle_to_dcm(0.001, -0.002, +0.003)\n\ndcm = smallangle_to_dcm(0.001, -0.002, +0.003; normalize = false)","category":"section"},{"location":"man/conversions/#Small-Euler-Angles-to-Quaternions","page":"Conversions","title":"Small Euler Angles to Quaternions","text":"Small Euler angles can be converted to quaternions using the following function:\n\nfunction smallangle_to_quat(θx::Number, θy::Number, θz::Number)\n\nq = smallangle_to_quat(0.001, -0.002, +0.003)\n\nnote: Note\nThe computed quaternion is normalized.","category":"section"},{"location":"man/conversions/#Quaternions-to-Direction-Cosine-Matrices","page":"Conversions","title":"Quaternions to Direction Cosine Matrices","text":"A quaternion can be converted to DCM using the following method:\n\nfunction quat_to_dcm(q::Quaternion)\n\nq = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)\n\ndcm = quat_to_dcm(q)","category":"section"},{"location":"man/conversions/#Quaternions-to-Euler-Angle-and-Axis","page":"Conversions","title":"Quaternions to Euler Angle and Axis","text":"A quaternion can be converted to Euler Angle and Axis representation using the following function:\n\nfunction quat_to_angleaxis(q::Quaternion)\n\nv = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3]\n\na = 60.0 * pi / 180\n\nq = Quaternion(cos(a / 2), v * sin(a / 2))\n\nquat_to_angleaxis(q)","category":"section"},{"location":"man/conversions/#Quaternions-to-Euler-Angles","page":"Conversions","title":"Quaternions to Euler Angles","text":"There is one method to convert quaternions to Euler Angles:\n\nfunction quat_to_angle(q::Quaternion, rot_seq=:ZYX)\n\nHowever, it first transforms the quaternion to DCM using quat_to_dcm and then transforms the DCM into the Euler Angles. Hence, the performance will be poor. The improvement of this conversion will be addressed in a future version of ReferenceFrameRotations.jl.\n\nq = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)\n\nquat_to_angle(q, :XYZ)","category":"section"},{"location":"man/conversions/#Julia-API","page":"Conversions","title":"Julia API","text":"All the rotation representations can be converted using the Julia API function convert:\n\ndcm = angle_to_dcm(pi / 4, pi / 7, pi / 5)\n\nconvert(Quaternion, dcm)\n\nconvert(EulerAngleAxis, dcm)\n\nq = Quaternion(cos(pi / 4), 0, sin(pi / 4), 0)\n\nconvert(DCM, q)\n\nIf it is desired to convert to EulerAngles, then one should use the help function EulerAngles(rot_seq), where rot_seq is a symbol specifying the rotation sequence. If EulerAngles is used, then it defaults to ZYX rotation sequence:\n\ndcm = angle_to_dcm(pi / 4, pi / 7, pi / 5)\n\nconvert(EulerAngles, dcm)\n\nconvert(EulerAngles(:YXY), dcm)\n\nconvert(EulerAngles(:XYX), dcm)\n\nSupporting this API enables us to perform interesting conversions like:\n\nv = [\n    Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),\n    angle_to_dcm(pi / 5, pi / 10, 1),\n    EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])\n]\n\nv = Quaternion[\n    Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),\n    angle_to_dcm(pi / 5, pi / 10, 1),\n    EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])\n]\n\nv = EulerAngleAxis[\n    Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),\n    angle_to_dcm(pi / 5, pi / 10, 1),\n    EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])\n]","category":"section"},{"location":"man/composing_rotations/#Composing-rotations","page":"Composing rotations","title":"Composing rotations","text":"Multiple rotations represented can be composed using the function:\n\ncompose_rotation(R1, R2, R3, R4...)\n\nin which R1, R2, R3, ..., must be of the same type. This method returns the following rotation:\n\n(Image: Composing rotations)\n\nCurrently, this method supports DCMs, Euler angle and axis, Euler angles, and Quaternions.\n\nD1 = angle_to_dcm(0.5, 0.5, 0.5, :XYZ)\n\nD2 = angle_to_dcm(-0.5, -0.5, -0.5, :ZYX)\n\ncompose_rotation(D1, D2)\n\nea1 = EulerAngleAxis(30 * pi / 180, [0, 1, 0])\n\nea2 = EulerAngleAxis(45 * pi / 180, [0, 1, 0])\n\ncompose_rotation(ea1, ea2)\n\nΘ1 = EulerAngles(1, 2, 3, :ZYX)\n\nΘ2 = EulerAngles(-3, -2, -1, :XYZ)\n\ncompose_rotation(Θ1, Θ2)\n\nq1 = angle_to_quat(0.5, 0.5, 0.5, :XYZ)\n\nq2 = angle_to_quat(-0.5, -0.5, -0.5, :ZYX)\n\ncompose_rotation(q1, q2)","category":"section"},{"location":"man/composing_rotations/#Operator","page":"Composing rotations","title":"Operator ∘","text":"The rotations can also be composed using the operator ∘, which can be entered by typing \\circ and hitting TAB in REPL. In this case, the composition order is the same as those used by DCMs, i.e., the first rotation is the rightmost one.\n\nR = R5 ∘ R4 ∘ R3 ∘ R2 ∘ R1\n\nThe advantage of using ∘ lies when composing rotations represented by different entities. In this case, they will be automatically converted by the type of the left object.\n\nD = angle_to_dcm(0.5, 0, 0, :ZYX)\n\nq = angle_to_quat(0.3, 0, 0, :ZXY)\n\nD ∘ q\n\nq ∘ D","category":"section"},{"location":"man/kinematics/#Kinematics","page":"Kinematics","title":"Kinematics","text":"Currently, only the kinematics of Direction Cosine Matrices and Quaternions are implemented.","category":"section"},{"location":"man/kinematics/#Direction-Cosine-Matrices","page":"Kinematics","title":"Direction Cosine Matrices","text":"Let A and B be two reference frames in which the angular velocity of B with respect to A, and represented in B, is given by\n\nboldsymbolomega_bab = leftbeginarrayc\n    omega_babx \n    omega_baby \n    omega_babz\nendarrayright \n\nIf mathbfD_b^a is the DCM that rotates the reference frame A into alignment with the reference frame B, then its time-derivative is\n\ndotmathbfD_b^a = -leftbeginarrayccc\n           0          -omega_babz  +omega_baby \n    +omega_babz         0          -omega_babx \n    -omega_baby  +omega_babx         0\nendarrayright cdot mathbfD_b^a \n\nIn this package, the time-derivative of this DCM can be computed using the function:\n\nfunction ddcm(Dba, wba_b)\n\nwba_b = [0.01, 0, 0]\n\nDba = angle_to_dcm(0.5, 0, 0, :XYZ)\n\nddcm(Dba, wba_b)","category":"section"},{"location":"man/kinematics/#Quaternions","page":"Kinematics","title":"Quaternions","text":"Let A and B be two reference frames in which the angular velocity of B with respect to A, and represented in B, is given by\n\nboldsymbolomega_bab = leftbeginarrayc\n    omega_babx \n    omega_baby \n    omega_babz\nendarrayright \n\nIf mathbfq_ba is the quaternion that rotates the reference frame A into alignment with the reference frame B, then its time-derivative is\n\ndotmathbfq_ba = frac12 cdot leftbeginarraycccc\n           0           -omega_babx   -omega_baby  -omega_babz \n    +omega_babx          0           +omega_babz  -omega_baby \n    +omega_baby   -omega_babz          0          +omega_babx \n    +omega_babz   +omega_baby   -omega_babx         0\nendarrayright cdot mathbfq_ba \n\nIn this package, the time-derivative of this quaternion can be computed using the function:\n\nfunction dquat(qba, wba_b)\n\nwba_b = [0.01, 0, 0]\n\nqba = angle_to_quat(0.5, 0, 0, :XYZ)\n\ndquat(qba, wba_b)","category":"section"},{"location":"man/random/#Random-rotations","page":"Random rotations","title":"Random rotations","text":"Sometimes it is necessary to generate random rotations. For example, if you are testing a stochastic system numerically, you need to perform a Monte Carlo simulation sampling the initial conditions. ReferenceFrameRotations.jl defines rand function for all rotation representations, which samples a random rotation uniformly in SO(3).\n\nrand(Quaternion)\n\nrand(DCM)\n\nrand(EulerAngles)\n\nrand(EulerAngleAxis)","category":"section"},{"location":"man/euler_angle_axis/#Euler-Angle-and-Axis","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"The Euler angle and axis representation is defined by the following immutable structure:\n\nstruct EulerAngleAxis{T}\n    a::T\n    v::SVector{3,T}\nend\n\nin which a is the Euler Angle and v is a unitary vector aligned with the Euler axis.\n\nThe constructor for this structure is:\n\nfunction EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}\n\nin which a EulerAngleAxis with angle a [rad] and vector v will be created. Notice that the type of the returned structure will be selected according to the input types T1 and T2. Furthermore, the vector v will not be normalized.\n\nEulerAngleAxis(1, [1, 1, 1])\n\nEulerAngleAxis(1.f0, [1, 1, 1])\n\nEulerAngleAxis(1, [1, 1, 1.f0])\n\nEulerAngleAxis(1.0, [1, 1, 1])","category":"section"},{"location":"man/euler_angle_axis/#Operations","page":"Euler Angle and Axis","title":"Operations","text":"","category":"section"},{"location":"man/euler_angle_axis/#Multiplication","page":"Euler Angle and Axis","title":"Multiplication","text":"The multiplication of two Euler angle and axis sets is defined here as the composition of the rotations. Let Theta_1 and Theta_2 be two Euler angle and axis sets (instances of the structure EulerAngleAxis).  Thus, the operation:\n\nTheta_21 = Theta_2 cdot Theta_1\n\nwill return a new set of Euler angle and axis Theta_21 that represents the composed rotation of Theta_1 followed by Theta_2. By convention, the Euler angle of the result will always be in the interval 0 pi rad.\n\nwarning: Warning\nThis operation is only valid if the vector of the Euler angle and axis set is unitary. The multiplication function does not verify this and does not normalize the vector.\n\nea1 = EulerAngleAxis(30 * pi / 180, [1.0, 0.0, 0.0])\n\nea2 = EulerAngleAxis(60 * pi / 180, [1.0, 0.0, 0.0])\n\nea2 * ea1","category":"section"},{"location":"man/euler_angle_axis/#Inversion","page":"Euler Angle and Axis","title":"Inversion","text":"The inv function applied to Euler angle and axis will return the inverse rotation. Hence, if the Euler angle is a and the Euler axis is aligned with the unitary vector v, then it   will return a as the Euler angle and -v as the Euler axis. By convention, the Euler   angle of the result will always be in the interval 0 pi rad.\n\nea = EulerAngleAxis(1.3, [1.0, 0, 0])\n\ninv(ea)\n\nea = EulerAngleAxis(-π, [sqrt(3), sqrt(3), sqrt(3)])\n\ninv(ea)\n\nea = EulerAngleAxis(-3π / 2, [sqrt(3), sqrt(3), sqrt(3)])\n\ninv(ea)","category":"section"},{"location":"man/euler_angles/#Euler-Angles","page":"Euler Angles","title":"Euler Angles","text":"The Euler Angles are defined by the following immutable structure:\n\nstruct EulerAngles{T}\n    a1::T\n    a2::T\n    a3::T\n    rot_seq::Symbol\nend\n\nin which a1, a2, and a3 define the angles and the rot_seq is a symbol that defines the axes. The valid values for rot_seq are:\n\n:XYX, :XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and ZYZ.\n\nThe constructor for this structure is:\n\nfunction EulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1,T2,T3}\n\nin which a EulerAngles with angles a1, a2, and a3 [rad] and rotation sequence rot_seq will be created. Notice that the type of the returned structure will be selected according to the input types T1, T2, and T3. If rot_seq is omitted, then it defaults to :ZYX.\n\nEulerAngles(1, 1, 1)\n\nEulerAngles(1, 1, 1.0f0, :XYZ)\n\nEulerAngles(1., 1, 1, :XYX)","category":"section"},{"location":"man/euler_angles/#Operations","page":"Euler Angles","title":"Operations","text":"","category":"section"},{"location":"man/euler_angles/#Multiplication","page":"Euler Angles","title":"Multiplication","text":"The multiplication of two Euler angles is defined here as the composition of the rotations. Let Theta_1 and Theta_2 be two sequences of Euler angles (instances of the structure EulerAngles). Thus, the operation:\n\nTheta_21 = Theta_2 cdot Theta_1\n\nwill return a new set of Euler angles Theta_21 that represents the composed rotation of Theta_1 followed by Theta_2. Notice that Theta_21 will be represented using the same rotation sequence as Theta_2.\n\na1 = EulerAngles(1, 0, 0, :ZYX)\n\na2 = EulerAngles(0, -1, 0, :YZY)\n\na2 * a1\n\na1 = EulerAngles(1, 1, 1, :YZY)\n\na2 = EulerAngles(0, 0, -1, :YZY)\n\na2 * a1\n\na1 = EulerAngles(1.3, 2.2, 1.4, :XYZ)\n\na2 = EulerAngles(-1.4, -2.2, -1.3, :ZYX)\n\na2 * a1","category":"section"},{"location":"man/euler_angles/#Inversion","page":"Euler Angles","title":"Inversion","text":"The inv function applied to Euler angles will return the inverse rotation. If the Euler angles Theta represent a rotation through the axes a_1, a_2, and a_3 by angles alpha_1, alpha_2, and alpha_3, then Theta^-1 is a rotation through the axes a_3, a_2, and a_1 by angles -alpha_3, -alpha_2, and -alpha_1.\n\na = EulerAngles(1, 2, 3, :ZYX)\n\ninv(a)\n\na = EulerAngles(1.2, 3.3, 4.6, :XYX)\n\na * inv(a)\n\nwarning: Warning\nAll the operations related to Euler angles first convert them to DCM or Quaternions, and then the result is converted back to Euler angles. Hence, the performance will not be good.","category":"section"},{"location":"man/quaternions/#Quaternion","page":"Quaternions","title":"Quaternion","text":"Quaternions are hypercomplex number with 4 dimensions that can be used to represent 3D rotations. In this package, a quaternion mathbfq is represented by\n\nmathbfq =\n  q_0 + q_1 cdot mathbfi + q_2 cdot mathbfj + q_3 cdot mathbfk =\n  r + mathbfv\n\nusing the following immutable structure:\n\nstruct Quaternion{T}\n    q0::T\n    q1::T\n    q2::T\n    q3::T\nend","category":"section"},{"location":"man/quaternions/#Initialization","page":"Quaternions","title":"Initialization","text":"There are several ways to create a quaternion.\n\nProvide all the elements:\n\nq = Quaternion(1.0, 0.0, 0.0, 0.0)\n\nProvide the real and imaginary parts as separated numbers:\n\nr = sqrt(2) / 2\n\nv = [sqrt(2) / 2, 0, 0]\n\nq = Quaternion(r,v)\n\nProvide the real and imaginary parts as one single vector:\n\nv = [1., 2., 3., 4.]\n\nq = Quaternion(v)\n\nProvide just the imaginary part, in this case the real part will be 0:\n\nv = [1., 0., 0.]\n\nq = Quaternion(v)\n\nCreate an identity quaternion:\n\nq = Quaternion{Float64}(I)  # Creates an identity quaternion of type `Float64`.\n\nq = Quaternion(1.0I)  # Creates an identity quaternion of type `Float64`.\n\nq = Quaternion{Float32}(I)  # Creates an identity quaternion of type `Float32`.\n\nq = Quaternion(1.0f0I)  # Creates an identity quaternion of type `Float32`.\n\na = Quaternion(I,q)  # Creates an identity quaternion with the same type of `q`.\n\nq = Quaternion(I)\n\nCreate an additive identity quaternion using the zero function:\n\nq = zero(Quaternion)\n\nq = zero(Quaternion{Float32})\n\na = zero(q)\n\nCreate an multiplicative identity quaternion using the one function:\n\nq = one(Quaternion)\n\nq = one(Quaternion{Float32})\n\na = one(q)\n\nnote: Note\nIndividual elements of the quaternion can be accessed by:q.q0\nq.q1\nq.q2\nq.q3or using linear indexing:q[1]\nq[2]\nq[3]\nq[4]Notice that, in this case, the index 1 refers to the real part of the quaternion.\n\nwarning: Warning\nSince the type Quaternion is immutable, its components cannot be changed individually after the creation. Hence, the following operation will lead to an error:q.q0 = 1.0  # This is not defined and will not work.If you want to modify a single value for the quaternion, you need to create another one:q = Quaternion(1.0, q.q1, q.q2, q.q3)This can be annoying sometimes, but using an immutable type provided a huge performance boost for the algorithm.","category":"section"},{"location":"man/quaternions/#Operations","page":"Quaternions","title":"Operations","text":"","category":"section"},{"location":"man/quaternions/#Sum,-subtraction,-and-scalar-multiplication","page":"Quaternions","title":"Sum, subtraction, and scalar multiplication","text":"The sum between quaternions, the subtraction between quaternions, and the multiplication between a quaternion and a scalar are defined as usual:\n\nbeginaligned\n  mathbfq_a + mathbfq_b = (q_a0 + q_b0) +\n                                 (q_a1 + q_b1) cdot mathbfi +\n                                 (q_a2 + q_b2) cdot mathbfj +\n                                 (q_a3 + q_b3) cdot mathbfk \n  mathbfq_a - mathbfq_b = (q_a0 - q_b0) +\n                                 (q_a1 - q_b1) cdot mathbfi +\n                                 (q_a2 - q_b2) cdot mathbfj +\n                                 (q_a3 - q_b3) cdot mathbfk \n  lambda cdot mathbfq = (lambda cdot q_0) +\n                              (lambda cdot q_1) cdot mathbfi +\n                              (lambda cdot q_2) cdot mathbfj +\n                              (lambda cdot q_3) cdot mathbfk\nendaligned\n\nq1 = Quaternion(1.0, 1.0, 0.0, 0.0)\n\nq2 = Quaternion(1.0, 2.0, 3.0, 4.0)\n\nq1 + q2\n\nq1 - q2\n\nq1 = Quaternion(1.0, 2.0, 3.0, 4.0)\n\nq1 * 3\n\n4 * q1\n\n5q1","category":"section"},{"location":"man/quaternions/#Multiplication-between-quaternions","page":"Quaternions","title":"Multiplication between quaternions","text":"The multiplication between quaternions is defined using the Hamilton product:\n\nbeginaligned\n  mathbfq_1 = r_1 + mathbfv_1  \n  mathbfq_2 = r_2 + mathbfv_2  \n  mathbfq_1 cdot mathbfq_2 = r_1 cdot r_2 -\n                                     mathbfv_1 cdot mathbfv_2 +\n                                     r_1 cdot mathbfv_2 +\n                                     r_2 cdot mathbfv_1 +\n                                     mathbfv_1 times mathbfv_2 \nendaligned\n\nq1 = Quaternion(cosd(15), sind(15), 0.0, 0.0)\n\nq2 = Quaternion(cosd(30), sind(30), 0.0, 0.0)\n\nq1 * q2\n\nIf a quaternion mathbfq is multiplied by a vector mathbfv, then the vector is converted to a quaternion with real part 0, mathbfq_v = 0 + mathbfv, and the quaternion multiplication is performed as usual:\n\nbeginaligned\nmathbfq   = r + mathbfw  \nmathbfq_v = 0 + mathbfv  \nmathbfq cdot mathbfv triangleq mathbfq cdot mathbfq_v =\n  - mathbfw cdot mathbfv + r cdot mathbfv + mathbfw times mathbfv  \nmathbfv cdot mathbfq triangleq mathbfq_v cdot mathbfq =\n  - mathbfv cdot mathbfw + r cdot mathbfv + mathbfv times mathbfw \nendaligned\n\nq1 = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)\n\nv = [0; 1; 0]\n\nv * q1\n\nq1 * v","category":"section"},{"location":"man/quaternions/#Division-between-quaternions","page":"Quaternions","title":"Division between quaternions","text":"Given this definition of the product between two quaternions, we can define the multiplicative inverse of a quaternion by:\n\nmathbfq^-1 triangleq fracbarmathbfqmathbfq^2 =\n  fracq_0 - q_1 cdot mathbfi - q_2 cdot mathbfj - q_3 cdot mathbfk\n       q_0^2 + q_1^2 + q_2^2 + q_3^2\n\nNotice that, in this case, one gets:\n\nmathbfq cdot mathbfq^-1 = 1\n\nnote: Note\nbarmathbfq, which is the quaternion conjugate, can be computed using conj(q).mathbfq, which is the quaternion norm, can be computed using norm(q).The quaternion inverse can be computed using inv(q).\n\nwarning: Warning\nThe exponentiation operator is not defined for quaternions. Hence, q^(-1) or q^2 will throw an error.\n\nThe right division (/) between two quaternions mathbfq_1 and mathbfq_2 is defined as the following Hamilton product:\n\nmathbfq_1  mathbfq_2 = mathbfq_1 cdot mathbfq_2^-1 \n\nThe left division (\\) between two quaternions mathbfq_1 and mathbfq_2 is defined as the following Hamilton product:\n\nmathbfq_1 backslash mathbfq_2 = mathbfq_1^-1 cdot mathbfq_2 \n\nq1 = Quaternion(cosd(45 + 22.5), sind(45 + 22.5), 0.0, 0.0)\n\nq2 = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)\n\nq1 / q2\n\nq1 \\ q2\n\nq1 \\ q2 * q1 / q2\n\nIf a division operation (right-division or left-division) is performed between a vector mathbfv and a quaternion, then the vector mathbfv is converted to a quaternion real part 0, mathbfq_v = 0 + mathbfv, and the division operation is performed as defined earlier.\n\nbeginaligned\n  mathbfv  mathbfq          triangleq mathbfq_v      cdot mathbfq^-1   \n  mathbfv backslash mathbfq triangleq mathbfq_v^-1 cdot mathbfq        \n  mathbfq  mathbfv          triangleq mathbfq        cdot mathbfq_v^-1 \n  mathbfq backslash mathbfv triangleq mathbfq^-1   cdot mathbfq_v\nendaligned\n\nq1 = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)\n\nv  = [0; 1; 0]\n\nq1 \\ v\n\nv \\ q1","category":"section"},{"location":"man/quaternions/#Other-operations","page":"Quaternions","title":"Other operations","text":"There are also the following functions available:\n\nq = Quaternion(1.0, 2.0, 3.0, 4.0)\n\nconj(q)  # Returns the complex conjugate of the quaternion.\n\ncopy(q)  # Creates a copy of the quaternion.\n\ninv(q)   # Computes the multiplicative inverse of the quaternion.\n\ninv(q) * q\n\nimag(q)  # Returns the vectorial / imaginary part of the quaternion.\n\nnorm(q)  # Computes the norm of the quaternion.\n\nreal(q)  # Returns the real part of the quaternion.\n\nvect(q)  # Returns the vectorial / imaginary part of the quaternion.\n\nnote: Note\nThe operation a / q is equal to a * inv(q) if a is a scalar.","category":"section"},{"location":"man/quaternions/#Converting-reference-frames-using-quaternions","page":"Quaternions","title":"Converting reference frames using quaternions","text":"Given the reference frames A and B, let mathbfw be a unitary vector in which a rotation about it of an angle theta aligns the reference frame A with the reference frame B (in this case, mathbfw is aligned with the Euler Axis and theta is the Euler angle). Construct the following quaternion:\n\nmathbfq_ba =\n  cosleft(fractheta2right) +\n  sinleft(fractheta2right) cdot mathbfw \n\nThen, a vector mathbfv represented in reference frame A (mathbfv_a) can be represented in reference frame B using:\n\nmathbfv_b =\n  textttvectleft(mathbfq_ba^-1 cdot mathbfv_a cdot mathbfq_baright) \n\nHence:\n\nqBA = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)\n\nvA  = [0, 1, 0]\n\nvB  = vect(qBA \\ vA * qBA) # Equivalent to: vect(inv(qBA)*vA*qBA)\n\nvB\n\nnote: Note\nA SArray is returned instead of the usual Array. This is a static vector created by the package StaticArrays. Generally, you can treat this vector as any other one. The only downside is that you cannot modify individual components because it is immutable.","category":"section"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"Documentation for ReferenceFrameRotations.jl.","category":"section"},{"location":"lib/library/#ReferenceFrameRotations.ReferenceFrameRotation","page":"Library","title":"ReferenceFrameRotations.ReferenceFrameRotation","text":"ReferenceFrameRotation\n\nA Union of all supported rotation types.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.CRP","page":"Library","title":"ReferenceFrameRotations.CRP","text":"CRP{T}\n\nThe definition of Classical Rodrigues Parameters (CRP).\n\nFields\n\nq1::T: First component of the CRP.\nq2::T: Second component of the CRP.\nq3::T: Third component of the CRP.\n\nConstructor\n\nCRP(q1::T1, q2::T2, q3::T3) where {T1, T2, T3}\n\nCreate a new instance of CRP with coordinates q1, q2, and q3.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.CRP-Tuple{AbstractVector}","page":"Library","title":"ReferenceFrameRotations.CRP","text":"CRP(v::AbstractVector)\n\nCreate a CRP from the vector v.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.DCM","page":"Library","title":"ReferenceFrameRotations.DCM","text":"DCM{T}\n\nDirection Cosine Matrix (DCM) of type T, which is a 3x3 static matrix of type T.\n\nExamples\n\njulia> DCM(1.0I)\nDCM{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> DCM([1 0 0; 0 -1 0; 0 0 -1])\nDCM{Int64}:\n 1   0   0\n 0  -1   0\n 0   0  -1\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.EulerAngleAxis","page":"Library","title":"ReferenceFrameRotations.EulerAngleAxis","text":"EulerAngleAxis{T}\n\nThe definition of Euler Angle and Axis to represent a 3D rotation.\n\nFields\n\na::T: The Euler angle [rad].\nv::SVector{3, T}: The unitary vector aligned with the Euler axis.\n\nConstructor\n\nEulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}\n\nCreate an Euler Angle and Axis representation structure with angle a [rad] and vector v.\n\nThe vector v will not be normalized.\n\nThe returned structure type will be selected according to the input types.\n\nExamples\n\njulia> EulerAngleAxis(pi / 3, [sqrt(2), sqrt(2), 0])\nEulerAngleAxis{Float64}:\n  Euler angle:   1.0472 rad ( 60.0000 deg)\n   Euler axis: [  1.4142,   1.4142,   0.0000]\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.EulerAngles","page":"Library","title":"ReferenceFrameRotations.EulerAngles","text":"EulerAngles{T}\n\nThe definition of Euler Angles, which is composed of three angles a1, a2, and a3 together with a rotation sequence rot_seq.\n\nFields\n\na1::T: First rotation [rad].\na2::T: Second rotation [rad].\na3::T: Third rotation [rad].\nrot_seq::Symbol: Rotation sequence.\n\ninfo: Info\nrot_seq is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle, e.g. :ZYX. The valid values for rot_seq are::XYX, :XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY,   :ZXZ, :ZYX, and ZYZ.\n\nConstructor\n\nEulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1, T2, T3}\n\nCreate a new instance of EulerAngles with the angles a1, a2, and a3 and the rotation sequence rot_seq.\n\nThe type will be inferred from T1, T2, and T3.\n\nIf rot_seq is not provided, then it defaults to :ZYX.\n\nExamples\n\njulia> EulerAngles(pi / 2, pi / 4, -pi, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  1.5707963267948966 rad  ( 90.0°)\n  R(Y) :  0.7853981633974483 rad  ( 45.0°)\n  R(Z) : -3.141592653589793  rad  (-180.0°)\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.MRP","page":"Library","title":"ReferenceFrameRotations.MRP","text":"MRP{T}\n\nThe definition of Modified Rodrigues Parameters (MRP).\n\nFields\n\nq1::T: First component of the MRP.\nq2::T: Second component of the MRP.\nq3::T: Third component of the MRP.\n\nConstructor\n\nMRP(q1::T1, q2::T2, q3::T3) where {T1, T2, T3}\n\nCreate a new instance of MRP with coordinates q1, q2, and q3.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.MRP-Tuple{AbstractVector}","page":"Library","title":"ReferenceFrameRotations.MRP","text":"MRP(v::AbstractVector)\n\nCreate a MRP from the vector v.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.Quaternion","page":"Library","title":"ReferenceFrameRotations.Quaternion","text":"Quaternion{T}\n\nThe definition of the quaternion.\n\nFields\n\nq0::T: Quaternion real part.\nq1::T: X component of the quaternion imaginary part.\nq2::T: Y component of the quaternion imaginary part.\nq3::T: Z component of the quaternion imaginary part.\n\nnote: Note\nThe quaternion q in this structure is represented by:q = q0 + q1.i + q2.j + q3.k\n\nExample\n\njulia> Quaternion(cosd(45), sind(45), 0, 0)\nQuaternion{Float64}:\n  + 0.7071067811865476 + 0.7071067811865476.i + 0.0.j + 0.0.k\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}","page":"Library","title":"ReferenceFrameRotations.Quaternion","text":"Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0, T1, T2, T3}\n\nCreate the following quaternion:\n\nq0 + q1.i + q2.j + q3.k\n\nin which:\n\nq0 is the real part of the quaternion.\nq1 is the X component of the quaternion vectorial part.\nq2 is the Y component of the quaternion vectorial part.\nq3 is the Z component of the quaternion vectorial part.\n\nnote: Note\nThe quaternion type is obtained by promoting T0, T1, T2, and T3.\n\nExamples\n\njulia> Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> Quaternion(1, 0, 0, 0.0)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\nQuaternion(v::AbstractVector)\n\nIf the vector v has 3 components, then create a quaternion in which the real part is 0 and the vectorial or imaginary part has the same components of the vector v. In other words:\n\nq = 0 + v[1].i + v[2].j + v[3].k\n\nOtherwise, if the vector v has 4 components, then create a quaternion in which the elements match those of the input vector:\n\nq = v[1] + v[2].i + v[3].j + v[4].k\n\nnote: Note\nIf the length of v is not 3 or 4, then an error is thrown.\n\nExamples\n\njulia> Quaternion([0, cosd(45), sind(45)])\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k\n\njulia> Quaternion([cosd(45), 0, sind(45), 0])\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k\n\n\n\nQuaternion(r::Number, v::AbstractVector)\n\nCreate a quaternion with real part r and vectorial or imaginary part v:\n\nr + v[1].i + v[2].j + v[3].k\n\nnote: Note\nThe quaternion type is obtained by promoting the type of r and the elements of v.\n\nExamples\n\njulia> Quaternion(cosd(45), [0, sind(45), 0])\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k\n\n\n\nQuaternion(u::UniformScaling{T}) where T\nQuaternion{T}(u::UniformScaling) where T\nQuaternion(u::UniformScaling, Q::Quaternion{T}) where T\n\nCreate the quaternion u.λ + 0.i + 0.j + 0.k.\n\nIf a quaternion is passed as in the third signature, then the new quaternion will have the same type.\n\nExamples\n\njulia> Quaternion(I)\nQuaternion{Bool}:\n  + true + false⋅i + false⋅j + false⋅k\n\njulia> Quaternion(1.0I)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = Quaternion{Float32}(I)\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> Quaternion(I, q)\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations._EulerAngleConversion","page":"Library","title":"ReferenceFrameRotations._EulerAngleConversion","text":"struct _EulerAngleConversion{R}\n\nThis private structure is used only to enable the rotation conversion to Euler angles using the Julia API.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#Base.:*-Tuple{AbstractVector, Quaternion}","page":"Library","title":"Base.:*","text":"*(v::AbstractVector, q::Quaternion) -> Quaternion\n*(q::Quaternion, v::AbstractVector) -> Quaternion\n\nCompute the multiplication qv * q or q * qv in which qv is a quaternion with real part 0 and vectorial/imaginary part v (Hamilton product).\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> v = [0, cosd(60), sind(60)]\n3-element Vector{Float64}:\n 0.0\n 0.5\n 0.8660254037844386\n\njulia> q * v\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.5⋅j + 0.866025⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{CRP, CRP}","page":"Library","title":"Base.:*","text":"*(c1::CRP, c2::CRP) -> CRP\n\nCompute the composition of two CRPs c1 and c2.\n\nC3 = C2 * C1\n\nwhich means that C3 acts as C1 followed by C2.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{EulerAngles, EulerAngles}","page":"Library","title":"Base.:*","text":"*(Θ₂::EulerAngles, Θ₁::EulerAngles) -> EulerAngles\n\nCompute the composed rotation of Θ₁ -> Θ₂.\n\nThe rotation will be represented by Euler angles (see EulerAngles) with the same rotation sequence as Θ₂.\n\nExamples\n\njulia> ea1 = EulerAngles(deg2rad(35), 0, 0, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.610865 rad  ( 35.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(Z) :  0.0      rad  ( 0.0°)\n\njulia> ea2 = EulerAngles(0, 0, deg2rad(25), :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  0.0      rad  ( 0.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(X) :  0.436332 rad  ( 25.0°)\n\njulia> ea2 * ea1\nEulerAngles{Float64}:\n  R(Z) :  0.0    rad  ( 0.0°)\n  R(Y) : -0.0    rad  (-0.0°)\n  R(X) :  1.0472 rad  ( 60.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{MRP, MRP}","page":"Library","title":"Base.:*","text":"*(m1::MRP, m2::MRP) -> MRP\n\nCompute the composition of two MRPs m1 and m2.\n\nM3 = M2 * M1\n\nwhich means that M3 acts as M1 followed by M2.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{Number, Quaternion}","page":"Library","title":"Base.:*","text":"*(λ::Number, q::Quaternion) -> Quaternion\n*(q::Quaternion, λ::Number) -> Quaternion\n\nCompute λ * q or q * λ, in which λ is a scalar.\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> 2 * q\nQuaternion{Int64}:\n  + 2 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:*","text":"*(q1::Quaternion, q2::Quaternion) -> Quaternion\n\nCompute the quaternion multiplication q1 * q2 (Hamilton product).\n\nIf one of the operands is a UniformScaling:\n\n*(u::UniformScaling, q::Quaternion)\n*(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(cosd(30), 0, sind(30), 0)\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k\n\njulia> q2 = Quaternion(cosd(60), 0, sind(60), 0)\nQuaternion{Float64}:\n  + 0.5 + 0.0⋅i + 0.866025⋅j + 0.0⋅k\n\njulia> q1 * q2\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 1.0⋅j + 0.0⋅k\n\njulia> I * q1\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}","page":"Library","title":"Base.:*","text":"*(av₂::EulerAngleAxis{T1}, av₁::EulerAngleAxis{T2}) where {T1, T2} -> EulerAngleAxis{T3}\n\nCompute the composed rotation of av₁ -> av₂.\n\nThe rotation will be represented by a Euler angle and axis (see EulerAngleAxis). By convention, the output angle will always be in the range [0, π] rad.\n\nNotice that the vector representing the axis in av₁ and av₂ must be unitary. This function neither verifies this nor normalizes the vector.\n\nnote: Note\nThe output type T3 is obtained by promoting T1 and T2 to a float.\n\nExamples\n\njulia> av1 = EulerAngleAxis(deg2rad(45), [sqrt(2)/2, sqrt(2)/2, 0])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.785398 rad  (45.0°)\n  Euler axis  : [0.707107, 0.707107, 0.0]\n\njulia> av2 = EulerAngleAxis(deg2rad(22.5), [sqrt(2)/2, sqrt(2)/2, 0])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.392699 rad  (22.5°)\n  Euler axis  : [0.707107, 0.707107, 0.0]\n\njulia> av1 * av2\nEulerAngleAxis{Float64}:\n  Euler angle : 1.1781 rad  (67.5°)\n  Euler axis  : [0.707107, 0.707107, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:+-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:+","text":"+(qa::Quaternion, qb::Quaternion) -> Quaternion\n\nCompute qa + qb.\n\nIf one of the operands is a UniformScaling:\n\n+(u::UniformScaling, q::Quaternion)\n+(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> q2 = Quaternion(0, cosd(45), 0, sind(45))\nQuaternion{Float64}:\n  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.707107⋅k\n\njulia> q1 + q2\nQuaternion{Float64}:\n  + 1.0 + 0.707107⋅i + 0.0⋅j + 0.707107⋅k\n\njulia> q1 + I\nQuaternion{Int64}:\n  + 2 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:--Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:-","text":"-(qa::Quaternion, qb::Quaternion) -> Quaternion\n\nCompute qa - qb.\n\nIf one of the operands is a UniformScaling:\n\n-(u::UniformScaling, q::Quaternion)\n-(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> q2 = Quaternion(0, cosd(45), 0, sind(45))\nQuaternion{Float64}:\n  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.707107⋅k\n\njulia> q1 - q2\nQuaternion{Float64}:\n  + 1.0 - 0.707107⋅i + 0.0⋅j - 0.707107⋅k\n\njulia> q1 - I\nQuaternion{Int64}:\n  + 0 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:--Tuple{Quaternion}","page":"Library","title":"Base.:-","text":"-(q::Quaternion) -> Quaternion\n\nReturn the quaterion -q.\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> -q\nQuaternion{Int64}:\n  - 1 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:/-Tuple{Number, Quaternion}","page":"Library","title":"Base.:/","text":"/(λ::Number, q::Quaternion) -> Quaternion\n/(q::Quaternion, λ::Number) -> Quaternion\n\nCompute the division λ / q or q / λ, in which λ is a scalar.\n\nExamples\n\njulia> q = Quaternion(2, 0, 0, 0)\nQuaternion{Int64}:\n  + 2 + 0⋅i + 0⋅j + 0⋅k\n\njulia> q / 2\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:/-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:/","text":"/(q1::Quaternion, q2::Quaternion) -> Quaternion\n\nCompute q1 * inv(q2) (Hamilton product).\n\nIf one of the operands is a UniformScaling:\n\n/(u::UniformScaling, q::Quaternion)\n/(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k\n\njulia> q2 = Quaternion(cosd(30), 0, sind(30), 0)\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k\n\njulia> q1 / q2\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k\n\njulia> q1 / (2 * I)\nQuaternion{Float64}:\n  + 0.12941 + 0.0⋅i + 0.482963⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:\\-Tuple{Quaternion, AbstractVector}","page":"Library","title":"Base.:\\","text":"\\(v::AbstractVector, q::Quaternion) -> Quaternion\n\\(q::Quaternion, v::AbstractVector) -> Quaternion\n\nCompute the division qv \\ q or q \\ qv in which qv is a quaternion with real part 0 and vectorial/imaginary part v (Hamilton product).\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> v = [0, cosd(60), sind(60)]\n3-element Vector{Float64}:\n 0.0\n 0.5\n 0.8660254037844386\n\njulia> v \\ q\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i - 0.5⋅j - 0.866025⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:\\-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:\\","text":"\\(q1::Quaternion, q2::Quaternion) -> Quaternion\n\nCompute inv(q1) * q2.\n\nIf one of the operands is a UniformScaling:\n\n\\(u::UniformScaling, q::Quaternion)\n\\(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k\n\njulia> q2 = Quaternion(cosd(30), 0, sind(30), 0)\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k\n\njulia> q2 \\ q1\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.conj-Tuple{Quaternion}","page":"Library","title":"Base.conj","text":"conj(q::Quaternion) -> Quaternion\n\nCompute the complex conjugate of the quaternion q:\n\nq0 - q1.i - q2.j - q3.k\n\nSee also: inv\n\nExamples\n\njulia> q = Quaternion(1, cosd(75), 0, sind(75))\nQuaternion{Float64}:\n  + 1.0 + 0.258819⋅i + 0.0⋅j + 0.965926⋅k\n\njulia> conj(q)\nQuaternion{Float64}:\n  + 1.0 - 0.258819⋅i - 0.0⋅j - 0.965926⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.copy-Union{Tuple{CRP{T}}, Tuple{T}} where T","page":"Library","title":"Base.copy","text":"copy(c::CRP) -> CRP\n\nCreate a copy of the CRP c.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.copy-Union{Tuple{MRP{T}}, Tuple{T}} where T","page":"Library","title":"Base.copy","text":"copy(m::MRP) -> MRP\n\nCreate a copy of the MRP m.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Library","title":"Base.copy","text":"copy(q::Quaternion{T}) where T -> Quaternion\n\nCreate a copy of the quaternion q.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.imag-Tuple{Quaternion}","page":"Library","title":"Base.imag","text":"imag(q::Quaternion{T}) -> SVector{3, T}\n\nReturn the vectorial or imaginary part of the quaternion q represented by a 3 × 1 vector of type SVector{3}.\n\nSee also: real, vect\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k\n\njulia> imag(q)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.9659258262890683\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Tuple{CRP}","page":"Library","title":"Base.inv","text":"inv(c::CRP) -> CRP\n\nCompute the inverse of the CRP c.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Tuple{EulerAngles}","page":"Library","title":"Base.inv","text":"inv(Θ::EulerAngles) -> EulerAngles\n\nReturn the Euler angles that represent the inverse rotation of Θ.\n\nThe rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, :XYZ, then the result will be represented using :ZYX.\n\nExamples\n\njulia> ea = EulerAngles(π / 3, π / 6,  2 / 3 * π, :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  1.0472   rad  ( 60.0°)\n  R(Y) :  0.523599 rad  ( 30.0°)\n  R(X) :  2.0944   rad  ( 120.0°)\n\njulia> inv(ea)\nEulerAngles{Float64}:\n  R(X) : -2.0944   rad  (-120.0°)\n  R(Y) : -0.523599 rad  (-30.0°)\n  R(Z) : -1.0472   rad  (-60.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Tuple{MRP}","page":"Library","title":"Base.inv","text":"inv(m::MRP) -> MRP\n\nCompute the inverse of the MRP m.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Tuple{Quaternion}","page":"Library","title":"Base.inv","text":"inv(q::Quaternion) -> Quaternion\n\nCompute the inverse of the quaternion q:\n\nconj(q)\n───────\n  |q|²\n\nSee also: conj\n\nExamples\n\njulia> q = Quaternion(1, 0, cosd(75), sind(75))\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.258819⋅j + 0.965926⋅k\n\njulia> inv(q)\nQuaternion{Float64}:\n  + 0.5 - 0.0⋅i - 0.12941⋅j - 0.482963⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T<:Number","page":"Library","title":"Base.inv","text":"inv(av::EulerAngleAxis) -> EulerAngleAxis\n\nCompute the inverse rotation of the Euler angle and axis av.\n\nThe Euler angle returned by this function will always be in the interval [0, π] rad.\n\nExamples\n\njulia> av = EulerAngleAxis(deg2rad(20), [sqrt(2) / 2, 0, sqrt(2) / 2])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.349066 rad  (20.0°)\n  Euler axis  : [0.707107, 0.0, 0.707107]\n\njulia> inv(av)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.349066 rad  (20.0°)\n  Euler axis  : [-0.707107, -0.0, -0.707107]\n\njulia> av = EulerAngleAxis(deg2rad(-20), [sqrt(2) / 2, 0, sqrt(2) / 2])\nEulerAngleAxis{Float64}:\n  Euler angle : -0.349066 rad  (-20.0°)\n  Euler axis  : [0.707107, 0.0, 0.707107]\n\njulia> inv(av)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.349066 rad  (20.0°)\n  Euler axis  : [0.707107, 0.0, 0.707107]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.real-Tuple{Quaternion}","page":"Library","title":"Base.real","text":"real(q::Quaternion{T}) -> T\n\nReturn the real part of the quaternion q: q0.\n\nSee also: imag, vect\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k\n\njulia> real(q)\n0.25881904510252074\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#LinearAlgebra.norm-Tuple{CRP}","page":"Library","title":"LinearAlgebra.norm","text":"norm(c::CRP) -> Number\n\nCompute the Euclidean norm of the CRP c.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#LinearAlgebra.norm-Tuple{MRP}","page":"Library","title":"LinearAlgebra.norm","text":"norm(m::MRP) -> Number\n\nCompute the Euclidean norm of the MRP m.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#LinearAlgebra.norm-Tuple{Quaternion}","page":"Library","title":"LinearAlgebra.norm","text":"norm(q::Quaternion{T}) -> float(T)\n\nCompute the Euclidean norm of the quaternion q:\n\n√(q0² + q1² + q2² + q3²)\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k\n\njulia> norm(q)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}","page":"Library","title":"ReferenceFrameRotations.angle_to_angle","text":"angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol) -> EulerAngles\nangle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol) -> EulerAngles\n\nConvert the Euler angles θ₁, θ₂, and θ₃ [rad] with the rotation sequence rot_seq_orig to a new set of Euler angles with rotation sequence rot_seq_dest.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ.\n\nExample\n\njulia> angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)\nEulerAngles{Float64}:\n  R(X) : -1.0472   rad  (-60.0°)\n  R(Y) :  0.785398 rad  ( 45.0°)\n  R(Z) : -1.5708   rad  (-90.0°)\n\njulia> angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.0    rad  ( 0.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(Z) : -1.5708 rad  (-90.0°)\n\njulia> Θ = EulerAngles(1, 2, 3, :XYX)\nEulerAngles{Int64}:\n  R(X) :  1 rad  ( 57.2958°)\n  R(Y) :  2 rad  ( 114.592°)\n  R(X) :  3 rad  ( 171.887°)\n\njulia> angle_to_angle(Θ, :ZYZ)\nEulerAngles{Float64}:\n  R(Z) : -2.70239 rad  (-154.836°)\n  R(Y) :  1.46676 rad  ( 84.0393°)\n  R(Z) : -1.05415 rad  (-60.3984°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_angleaxis","page":"Library","title":"ReferenceFrameRotations.angle_to_angleaxis","text":"angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX) -> EulerAngleAxis\nangle_to_angleaxis(Θ::EulerAngles) -> EulerAngleAxis\n\nConvert the Euler angles θ₁, θ₂, and θ₃ [rad] with the rotation sequence rot_seq to an Euler angle and axis representation.\n\nThose values can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, it defaults to :ZYX.\n\nExample\n\njulia> angle_to_angleaxis(1, 0, 0, :XYZ)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0 rad  (57.2958°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\njulia> Θ = EulerAngles(1, 1, 1, :XYZ);\n\njulia> angle_to_angleaxis(Θ)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.93909 rad  (111.102°)\n  Euler axis  : [0.692363, 0.203145, 0.692363]\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_dcm-Union{Tuple{T}, Tuple{T, Symbol}} where T<:Number","page":"Library","title":"ReferenceFrameRotations.angle_to_dcm","text":"angle_to_dcm(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX) -> DCM\nangle_to_dcm(Θ::EulerAngles) -> DCM\n\nCreate a direction cosine matrix that perform a set of rotations (θ₁, θ₂, θ₃) about the coordinate axes specified in rot_seq.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible values depends on the number of rotations as follows:\n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX,   :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nRemarks\n\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i ∈ [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nExample\n\njulia> angle_to_dcm(pi / 2, :X)\nDCM{Float64}:\n 1.0   0.0          0.0\n 0.0   6.12323e-17  1.0\n 0.0  -1.0          6.12323e-17\n\njulia> angle_to_dcm(pi / 5, pi / 7, :YZ)\nDCM{Float64}:\n  0.728899  0.433884  -0.529576\n -0.351019  0.900969   0.25503\n  0.587785  0.0        0.809017\n\njulia> angle_to_dcm(pi / 5, pi / 7, 0, :YZY)\nDCM{Float64}:\n  0.728899  0.433884  -0.529576\n -0.351019  0.900969   0.25503\n  0.587785  0.0        0.809017\n\njulia> dcm = angle_to_dcm(pi / 2, pi / 3, pi / 4, :ZYX)\nDCM{Float64}:\n  3.06162e-17  0.5       -0.866025\n -0.707107     0.612372   0.353553\n  0.707107     0.612372   0.353553\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_quat-Tuple{Number, Symbol}","page":"Library","title":"ReferenceFrameRotations.angle_to_quat","text":"angle_to_quat(θ₁::T1[, θ₂::T2[, θ₃::T3]], rot_seq::Symbol = :ZYX) where {T1<:Number, T2<:Number, T3<:Number} -> Quaternion\nangle_to_quat(eulerang::EulerAngles) -> Quaternion\n\nCreate a quaternion that perform a set of rotations (θ₁, θ₂, θ₃) about the coordinate axes specified in rot_seq.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible values depends on the number of rotations as follows:\n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX,   :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThe type of the new quaternion will be obtained by promiting T1, T2, and T3.\n\nRemarks\n\nThis function assigns q = q1 * q2 * q3 in which qi is the quaternion related with the i-th rotation, i ∈ [1,2,3]. If the i-th rotation is not specified, then qi = Quaternion(I).\n\nExample\n\njulia> angle_to_quat(pi / 2, :X)\nQuaternion{Float64}:\n  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> angle_to_quat(pi / 5, pi / 7, :YZ)\nQuaternion{Float64}:\n  + 0.927212 + 0.0687628⋅i + 0.301269⋅j + 0.21163⋅k\n\njulia> angle_to_quat(pi / 5, pi / 7, 0, :YZX)\nQuaternion{Float64}:\n  + 0.927212 + 0.0687628⋅i + 0.301269⋅j + 0.21163⋅k\n\njulia> angle_to_quat(pi / 2, pi / 3, pi / 4, :ZYX)\nQuaternion{Float64}:\n  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.430459⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_rot-Tuple{Number, Symbol}","page":"Library","title":"ReferenceFrameRotations.angle_to_rot","text":"angle_to_rot([T,] θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol) -> T\nangle_to_rot([T,] Θ::EulerAngles) -> T\n\nCreate a rotation description of type T that perform a set of rotations (θ₁, θ₂, θ₃) about the coordinate axes specified in rot_seq.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible values depends on the number of rotations as follows:\n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX,   :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nExample\n\njulia> dcm = angle_to_rot(pi / 5, :Z)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.809017  0.587785  0.0\n -0.587785  0.809017  0.0\n  0.0       0.0       1.0\n\njulia> quat = angle_to_rot(Quaternion, pi / 5, :Z)\nQuaternion{Float64}:\n  + 0.951057 + 0.0⋅i + 0.0⋅j + 0.309017⋅k\n\njulia> dcm = angle_to_rot(pi / 5, pi / 7, :YZ)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.728899  0.433884  -0.529576\n -0.351019  0.900969   0.25503\n  0.587785  0.0        0.809017\n\njulia> quat = angle_to_rot(Quaternion, pi / 5, pi / 7, :YZ)\nQuaternion{Float64}:\n  + 0.927212 + 0.0687628⋅i + 0.301269⋅j + 0.21163⋅k\n\njulia> dcm = angle_to_rot(pi / 2, pi / 3, pi / 4, :ZYX)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  3.06162e-17  0.5       -0.866025\n -0.707107     0.612372   0.353553\n  0.707107     0.612372   0.353553\n\njulia> q = angle_to_rot(Quaternion, pi / 2, pi / 3, pi / 4, :ZYX)\nQuaternion{Float64}:\n  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.430459⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector, Symbol}","page":"Library","title":"ReferenceFrameRotations.angleaxis_to_angle","text":"angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol) -> EulerAngles\nangleaxis_to_angle(av::EulerAngleAxis, rot_seq::Symbol) -> EulerAngles\n\nConvert the Euler angle θ [rad]  and Euler axis v to Euler angles with rotation sequence rot_seq.\n\nThose values can also be passed inside the structure av (see EulerAngleAxis).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, it defaults to :ZYX.\n\nwarning: Warning\nIt is expected that the vector v is unitary. However, no verification is performed inside the function. The user must handle this situation.\n\nExample\n\njulia> av = EulerAngleAxis(deg2rad(45), [1, 0, 0]);\n\njulia> angleaxis_to_angle(av, :ZXY)\nEulerAngles{Float64}:\n  R(Z) :  0.0      rad  ( 0.0°)\n  R(X) :  0.785398 rad  ( 45.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angleaxis_to_dcm-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}}} where {T1, T2}","page":"Library","title":"ReferenceFrameRotations.angleaxis_to_dcm","text":"angleaxis_to_dcm(a::Number, v::AbstractVector) -> DCM\nangleaxis_to_dcm(av::EulerAngleAxis) -> DCM\n\nConvert the Euler angle a [rad] and Euler axis v to a DCM.\n\nThose values can also be passed inside the structure ea (see EulerAngleAxis).\n\nwarning: Warning\nIt is expected that the vector v is unitary. However, no verification is performed inside the function. The user must handle this situation.\n\nExample\n\njulia> v = [1, 1, 1];\n\njulia> v /= norm(v);\n\njulia> angleaxis_to_dcm(pi / 2, v)\nDCM{Float64}:\n  0.333333   0.910684  -0.244017\n -0.244017   0.333333   0.910684\n  0.910684  -0.244017   0.333333\n\njulia> ea = EulerAngleAxis(pi / 2, v);\n\njulia> angleaxis_to_dcm(ea)\nDCM{Float64}:\n  0.333333   0.910684  -0.244017\n -0.244017   0.333333   0.910684\n  0.910684  -0.244017   0.333333\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angleaxis_to_quat-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}}} where {T1, T2}","page":"Library","title":"ReferenceFrameRotations.angleaxis_to_quat","text":"angleaxis_to_quat(θ::Number, v::AbstractVector) -> Quaternion\nangleaxis_to_quat(angleaxis::EulerAngleAxis) -> Quaternion\n\nConvert the Euler angle θ [rad] and Euler axis v to a quaternion.\n\nThose values can also be passed inside the structure ea (see EulerAngleAxis).\n\nwarning: Warning\nIt is expected that the vector v is unitary. However, no verification is performed inside the function. The user must handle this situation.\n\nExample\n\njulia> v = [1, 1, 1];\n\njulia> v /= norm(v);\n\njulia> angleaxis_to_quat(pi / 2, v)\nQuaternion{Float64}:\n  + 0.707107 + 0.408248⋅i + 0.408248⋅j + 0.408248⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.compose_rotation-Tuple{DCM}","page":"Library","title":"ReferenceFrameRotations.compose_rotation","text":"compose_rotation(R1::T, [, R2::T, R3::T, R4::T, R5::T, ...]) -> T\n\nCompute a composed rotation using the rotations R1, R2, R3, R4, ..., in the following order:\n\n First rotation\n |\n |\nR1 => R2 => R3 => R4 => ...\n       |\n       |\n       Second rotation\n\nThe rotations can be described by:\n\nA direction cosine matrix (DCM);\nAn Euler angle and axis (EulerAngleAxis);\nA set of Euler angles (EulerAngles);\nA quaternion (Quaternion);\nClassical Rodrigues parameters (CRP); or\nModified Rodrigues parameters (MRP).\n\nNotice, however, that all rotations must be of the same type.\n\nThe output will have the same type as the inputs.\n\nExample\n\njulia> D1 = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> D2 = angle_to_dcm(-pi / 5, -pi / 4, -pi / 3, :XYZ);\n\njulia> compose_rotation(D1, D2)\nDCM{Float64}:\n 1.0          1.08801e-17  3.54837e-17\n 1.08801e-17  1.0          2.88714e-17\n 3.54837e-17  2.88714e-17  1.0\n\njulia> ea1 = EulerAngleAxis(30 * pi / 180, [0, 1, 0]);\n\njulia> ea2 = EulerAngleAxis(45 * pi / 180, [0, 1, 0]);\n\njulia> compose_rotation(ea1, ea2)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.309 rad  (75.0°)\n  Euler axis  : [0.0, 1.0, 0.0]\n\njulia> Θ1 = EulerAngles(1, 2, 3, :ZYX);\n\njulia> Θ2 = EulerAngles(-3, -2, -1, :XYZ);\n\njulia> compose_rotation(Θ1, Θ2)\nEulerAngles{Float64}:\n  R(X) : -1.66533e-16 rad  (-9.54166e-15°)\n  R(Y) :  9.24446e-33 rad  ( 5.29669e-31°)\n  R(Z) : -1.11022e-16 rad  (-6.36111e-15°)\n\njulia> q1 = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> q2 = angle_to_quat(-pi / 5, -pi / 4, -pi / 3, :XYZ);\n\njulia> compose_rotation(q1, q2)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 2.08167e-17⋅j + 5.55112e-17⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.crp_to_angle","page":"Library","title":"ReferenceFrameRotations.crp_to_angle","text":"crp_to_angle(c::CRP, rot_seq::Symbol) -> EulerAngles\n\nConvert CRP c to Euler Angles (see EulerAngles) given a rotation sequence rot_seq.\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, it defaults to :ZYX.\n\nExamples\n\njulia> c = CRP(0.5, 0, 0)\nCRP{Float64}:\n  X : + 0.5\n  Y : + 0.0\n  Z : + 0.0\n\njulia> crp_to_angle(c, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.927295 rad  ( 53.1301°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(Z) :  0.0      rad  ( 0.0°)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.crp_to_angleaxis-Tuple{CRP}","page":"Library","title":"ReferenceFrameRotations.crp_to_angleaxis","text":"crp_to_angleaxis(c::CRP) -> EulerAngleAxis\n\nConvert the CRP c to a Euler angle and axis representation (see EulerAngleAxis). By convention, the Euler angle will be kept between [0, π] rad.\n\nExamples\n\njulia> c = CRP(0.5, 0, 0)\nCRP{Float64}:\n  X : + 0.5\n  Y : + 0.0\n  Z : + 0.0\n\njulia> crp_to_angleaxis(c)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.927295 rad  (53.1301°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.crp_to_dcm-Tuple{CRP}","page":"Library","title":"ReferenceFrameRotations.crp_to_dcm","text":"crp_to_dcm(c::CRP) -> DCM\n\nConvert the CRP c to a Direction Cosine Matrix (DCM).\n\nExamples\n\njulia> c = CRP(0.5, 0, 0)\nCRP{Float64}:\n  X : + 0.5\n  Y : + 0.0\n  Z : + 0.0\n\njulia> crp_to_dcm(c)\nDCM{Float64}:\n 1.0   0.0  0.0\n 0.0   0.6  0.8\n 0.0  -0.8  0.6\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.crp_to_quat-Tuple{CRP}","page":"Library","title":"ReferenceFrameRotations.crp_to_quat","text":"crp_to_quat(c::CRP) -> Quaternion\n\nConvert CRP c to a quaternion.\n\nRemarks\n\nBy convention, the real part of the quaternion will always be positive. Moreover, the function does not check if dcm is a valid direction cosine matrix. This must be handle by the user.\n\nExample\n\njulia> c = CRP(0.5, 0, 0)\nCRP{Float64}:\n  X : + 0.5\n  Y : + 0.0\n  Z : + 0.0\n\njulia> crp_to_quat(c)\nQuaternion{Float64}:\n  + 0.894427 + 0.447214⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{DCM{T}}, Tuple{T}, Tuple{DCM{T}, Symbol}} where T<:Number","page":"Library","title":"ReferenceFrameRotations.dcm_to_angle","text":"dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX) -> EulerAngles\n\nConvert the dcm to Euler Angles (see EulerAngles) given a rotation sequence rot_seq.\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, it defaults to :ZYX.\n\nGimbal-lock and special cases\n\nIf the rotations are about three different axes, e.g. :XYZ, :ZYX, etc., then a second rotation of ±90˚ yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation, and the angle of the third rotation is set to 0.\n\nIf the rotations are about two different axes, e.g. :XYX, :YXY, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.\n\nExample\n\njulia> D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);\n\njulia> dcm_to_angle(D,:XYZ)\nEulerAngles{Float64}:\n  R(X) :  1.5708 rad  ( 90.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(Z) :  0.0    rad  ( 0.0°)\n\njulia> D = angle_to_dcm(1, -pi / 2, 2, :ZYX);\n\njulia> dcm_to_angle(D, :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  3.0    rad  ( 171.887°)\n  R(Y) : -1.5708 rad  (-90.0°)\n  R(X) :  0.0    rad  ( 0.0°)\n\njulia> D = angle_to_dcm(1, :X) * angle_to_dcm(2, :X);\n\njulia> dcm_to_angle(D, :XYX)\nEulerAngles{Float64}:\n  R(X) :  3.0 rad  ( 171.887°)\n  R(Y) :  0.0 rad  ( 0.0°)\n  R(X) :  0.0 rad  ( 0.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{DCM{T}}, Tuple{T}} where T<:Number","page":"Library","title":"ReferenceFrameRotations.dcm_to_angleaxis","text":"dcm_to_angleaxis(dcm::DCM{T}) where T<:Number -> EulerAngleAxis\n\nConvert the dcm to an Euler angle and axis representation.\n\nBy convention, the returned Euler angle will always be in the interval [0, π].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_crp-Tuple{DCM}","page":"Library","title":"ReferenceFrameRotations.dcm_to_crp","text":"dcm_to_crp(dcm::DCM) -> CRP\n\nConvert DCM dcm to CRP.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_mrp-Tuple{DCM}","page":"Library","title":"ReferenceFrameRotations.dcm_to_mrp","text":"dcm_to_mrp(dcm::DCM) -> MRP\n\nConvert DCM dcm to MRP.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_quat-Tuple{DCM}","page":"Library","title":"ReferenceFrameRotations.dcm_to_quat","text":"dcm_to_quat(dcm::DCM) -> Quaternion\n\nConvert the dcm to a quaternion.\n\nThe type of the quaternion will be automatically selected by the constructor Quaternion to avoid InexactError.\n\nRemarks\n\nBy convention, the real part of the quaternion will always be positive. Moreover, the function does not check if dcm is a valid direction cosine matrix. This must be handle by the user.\n\nThis algorithm was obtained from [1].\n\nExample\n\njulia> dcm = angle_to_dcm(pi / 2, 0.0, 0.0, :XYZ);\n\njulia> q = dcm_to_quat(dcm)\nQuaternion{Float64}:\n  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\nReferences\n\n[1]: http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcrp-Tuple{CRP, AbstractVector}","page":"Library","title":"ReferenceFrameRotations.dcrp","text":"dcrp(c::CRP, wba_b::AbstractVector) -> CRP\n\nCompute the time-derivative of the CRP c that rotates a reference frame a into alignment with the reference frame b in which the angular velocity of b with respect to a, and represented in b, is wba_b [1].\n\nExample\n\njulia> c = CRP(0.0, 0.0, 0.0)\nCRP{Float64}:\n  X : + 0.0\n  Y : + 0.0\n  Z : + 0.0\n\njulia> dcrp(c, [1.0, 0.0, 0.0])\nCRP{Float64}:\n  X : + 0.5\n  Y : + 0.0\n  Z : + 0.0\n\nReferences\n\n[1] Schaub, H.; Junkins, J. L (1996). Stereographic Orientation Parameters for   Attitude Dynamics: A Generalization of the Rodrigues Parameters. In: Journal of the   Astronautical Sciences, Vol. 44, No. 1, pp. 1 – 19.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.ddcm-Tuple{DCM, AbstractArray}","page":"Library","title":"ReferenceFrameRotations.ddcm","text":"ddcm(Dba::DCM, wba_b::AbstractArray) -> SMatrix{3, 3}\n\nCompute the time-derivative of the dcm that rotates a reference frame a into alignment with the reference frame b in which the angular velocity of b with respect to a, and represented in b, is wba_b.\n\nExample\n\njulia> D = DCM(1.0I);\n\njulia> ddcm(D, [1, 0, 0])\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 0.0   0.0  0.0\n 0.0   0.0  1.0\n 0.0  -1.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dmrp-Tuple{MRP, AbstractVector}","page":"Library","title":"ReferenceFrameRotations.dmrp","text":"dmrp(m::MRP, wba_b::AbstractVector) -> MRP\n\nCompute the time-derivative of the MRP m that rotates a reference frame a into alignment with the reference frame b in which the angular velocity of b with respect to a, and represented in b, is wba_b [1].\n\nExample\n\njulia> m = MRP(0.0, 0.0, 0.0)\nMRP{Float64}:\n  X : + 0.0\n  Y : + 0.0\n  Z : + 0.0\n\njulia> dmrp(m, [1.0, 0.0, 0.0])\nMRP{Float64}:\n  X : + 0.25\n  Y : + 0.0\n  Z : + 0.0\n\nReferences\n\n[1] Schaub, H.; Junkins, J. L (1996). Stereographic Orientation Parameters for   Attitude Dynamics: A Generalization of the Rodrigues Parameters. In: Journal of the   Astronautical Sciences, Vol. 44, No. 1, pp. 1 – 19.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector}","page":"Library","title":"ReferenceFrameRotations.dquat","text":"dquat(qba::Quaternion, wba_b::AbstractVector) -> Quaternion\n\nCompute the time-derivative of the quaternion qba that rotates a reference frame a into alignment to the reference frame b in which the angular velocity of b with respect to a, and represented in b, is wba_b.\n\nExamples\n\njulia> q = Quaternion(1.0I);\n\njulia> dquat(q,[1;0;0])\nQuaternion{Float64}:\n  - 0.0 + 0.5⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.inv_rotation-Tuple{DCM}","page":"Library","title":"ReferenceFrameRotations.inv_rotation","text":"inv_rotation(R::T) -> T\n\nCompute the inverse rotation of R, which can be:\n\nA direction cosine matrix (DCM);\nAn Euler angle and axis (EulerAngleAxis);\nA set of Euler angles (EulerAngles);\nA quaternion (Quaternion);\nA classical Rodrigues parameter (CRP); or\nA modified Rodrigues parameter (MRP).\n\nThe output will have the same type as R.\n\nnote: Note\nIf R is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the user.\n\nnote: Note\nIf R is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the user.\n\nExample\n\njulia> D = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> inv_rotation(D)\nDCM{Float64}:\n  0.353553  -0.492816  0.795068\n  0.612372   0.764452  0.201527\n -0.707107   0.415627  0.572061\n\njulia> ea = EulerAngleAxis(30 * pi / 180, [1, 0, 0]);\n\njulia> inv_rotation(ea)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.523599 rad  (30.0°)\n  Euler axis  : [-1.0, -0.0, -0.0]\n\njulia> Θ = EulerAngles(-pi / 3, -pi / 2, -pi, :YXZ);\n\njulia> inv_rotation(Θ)\nEulerAngles{Float64}:\n  R(Z) :  3.14159 rad  ( 180.0°)\n  R(X) :  1.5708  rad  ( 90.0°)\n  R(Y) :  1.0472  rad  ( 60.0°)\n\njulia> q = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> inv_rotation(q)\nQuaternion{Float64}:\n  + 0.820071 - 0.0652687⋅i - 0.45794⋅j - 0.336918⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.mrp_to_angle","page":"Library","title":"ReferenceFrameRotations.mrp_to_angle","text":"mrp_to_angle(m::MRP, rot_seq::Symbol) -> EulerAngles\n\nConvert MRP m to Euler Angles with rotation sequence rot_seq.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.mrp_to_angleaxis-Tuple{MRP}","page":"Library","title":"ReferenceFrameRotations.mrp_to_angleaxis","text":"mrp_to_angleaxis(m::MRP) -> EulerAngleAxis\n\nConvert MRP m to Euler Angle and Axis.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.mrp_to_dcm-Tuple{MRP}","page":"Library","title":"ReferenceFrameRotations.mrp_to_dcm","text":"mrp_to_dcm(m::MRP) -> DCM\n\nConvert MRP m to a Direction Cosine Matrix (DCM).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.mrp_to_quat-Tuple{MRP}","page":"Library","title":"ReferenceFrameRotations.mrp_to_quat","text":"mrp_to_quat(m::MRP) -> Quaternion\n\nConvert MRP m to a Quaternion.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.orthonormalize-Tuple{DCM}","page":"Library","title":"ReferenceFrameRotations.orthonormalize","text":"orthonormalize(dcm::DCM) -> DCM\n\nPerform the Gram-Schmidt orthonormalization process in the dcm and return the new matrix.\n\nwarning: Warning\nThis function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have NaN. Notice, however, that such input matrix is not a valid direction cosine matrix.\n\nExample\n\njulia> D = DCM(3I)\n\njulia> orthonormalize(D)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_angle","page":"Library","title":"ReferenceFrameRotations.quat_to_angle","text":"quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX) -> EulerAngles\n\nConvert the quaternion q to Euler Angles (see EulerAngles) given a rotation sequence rot_seq.\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, it defaults to :ZYX.\n\nExamples\n\njulia> q = Quaternion(cosd(45/2), sind(45/2), 0, 0);\n\njulia> quat_to_angle(q, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.785398 rad  ( 45.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(Z) :  0.0      rad  ( 0.0°)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Library","title":"ReferenceFrameRotations.quat_to_angleaxis","text":"quat_to_angleaxis(q::Quaternion{T}) where T -> EulerAngleAxis\n\nConvert the quaternion q to a Euler angle and axis representation (see EulerAngleAxis). By convention, the Euler angle will be kept between [0, π] rad.\n\nRemarks\n\nThis function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.\n\nExamples\n\njulia> q = Quaternion(cosd(45/2), sind(45/2), 0, 0);\n\njulia> quat_to_angleaxis(q)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.785398 rad  (45.0°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_crp-Tuple{Quaternion}","page":"Library","title":"ReferenceFrameRotations.quat_to_crp","text":"quat_to_crp(q::Quaternion) -> CRP\n\nConvert Quaternion q to CRP.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}","page":"Library","title":"ReferenceFrameRotations.quat_to_dcm","text":"quat_to_dcm(q::Quaternion) -> DCM\n\nConvert the quaternion q to a Direction Cosine Matrix (DCM).\n\nExamples\n\njulia> q = Quaternion(cosd(45/2), sind(45/2), 0, 0);\n\njulia> quat_to_dcm(q)\nDCM{Float64}:\n 1.0   0.0       0.0\n 0.0   0.707107  0.707107\n 0.0  -0.707107  0.707107\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_mrp-Tuple{Quaternion}","page":"Library","title":"ReferenceFrameRotations.quat_to_mrp","text":"quat_to_mrp(q::Quaternion) -> MRP\n\nConvert Quaternion q to MRP.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.shadow_rotation-Tuple{CRP}","page":"Library","title":"ReferenceFrameRotations.shadow_rotation","text":"shadow_rotation(c::CRP) -> CRP\n\nCompute the shadow rotation of the CRP c.\n\nThe shadow rotation of a CRP is the rotation itself: c.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.shadow_rotation-Tuple{MRP}","page":"Library","title":"ReferenceFrameRotations.shadow_rotation","text":"shadow_rotation(m::MRP) -> MRP\n\nCompute the shadow rotation of the MRP m.\n\nThe shadow rotation of a MRP m is formed by the values q such that:\n\n|q| > 1\n\nand represents the same rotation as m.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.smallangle_to_dcm-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"ReferenceFrameRotations.smallangle_to_dcm","text":"smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true) -> DCM\n\nCreate a direction cosine matrix from three small rotations of angles θx, θy, and θz [rad] about the axes X, Y, and Z, respectively.\n\nIf the keyword normalize is true, the matrix will be normalized using the function orthonormalize.\n\nExample\n\njulia> smallangle_to_dcm(+0.01, -0.01, +0.01)\nDCM{Float64}:\n  0.9999     0.00989903  0.010098\n -0.009999   0.999901    0.00989802\n -0.009999  -0.009998    0.9999\n\njulia> smallangle_to_dcm(+0.01, -0.01, +0.01; normalize = false)\nDCM{Float64}:\n  1.0    0.01  0.01\n -0.01   1.0   0.01\n -0.01  -0.01  1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.smallangle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"ReferenceFrameRotations.smallangle_to_quat","text":"smallangle_to_quat(θx::Number, θy::Number, θz::Number) -> Quaternion\n\nCreate a quaternion from three small rotations of angles θx, θy, and θz [rad] about the axes X, Y, and Z, respectively.\n\nnote: Note\nThe quaternion is always normalized.\n\nExample\n\njulia> smallangle_to_quat(+0.01, -0.01, +0.01)\nQuaternion{Float64}:\n  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j + 0.00499981⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}","page":"Library","title":"ReferenceFrameRotations.smallangle_to_rot","text":"smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number[; normalize = true]) -> T\n\nCreate a rotation description of type T from three small rotations of angles θx, θy, and θz [rad] about the axes X, Y, and Z, respectively.\n\nThe type T of the rotation description can be DCM or Quaternion. If the type T is not specified, if defaults to DCM.\n\nIf T is DCM, the resulting matrix will be orthonormalized using the orthonormalize function if the keyword normalize is true.\n\nExample\n\njulia> dcm = smallangle_to_rot(+0.01, -0.01, +0.01)\nDCM{Float64}:\n  0.9999     0.00989903  0.010098\n -0.009999   0.999901    0.00989802\n -0.009999  -0.009998    0.9999\n\njulia> dcm = smallangle_to_rot(+0.01, -0.01, +0.01; normalize = false)\nDCM{Float64}:\n  1.0    0.01  0.01\n -0.01   1.0   0.01\n -0.01  -0.01  1.0\n\njulia> q = smallangle_to_rot(Quaternion, +0.01, -0.01, +0.01)\nQuaternion{Float64}:\n  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j + 0.00499981⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.vect-Tuple{CRP}","page":"Library","title":"ReferenceFrameRotations.vect","text":"vect(c::CRP) -> SVector{3, T}\n\nReturn the vector definition of the CRP c:\n\n[q1, q2, q3]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.vect-Tuple{MRP}","page":"Library","title":"ReferenceFrameRotations.vect","text":"vect(m::MRP) -> SVector{3, T}\n\nReturn the vector definition of the MRP m:\n\n[q1, q2, q3]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.vect-Tuple{Quaternion}","page":"Library","title":"ReferenceFrameRotations.vect","text":"vect(q::Quaternion{T}) -> SVector{3, T}\n\nReturn the vectorial or imaginary part of the quaternion q represented by a 3 × 1 vector of type SVector{3, T}.\n\nSee also: imag, real\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k\n\njulia> vect(q)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.9659258262890683\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"man/dcm/#Direction-Cosine-Matrices","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"Direction cosine matrices, or DCMs, are 3 times 3 matrices that represent a coordinate transformation between two orthonormal reference frames. Let those frames be right-handed, then it can be shown that this transformation is always a rotation. Thus, a DCM that rotates the reference frame a into alignment with the reference frame b is:\n\nmathbfD_ba = leftbeginmatrix\n    a_11  a_12  a_13 \n    a_21  a_22  a_23 \n    a_31  a_32  a_33\n    endmatrixright\n\nIn ReferenceFrameRotations.jl, a DCM is a 3 times 3 static matrix, i.e. it is immutable.","category":"section"},{"location":"man/dcm/#Initialization","page":"Direction Cosine Matrices","title":"Initialization","text":"Usually, a DCM is initialized by converting a more \"visual\" rotation representation, such as the Euler angles (see Conversions). However, it can be initialized by the following methods:\n\nIdentity DCM.\n\nDCM(I)  # Create a Boolean DCM, this can be used to save space.\n\nDCM(Int64(1)I)  # Create an Integer DCM.\n\nDCM(1.f0I) # Create a Float32 DCM.\n\nDCM(1.0I)  # Create a Float64 DCM.\n\nUser-defined DCM.\n\nDCM([-1 0 0; 0 -1 0; 0 0 1])\n\nDCM([-1.f0 0.f0 0.f0; 0.f0 -1.f0 0.f0; 0.f0 0.f0 1.f0])\n\nDCM([-1.0 0.0 0.0; 0.0 -1.0 0.0; 0.0 0.0 1.0])\n\nnote: Note\nThe type of the DCM will depend on the type of the input.\n\nwarning: Warning\nThis initialization method will not verify if the input data is indeed a DCM.","category":"section"},{"location":"man/dcm/#Operations","page":"Direction Cosine Matrices","title":"Operations","text":"Since a DCM is a static matrix (<: StaticMatrix), then all the operations available for general matrices in Julia are also available for DCMs.","category":"section"},{"location":"man/dcm/#Orthonomalization","page":"Direction Cosine Matrices","title":"Orthonomalization","text":"A DCM can be orthonormalized using the Gram-Schmidt algorithm by the function:\n\nfunction orthonormalize(dcm::DCM)\n\nD = DCM([2 0 0; 0 2 0; 0 0 2])\n\northonormalize(D)\n\nD = DCM(3.0f0I);\n\northonormalize(D)\n\nD = DCM(1, 1, 2, 2, 3, 3, 4, 4, 5);\n\nDn = orthonormalize(D)\n\nDn * Dn'\n\nwarning: Warning\nThis function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have NaN. Notice, however, that such input matrix is not a valid direction cosine matrix.","category":"section"},{"location":"man/inv_rotations/#Inverting-rotations","page":"Inverting rotations","title":"Inverting rotations","text":"A rotation represented by direction cosine matrix or quaternion can be inverted using the function:\n\ninv_rotation(R)\n\nin which R must be a DCM or a Quaternion.\n\nnote: Note\nIf R is a DCM, then the transpose matrix will be returned. Hence, the user must ensure that the input matrix is ortho-normalized. Otherwise, the result will not be the inverse matrix of the input.If R is a Quaternion, then the conjugate quaternion will be returned. Hence, the user must ensure that the input quaternion is normalized (have unit norm). Otherwise, the result will not be the inverse quaternion of the input.These behaviors were selected to alleviate the computational burden.\n\nD1 = angle_to_dcm(0.5, 0.5, 0.5, :XYZ)\n\nD2 = inv_rotation(D1)\n\nD2 * D1\n\nq1 = angle_to_quat(0.5, 0.5, 0.5, :XYZ)\n\nq2 = inv_rotation(q1)\n\nq2 * q1","category":"section"},{"location":"#ReferenceFrameRotations.jl","page":"Home","title":"ReferenceFrameRotations.jl","text":"This module contains functions related to 3D rotations of reference frames. It is used on a daily basis on projects at the Brazilian National Institute for Space Research (INPE).","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package can be installed using:\n\njulia> Pkg.update()\njulia> Pkg.add(\"ReferenceFrameRotations\")","category":"section"},{"location":"#Status","page":"Home","title":"Status","text":"This packages supports the following representations of 3D rotations:\n\nEuler Angle and Axis;\nEuler Angles;\nDirection Cosine Matrices (DCMs);\nQuaternions.\n\nHowever, composing rotations is only currently supported for DCMs and Quaternions.","category":"section"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"This package will be continuously enhanced. Next steps will be to add other representations of 3D rotations such as Rodrigues parameters, etc.","category":"section"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"Pages = [\n    \"man/dcm.md\",\n    \"man/euler_angle_axis.md\",\n    \"man/euler_angles.md\",\n    \"man/quaternions.md\",\n    \"man/conversions.md\",\n    \"man/kinematics.md\",\n    \"man/composing_rotations.md\",\n    \"man/inv_rotations.md\",\n]\nDepth = 2","category":"section"},{"location":"#Library-documentation","page":"Home","title":"Library documentation","text":"Pages = [\"lib/library.md\"]","category":"section"}]
}
