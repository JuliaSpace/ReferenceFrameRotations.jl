<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions · Reference Frame Rotations</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/man/conversions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Reference Frame Rotations</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../dcm/">Direction Cosine Matrices</a></li><li><a class="tocitem" href="../euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="tocitem" href="../euler_angles/">Euler Angles</a></li><li><a class="tocitem" href="../quaternions/">Quaternions</a></li><li class="is-active"><a class="tocitem" href>Conversions</a><ul class="internal"><li><a class="tocitem" href="#DCMs-to-Euler-Angles"><span>DCMs to Euler Angles</span></a></li><li><a class="tocitem" href="#DCMs-to-Euler-Angle-and-Axis"><span>DCMs to Euler Angle and Axis</span></a></li><li><a class="tocitem" href="#DCMs-to-Quaternions"><span>DCMs to Quaternions</span></a></li><li><a class="tocitem" href="#Euler-Angle-and-Axis-to-DCMs"><span>Euler Angle and Axis to DCMs</span></a></li><li><a class="tocitem" href="#Euler-Angle-and-Axis-to-Euler-Angles"><span>Euler Angle and Axis to Euler Angles</span></a></li><li><a class="tocitem" href="#Euler-Angle-and-Axis-to-Quaternions"><span>Euler Angle and Axis to Quaternions</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Direction-Cosine-Matrices"><span>Euler Angles to Direction Cosine Matrices</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Euler-Angles"><span>Euler Angles to Euler Angles</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Euler-angle-and-axis"><span>Euler Angles to Euler angle and axis</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Quaternions"><span>Euler Angles to Quaternions</span></a></li><li><a class="tocitem" href="#Small-Euler-Angles-to-Direction-Cosine-Matrices"><span>Small Euler Angles to Direction Cosine Matrices</span></a></li><li><a class="tocitem" href="#Small-Euler-Angles-to-Quaternions"><span>Small Euler Angles to Quaternions</span></a></li><li><a class="tocitem" href="#Quaternions-to-Direction-Cosine-Matrices"><span>Quaternions to Direction Cosine Matrices</span></a></li><li><a class="tocitem" href="#Quaternions-to-Euler-Angle-and-Axis"><span>Quaternions to Euler Angle and Axis</span></a></li><li><a class="tocitem" href="#Quaternions-to-Euler-Angles"><span>Quaternions to Euler Angles</span></a></li><li class="toplevel"><a class="tocitem" href="#Julia-API"><span>Julia API</span></a></li></ul></li><li><a class="tocitem" href="../kinematics/">Kinematics</a></li><li><a class="tocitem" href="../composing_rotations/">Composing rotations</a></li><li><a class="tocitem" href="../inv_rotations/">Inverting rotations</a></li><li><a class="tocitem" href="../random/">Random rotations</a></li><li><a class="tocitem" href="../../lib/library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Conversions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conversions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/master/docs/src/man/conversions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h1><p>There are several functions available to convert between the different types of 3D rotation representations.</p><h2 id="DCMs-to-Euler-Angles"><a class="docs-heading-anchor" href="#DCMs-to-Euler-Angles">DCMs to Euler Angles</a><a id="DCMs-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#DCMs-to-Euler-Angles" title="Permalink"></a></h2><p>A Direction Cosine Matrix (DCM) can be converted to Euler Angles using the following function:</p><pre><code class="language-julia hljs">function dcm_to_angle(dcm::DCM, rot_seq=:ZYX)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><strong>Gimbal-lock and special cases</strong></p><p>If the rotations are about three different axes, <em>e.g.</em> <code>:XYZ</code>, <code>:ZYX</code>, etc., then a second rotation of <span>$\pm 90^{\circ}$</span> yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation and the angle of the third rotation is set to 0.</p><p>If the rotations are about two different axes, <em>e.g.</em> <code>:XYX</code>, <code>:YXY</code>, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; dcm = DCM([1 0 0; 0 0 -1; 0 1 0]);

julia&gt; dcm_to_angle(dcm)
EulerAngles{Float64}:
  R(Z) :  0.0    rad  ( 0.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(X) : -1.5708 rad  (-90.0°)

julia&gt; dcm_to_angle(dcm, :XYZ)
EulerAngles{Float64}:
  R(X) : -1.5708 rad  (-90.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(Z) :  0.0    rad  ( 0.0°)

julia&gt; D = angle_to_dcm(1, -pi / 2, 2, :ZYX);

julia&gt; dcm_to_angle(D, :ZYX)
EulerAngles{Float64}:
  R(Z) :  3.0    rad  ( 171.887°)
  R(Y) : -1.5708 rad  (-90.0°)
  R(X) :  0.0    rad  ( 0.0°)

julia&gt; D = angle_to_dcm(1, :X) * angle_to_dcm(2, :X);

julia&gt; dcm_to_angle(D, :XYX)
EulerAngles{Float64}:
  R(X) :  3.0 rad  ( 171.887°)
  R(Y) :  0.0 rad  ( 0.0°)
  R(X) :  0.0 rad  ( 0.0°)</code></pre><h2 id="DCMs-to-Euler-Angle-and-Axis"><a class="docs-heading-anchor" href="#DCMs-to-Euler-Angle-and-Axis">DCMs to Euler Angle and Axis</a><a id="DCMs-to-Euler-Angle-and-Axis-1"></a><a class="docs-heading-anchor-permalink" href="#DCMs-to-Euler-Angle-and-Axis" title="Permalink"></a></h2><p>A DCM can be converto to an Euler angle and axis representation using the following method:</p><pre><code class="language-julia hljs">function dcm_to_angleaxis(dcm::DCM)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; dcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0]);

julia&gt; ea  = dcm_to_angleaxis(dcm)
EulerAngleAxis{Float64}:
  Euler angle : 1.5708 rad  (90.0°)
  Euler axis  : [-1.0, 0.0, 0.0]</code></pre><h2 id="DCMs-to-Quaternions"><a class="docs-heading-anchor" href="#DCMs-to-Quaternions">DCMs to Quaternions</a><a id="DCMs-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#DCMs-to-Quaternions" title="Permalink"></a></h2><p>A DCM can be converted to quaternion using the following method:</p><pre><code class="language-julia hljs">function dcm_to_quat(dcm::DCM)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; dcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0]);

julia&gt; q   = dcm_to_quat(dcm)
Quaternion{Float64}:
  + 0.707107 - 0.707107⋅i + 0.0⋅j + 0.0⋅k</code></pre><h2 id="Euler-Angle-and-Axis-to-DCMs"><a class="docs-heading-anchor" href="#Euler-Angle-and-Axis-to-DCMs">Euler Angle and Axis to DCMs</a><a id="Euler-Angle-and-Axis-to-DCMs-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angle-and-Axis-to-DCMs" title="Permalink"></a></h2><p>An Euler angle and axis representation can be converted to DCM using using these two methods:</p><pre><code class="language-julia hljs">function angleaxis_to_dcm(a::Number, v::AbstractVector)
function angleaxis_to_dcm(ea::EulerAngleAxis)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a = 60.0 * pi / 180;

julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3)/3];

julia&gt; angleaxis_to_dcm(a, v)
DCM{Float64}:
  0.666667   0.666667  -0.333333
 -0.333333   0.666667   0.666667
  0.666667  -0.333333   0.666667

julia&gt; angleaxis = EulerAngleAxis(a, v);

julia&gt; angleaxis_to_dcm(angleaxis)
DCM{Float64}:
  0.666667   0.666667  -0.333333
 -0.333333   0.666667   0.666667
  0.666667  -0.333333   0.666667</code></pre><h2 id="Euler-Angle-and-Axis-to-Euler-Angles"><a class="docs-heading-anchor" href="#Euler-Angle-and-Axis-to-Euler-Angles">Euler Angle and Axis to Euler Angles</a><a id="Euler-Angle-and-Axis-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angle-and-Axis-to-Euler-Angles" title="Permalink"></a></h2><p>An Euler angle and axis representaion can be converto to Euler angles using these two methods:</p><pre><code class="language-julia hljs">function angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)
function angleaxis_to_angle(ea::EulerAngleAxis, rot_seq::Symbol)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a = 19.86 * pi / 180;

julia&gt; v = [0, 1, 0];

julia&gt; angleaxis_to_angle(a, v, :XYX)
EulerAngles{Float64}:
  R(X) :  0.0      rad  ( 0.0°)
  R(Y) :  0.346622 rad  ( 19.86°)
  R(X) :  0.0      rad  ( 0.0°)

julia&gt; a = 60.0 * pi / 180;

julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3];

julia&gt; angleaxis = EulerAngleAxis(a, v)
EulerAngleAxis{Float64}:
  Euler angle : 1.0472 rad  (60.0°)
  Euler axis  : [0.57735, 0.57735, 0.57735]

julia&gt; angleaxis_to_angle(angleaxis, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.463648 rad  ( 26.5651°)
  R(Y) :  0.729728 rad  ( 41.8103°)
  R(Z) :  0.463648 rad  ( 26.5651°)

julia&gt; angleaxis_to_angle(angleaxis, :ZYX)
EulerAngles{Float64}:
  R(Z) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.339837 rad  ( 19.4712°)
  R(X) :  0.785398 rad  ( 45.0°)</code></pre><h2 id="Euler-Angle-and-Axis-to-Quaternions"><a class="docs-heading-anchor" href="#Euler-Angle-and-Axis-to-Quaternions">Euler Angle and Axis to Quaternions</a><a id="Euler-Angle-and-Axis-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angle-and-Axis-to-Quaternions" title="Permalink"></a></h2><p>An Euler angle and axis representation can be converted to quaternion using these two methods:</p><pre><code class="language-julia hljs">function angleaxis_to_quat(a::Number, v::AbstractVector)
function angleaxis_to_quat(angleaxis::EulerAngleAxis)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a = 60.0 * pi / 180;

julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3];

julia&gt; angleaxis_to_quat(a,v)
Quaternion{Float64}:
  + 0.866025 + 0.288675⋅i + 0.288675⋅j + 0.288675⋅k

julia&gt; angleaxis = EulerAngleAxis(a,v);

julia&gt; angleaxis_to_quat(angleaxis)
Quaternion{Float64}:
  + 0.866025 + 0.288675⋅i + 0.288675⋅j + 0.288675⋅k</code></pre><h2 id="Euler-Angles-to-Direction-Cosine-Matrices"><a class="docs-heading-anchor" href="#Euler-Angles-to-Direction-Cosine-Matrices">Euler Angles to Direction Cosine Matrices</a><a id="Euler-Angles-to-Direction-Cosine-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Direction-Cosine-Matrices" title="Permalink"></a></h2><p>Euler angles can be converted to DCMs using the following functions:</p><pre><code class="language-julia hljs">function angle_to_dcm(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX)
function angle_to_dcm(Θ::EulerAngles)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_dcm(pi / 2, pi / 4, pi / 3, :ZYX)
DCM{Float64}:
  4.32978e-17  0.707107  -0.707107
 -0.5          0.612372   0.612372
  0.866025     0.353553   0.353553

julia&gt; angles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX);

julia&gt; dcm = angle_to_dcm(angles)
DCM{Float64}:
  4.32978e-17  0.707107  -0.707107
 -0.5          0.612372   0.612372
  0.866025     0.353553   0.353553</code></pre><p>Suppose the user desires to obtain the DCM that rotates the coordinate system about only one or two axes. In that case, it is better to use the following functions due to improved accuracy in some cases:</p><pre><code class="nohighlight hljs">function angle_to_dcm(θ₁::Number, rot_seq::Symbol)
function angle_to_dcm(θ₁::Number, θ₂::Number, rot_seq::Symbol)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; angle_to_dcm(-pi / 4, :Z)
DCM{Float64}:
 0.707107  -0.707107  0.0
 0.707107   0.707107  0.0
 0.0        0.0       1.0

julia&gt; angle_to_dcm(-pi / 4, pi / 7, :XY)
DCM{Float64}:
 0.900969  -0.306802  -0.306802
 0.0        0.707107  -0.707107
 0.433884   0.637081   0.637081</code></pre><h2 id="Euler-Angles-to-Euler-Angles"><a class="docs-heading-anchor" href="#Euler-Angles-to-Euler-Angles">Euler Angles to Euler Angles</a><a id="Euler-Angles-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Euler-Angles" title="Permalink"></a></h2><p>It is possible to change the rotation sequence of a set of Euler angles using the following functions:</p><pre><code class="language-julia hljs">function angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)
function angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)</code></pre><p>in which <code>rot_seq_dest</code> is the desired rotation sequence of the result.</p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X) : -1.0472   rad  (-60.0°)
  R(Y) :  0.785398 rad  ( 45.0°)
  R(Z) : -1.5708   rad  (-90.0°)

julia&gt; angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.0    rad  ( 0.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(Z) : -1.5708 rad  (-90.0°)

julia&gt; Θ = EulerAngles(1, 2, 3, :XYX)
EulerAngles{Int64}:
  R(X) :  1 rad  ( 57.2958°)
  R(Y) :  2 rad  ( 114.592°)
  R(X) :  3 rad  ( 171.887°)

julia&gt; angle_to_angle(Θ, :ZYZ)
EulerAngles{Float64}:
  R(Z) : -2.70239 rad  (-154.836°)
  R(Y) :  1.46676 rad  ( 84.0393°)
  R(Z) : -1.05415 rad  (-60.3984°)</code></pre><h2 id="Euler-Angles-to-Euler-angle-and-axis"><a class="docs-heading-anchor" href="#Euler-Angles-to-Euler-angle-and-axis">Euler Angles to Euler angle and axis</a><a id="Euler-Angles-to-Euler-angle-and-axis-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Euler-angle-and-axis" title="Permalink"></a></h2><p>Euler angles can be converted to an Euler angle and axis using the following functions:</p><pre><code class="language-julia hljs">function angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)
function angle_to_angleaxis(Θ::EulerAngles)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; angle_to_angleaxis(1, 0, 0, :XYZ)
EulerAngleAxis{Float64}:
  Euler angle : 1.0 rad  (57.2958°)
  Euler axis  : [1.0, 0.0, 0.0]

julia&gt; Θ = EulerAngles(1, 1, 1, :XYZ);

julia&gt; angle_to_angleaxis(Θ)
EulerAngleAxis{Float64}:
  Euler angle : 1.93909 rad  (111.102°)
  Euler axis  : [0.692363, 0.203145, 0.692363]</code></pre><h2 id="Euler-Angles-to-Quaternions"><a class="docs-heading-anchor" href="#Euler-Angles-to-Quaternions">Euler Angles to Quaternions</a><a id="Euler-Angles-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Quaternions" title="Permalink"></a></h2><p>Euler angles can be converted to quaternions using the following functions:</p><pre><code class="language-julia hljs">function angle_to_quat(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX)
function angle_to_quat(Θ::EulerAngles)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; q = angle_to_quat(pi / 2, pi / 4, pi / 3, :ZYX)
Quaternion{Float64}:
  + 0.701057 + 0.092296⋅i + 0.560986⋅j + 0.430459⋅k

julia&gt; angles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX);

julia&gt; q = angle_to_quat(angles)
Quaternion{Float64}:
  + 0.701057 + 0.092296⋅i + 0.560986⋅j + 0.430459⋅k</code></pre><p>Suppose the user desires to obtain the quaternion that rotates the coordinate system about only one or two axes. In that case, it is better to use the following functions due to improved accuracy in some cases:</p><pre><code class="nohighlight hljs">function angle_to_quat(θ₁::Number, rot_seq::Symbol)
function angle_to_quat(θ₁::Number, θ₂::Number, rot_seq::Symbol)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; angle_to_quat(-pi / 4, :Z)
Quaternion{Float64}:
  + 0.92388 + 0.0⋅i + 0.0⋅j - 0.382683⋅k

julia&gt; angle_to_quat(-pi / 4, pi / 7, :XY)
Quaternion{Float64}:
  + 0.900716 - 0.373089⋅i + 0.205583⋅j - 0.0851551⋅k</code></pre><h2 id="Small-Euler-Angles-to-Direction-Cosine-Matrices"><a class="docs-heading-anchor" href="#Small-Euler-Angles-to-Direction-Cosine-Matrices">Small Euler Angles to Direction Cosine Matrices</a><a id="Small-Euler-Angles-to-Direction-Cosine-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Euler-Angles-to-Direction-Cosine-Matrices" title="Permalink"></a></h2><p>Small Euler angles can be converted to DCMs using the following function:</p><pre><code class="language-julia hljs">function smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)</code></pre><p>in which the resulting matrix will be orthonormalized if the keyword <code>normalize</code> is <code>true</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dcm = smallangle_to_dcm(0.001, -0.002, +0.003)
DCM{Float64}:
  0.999994     0.00299799   0.00200298
 -0.00299998   0.999995     0.000993989
 -0.00199999  -0.000999991  0.999998

julia&gt; dcm = smallangle_to_dcm(0.001, -0.002, +0.003; normalize = false)
DCM{Float64}:
  1.0     0.003  0.002
 -0.003   1.0    0.001
 -0.002  -0.001  1.0</code></pre><h2 id="Small-Euler-Angles-to-Quaternions"><a class="docs-heading-anchor" href="#Small-Euler-Angles-to-Quaternions">Small Euler Angles to Quaternions</a><a id="Small-Euler-Angles-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Euler-Angles-to-Quaternions" title="Permalink"></a></h2><p>Small Euler angles can be converted to quaternions using the following function:</p><pre><code class="language-julia hljs">function smallangle_to_quat(θx::Number, θy::Number, θz::Number)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; q = smallangle_to_quat(0.001, -0.002, +0.003)
Quaternion{Float64}:
  + 0.999998 + 0.000499999⋅i - 0.000999998⋅j + 0.0015⋅k</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The computed quaternion <strong>is</strong> normalized.</p></div></div><h2 id="Quaternions-to-Direction-Cosine-Matrices"><a class="docs-heading-anchor" href="#Quaternions-to-Direction-Cosine-Matrices">Quaternions to Direction Cosine Matrices</a><a id="Quaternions-to-Direction-Cosine-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions-to-Direction-Cosine-Matrices" title="Permalink"></a></h2><p>A quaternion can be converted to DCM using the following method:</p><pre><code class="language-julia hljs">function quat_to_dcm(q::Quaternion)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);

julia&gt; dcm = quat_to_dcm(q)
DCM{Float64}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre><h2 id="Quaternions-to-Euler-Angle-and-Axis"><a class="docs-heading-anchor" href="#Quaternions-to-Euler-Angle-and-Axis">Quaternions to Euler Angle and Axis</a><a id="Quaternions-to-Euler-Angle-and-Axis-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions-to-Euler-Angle-and-Axis" title="Permalink"></a></h2><p>A quaternion can be converted to Euler Angle and Axis representation using the following function:</p><pre><code class="language-julia hljs">function quat_to_angleaxis(q::Quaternion)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3];

julia&gt; a = 60.0 * pi / 180;

julia&gt; q = Quaternion(cos(a / 2), v * sin(a / 2));

julia&gt; quat_to_angleaxis(q)
EulerAngleAxis{Float64}:
  Euler angle : 1.0472 rad  (60.0°)
  Euler axis  : [0.57735, 0.57735, 0.57735]</code></pre><h2 id="Quaternions-to-Euler-Angles"><a class="docs-heading-anchor" href="#Quaternions-to-Euler-Angles">Quaternions to Euler Angles</a><a id="Quaternions-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions-to-Euler-Angles" title="Permalink"></a></h2><p>There is one method to convert quaternions to Euler Angles:</p><pre><code class="language-julia hljs">function quat_to_angle(q::Quaternion, rot_seq=:ZYX)</code></pre><p>However, it first transforms the quaternion to DCM using <code>quat_to_dcm</code> and then transforms the DCM into the Euler Angles. Hence, the performance will be poor. The improvement of this conversion will be addressed in a future version of <strong>ReferenceFrameRotations.jl</strong>.</p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);

julia&gt; quat_to_angle(q, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(Z) :  0.0      rad  ( 0.0°)</code></pre><h1 id="Julia-API"><a class="docs-heading-anchor" href="#Julia-API">Julia API</a><a id="Julia-API-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-API" title="Permalink"></a></h1><p>All the rotation representations can be converted using the Julia API function <code>convert</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_dcm(pi / 4, pi / 7, pi / 5)
DCM{Float64}:
  0.637081   0.637081  -0.433884
 -0.391728   0.752395   0.529576
  0.663835  -0.167419   0.728899

julia&gt; convert(Quaternion, dcm)
Quaternion{Float64}:
  + 0.882946 + 0.197349⋅i + 0.310811⋅j + 0.2913⋅k

julia&gt; convert(EulerAngleAxis, dcm)
EulerAngleAxis{Float64}:
  Euler angle : 0.977391 rad  (56.0004°)
  Euler axis  : [0.420362, 0.662041, 0.620481]

julia&gt; q = Quaternion(cos(pi / 4), 0, sin(pi / 4), 0)
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k

julia&gt; convert(DCM, q)
DCM{Float64}:
 2.22045e-16  0.0  -1.0
 0.0          1.0   0.0
 1.0          0.0   2.22045e-16</code></pre><p>If it is desired to convert to <code>EulerAngles</code>, then one should use the help function <code>EulerAngles(rot_seq)</code>, where <code>rot_seq</code> is a symbol specifying the rotation sequence. If <code>EulerAngles</code> is used, then it defaults to <code>ZYX</code> rotation sequence:</p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_dcm(pi / 4, pi / 7, pi / 5)
DCM{Float64}:
  0.637081   0.637081  -0.433884
 -0.391728   0.752395   0.529576
  0.663835  -0.167419   0.728899

julia&gt; convert(EulerAngles, dcm)
EulerAngles{Float64}:
  R(Z) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.448799 rad  ( 25.7143°)
  R(X) :  0.628319 rad  ( 36.0°)

julia&gt; convert(EulerAngles(:YXY), dcm)
EulerAngles{Float64}:
  R(Y) : -0.636877 rad  (-36.4903°)
  R(X) :  0.719106 rad  ( 41.2017°)
  R(Y) :  1.31382  rad  ( 75.2761°)

julia&gt; convert(EulerAngles(:XYX), dcm)
EulerAngles{Float64}:
  R(X) :  0.972902 rad  ( 55.7432°)
  R(Y) :  0.880091 rad  ( 50.4255°)
  R(X) : -0.533107 rad  (-30.5448°)</code></pre><p>Supporting this API enables us to perform interesting conversions like:</p><pre><code class="language-julia-repl hljs">julia&gt; v = [
           Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),
           angle_to_dcm(pi / 5, pi / 10, 1),
           EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])
       ]
3-element Vector{Any}:
 Quaternion{Float64}: + 0.809017 + 0.587785⋅i + 0.0⋅j + 0.0⋅k
 [0.7694208842938134 0.5590169943749475 -0.3090169943749474; -0.10721398096693543 0.5899548616836684 0.8002864633748501; 0.6296798115691402 -0.5826261761848704 0.5138580287651915]
 EulerAngleAxis{Float64}: θ = 0.54 rad, v = [0.707107, 0.707107, 0.0]

julia&gt; v = Quaternion[
           Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),
           angle_to_dcm(pi / 5, pi / 10, 1),
           EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])
       ]
3-element Vector{Quaternion}:
 Quaternion{Float64}: + 0.809017 + 0.587785⋅i + 0.0⋅j + 0.0⋅k
 Quaternion{Float64}: + 0.847531 + 0.407924⋅i + 0.276892⋅j + 0.196521⋅k
 Quaternion{Float64}: + 0.963771 + 0.188608⋅i + 0.188608⋅j + 0.0⋅k

julia&gt; v = EulerAngleAxis[
           Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),
           angle_to_dcm(pi / 5, pi / 10, 1),
           EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])
       ]
3-element Vector{EulerAngleAxis}:
 EulerAngleAxis{Float64}: θ = 1.25664 rad, v = [1.0, 0.0, 0.0]
 EulerAngleAxis{Float64}: θ = 1.11896 rad, v = [0.768586, 0.521703, 0.370273]
 EulerAngleAxis{Float64}: θ = 0.54 rad, v = [0.707107, 0.707107, 0.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quaternions/">« Quaternions</a><a class="docs-footer-nextpage" href="../kinematics/">Kinematics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 15 January 2022 23:59">Saturday 15 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
