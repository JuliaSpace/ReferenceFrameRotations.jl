<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions · Reference Frame Rotations</title><meta name="title" content="Conversions · Reference Frame Rotations"/><meta property="og:title" content="Conversions · Reference Frame Rotations"/><meta property="twitter:title" content="Conversions · Reference Frame Rotations"/><meta name="description" content="Documentation for Reference Frame Rotations."/><meta property="og:description" content="Documentation for Reference Frame Rotations."/><meta property="twitter:description" content="Documentation for Reference Frame Rotations."/><meta property="og:url" content="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/man/conversions/"/><meta property="twitter:url" content="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/man/conversions/"/><link rel="canonical" href="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/man/conversions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Reference Frame Rotations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../dcm/">Direction Cosine Matrices</a></li><li><a class="tocitem" href="../euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="tocitem" href="../euler_angles/">Euler Angles</a></li><li><a class="tocitem" href="../quaternions/">Quaternions</a></li><li class="is-active"><a class="tocitem" href>Conversions</a><ul class="internal"><li><a class="tocitem" href="#DCMs-to-Euler-Angles"><span>DCMs to Euler Angles</span></a></li><li><a class="tocitem" href="#DCMs-to-Euler-Angle-and-Axis"><span>DCMs to Euler Angle and Axis</span></a></li><li><a class="tocitem" href="#DCMs-to-Quaternions"><span>DCMs to Quaternions</span></a></li><li><a class="tocitem" href="#Euler-Angle-and-Axis-to-DCMs"><span>Euler Angle and Axis to DCMs</span></a></li><li><a class="tocitem" href="#Euler-Angle-and-Axis-to-Euler-Angles"><span>Euler Angle and Axis to Euler Angles</span></a></li><li><a class="tocitem" href="#Euler-Angle-and-Axis-to-Quaternions"><span>Euler Angle and Axis to Quaternions</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Direction-Cosine-Matrices"><span>Euler Angles to Direction Cosine Matrices</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Euler-Angles"><span>Euler Angles to Euler Angles</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Euler-angle-and-axis"><span>Euler Angles to Euler angle and axis</span></a></li><li><a class="tocitem" href="#Euler-Angles-to-Quaternions"><span>Euler Angles to Quaternions</span></a></li><li><a class="tocitem" href="#Small-Euler-Angles-to-Direction-Cosine-Matrices"><span>Small Euler Angles to Direction Cosine Matrices</span></a></li><li><a class="tocitem" href="#Small-Euler-Angles-to-Quaternions"><span>Small Euler Angles to Quaternions</span></a></li><li><a class="tocitem" href="#Quaternions-to-Direction-Cosine-Matrices"><span>Quaternions to Direction Cosine Matrices</span></a></li><li><a class="tocitem" href="#Quaternions-to-Euler-Angle-and-Axis"><span>Quaternions to Euler Angle and Axis</span></a></li><li><a class="tocitem" href="#Quaternions-to-Euler-Angles"><span>Quaternions to Euler Angles</span></a></li><li><a class="tocitem" href="#Julia-API"><span>Julia API</span></a></li></ul></li><li><a class="tocitem" href="../kinematics/">Kinematics</a></li><li><a class="tocitem" href="../composing_rotations/">Composing rotations</a></li><li><a class="tocitem" href="../inv_rotations/">Inverting rotations</a></li><li><a class="tocitem" href="../random/">Random rotations</a></li><li><a class="tocitem" href="../../lib/library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Conversions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conversions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/master/docs/src/man/conversions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h1><p>There are several functions available to convert between the different types of 3D rotation representations.</p><h2 id="DCMs-to-Euler-Angles"><a class="docs-heading-anchor" href="#DCMs-to-Euler-Angles">DCMs to Euler Angles</a><a id="DCMs-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#DCMs-to-Euler-Angles" title="Permalink"></a></h2><p>A Direction Cosine Matrix (DCM) can be converted to Euler Angles using the following function:</p><pre><code class="language-julia hljs">function dcm_to_angle(dcm::DCM, rot_seq=:ZYX)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><strong>Gimbal-lock and special cases</strong></p><p>If the rotations are about three different axes, <em>e.g.</em> <code>:XYZ</code>, <code>:ZYX</code>, etc., then a second rotation of <span>$\pm 90^{\circ}$</span> yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation and the angle of the third rotation is set to 0.</p><p>If the rotations are about two different axes, <em>e.g.</em> <code>:XYX</code>, <code>:YXY</code>, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = DCM([1 0 0; 0 0 -1; 0 1 0])</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Int64}:
 1  0   0
 0  0  -1
 0  1   0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm_to_angle(dcm)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Z) : </span></span> 0.0    rad  ( 0.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.0    rad  ( 0.0°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span>-1.5708 rad  (-90.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm_to_angle(dcm, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span>-1.5708 rad  (-90.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.0    rad  ( 0.0°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span> 0.0    rad  ( 0.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = angle_to_dcm(1, -pi / 2, 2, :ZYX)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  3.3084e-17   5.15252e-17   1.0
 -0.14112     -0.989992      5.56784e-17
  0.989992    -0.14112      -2.54816e-17</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm_to_angle(D, :ZYX)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Z) : </span></span> 3.0    rad  ( 171.887°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span>-1.5708 rad  (-90.0°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 0.0    rad  ( 0.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = angle_to_dcm(1, :X) * angle_to_dcm(2, :X)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 1.0   0.0        0.0
 0.0  -0.989992   0.14112
 0.0  -0.14112   -0.989992</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm_to_angle(D, :XYX)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 3.0 rad  ( 171.887°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.0 rad  ( 0.0°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 0.0 rad  ( 0.0°)</code></pre><h2 id="DCMs-to-Euler-Angle-and-Axis"><a class="docs-heading-anchor" href="#DCMs-to-Euler-Angle-and-Axis">DCMs to Euler Angle and Axis</a><a id="DCMs-to-Euler-Angle-and-Axis-1"></a><a class="docs-heading-anchor-permalink" href="#DCMs-to-Euler-Angle-and-Axis" title="Permalink"></a></h2><p>A DCM can be converto to an Euler angle and axis representation using the following method:</p><pre><code class="language-julia hljs">function dcm_to_angleaxis(dcm::DCM)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0])</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 1.0  0.0   0.0
 0.0  0.0  -1.0
 0.0  1.0   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ea  = dcm_to_angleaxis(dcm)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.5708 rad  (90.0°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[-1.0, 0.0, 0.0]</code></pre><h2 id="DCMs-to-Quaternions"><a class="docs-heading-anchor" href="#DCMs-to-Quaternions">DCMs to Quaternions</a><a id="DCMs-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#DCMs-to-Quaternions" title="Permalink"></a></h2><p>A DCM can be converted to quaternion using the following method:</p><pre><code class="language-julia hljs">function dcm_to_quat(dcm::DCM)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0])</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 1.0  0.0   0.0
 0.0  0.0  -1.0
 0.0  1.0   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = dcm_to_quat(dcm)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.707107 - 0.707107⋅<span class="sgr1">i</span> + 0.0⋅<span class="sgr1">j</span> + 0.0⋅<span class="sgr1">k</span></code></pre><h2 id="Euler-Angle-and-Axis-to-DCMs"><a class="docs-heading-anchor" href="#Euler-Angle-and-Axis-to-DCMs">Euler Angle and Axis to DCMs</a><a id="Euler-Angle-and-Axis-to-DCMs-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angle-and-Axis-to-DCMs" title="Permalink"></a></h2><p>An Euler angle and axis representation can be converted to DCM using using these two methods:</p><pre><code class="language-julia hljs">function angleaxis_to_dcm(a::Number, v::AbstractVector)
function angleaxis_to_dcm(ea::EulerAngleAxis)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 60.0 * pi / 180;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3)/3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.5773502691896257
 0.5773502691896257
 0.5773502691896257</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_dcm(a, v)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.666667   0.666667  -0.333333
 -0.333333   0.666667   0.666667
  0.666667  -0.333333   0.666667</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis = EulerAngleAxis(a, v)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.0472 rad  (60.0°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[0.57735, 0.57735, 0.57735]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_dcm(angleaxis)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.666667   0.666667  -0.333333
 -0.333333   0.666667   0.666667
  0.666667  -0.333333   0.666667</code></pre><h2 id="Euler-Angle-and-Axis-to-Euler-Angles"><a class="docs-heading-anchor" href="#Euler-Angle-and-Axis-to-Euler-Angles">Euler Angle and Axis to Euler Angles</a><a id="Euler-Angle-and-Axis-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angle-and-Axis-to-Euler-Angles" title="Permalink"></a></h2><p>An Euler angle and axis representation can be converto to Euler angles using these two methods:</p><pre><code class="language-julia hljs">function angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)
function angleaxis_to_angle(ea::EulerAngleAxis, rot_seq::Symbol)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 19.86 * pi / 180</code><code class="nohighlight hljs ansi" style="display:block;">0.3466223894460738</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [0, 1, 0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 0
 1
 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_angle(a, v, :XYX)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 0.0      rad  ( 0.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.346622 rad  ( 19.86°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 0.0      rad  ( 0.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 60.0 * pi / 180</code><code class="nohighlight hljs ansi" style="display:block;">1.0471975511965976</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.5773502691896257
 0.5773502691896257
 0.5773502691896257</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis = EulerAngleAxis(a, v)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.0472 rad  (60.0°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[0.57735, 0.57735, 0.57735]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_angle(angleaxis, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 0.463648 rad  ( 26.5651°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.729728 rad  ( 41.8103°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span> 0.463648 rad  ( 26.5651°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_angle(angleaxis, :ZYX)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Z) : </span></span> 0.785398 rad  ( 45.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.339837 rad  ( 19.4712°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 0.785398 rad  ( 45.0°)</code></pre><h2 id="Euler-Angle-and-Axis-to-Quaternions"><a class="docs-heading-anchor" href="#Euler-Angle-and-Axis-to-Quaternions">Euler Angle and Axis to Quaternions</a><a id="Euler-Angle-and-Axis-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angle-and-Axis-to-Quaternions" title="Permalink"></a></h2><p>An Euler angle and axis representation can be converted to quaternion using these two methods:</p><pre><code class="language-julia hljs">function angleaxis_to_quat(a::Number, v::AbstractVector)
function angleaxis_to_quat(angleaxis::EulerAngleAxis)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 60.0 * pi / 180</code><code class="nohighlight hljs ansi" style="display:block;">1.0471975511965976</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.5773502691896257
 0.5773502691896257
 0.5773502691896257</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_quat(a,v)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.866025 + 0.288675⋅<span class="sgr1">i</span> + 0.288675⋅<span class="sgr1">j</span> + 0.288675⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis = EulerAngleAxis(a,v)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.0472 rad  (60.0°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[0.57735, 0.57735, 0.57735]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angleaxis_to_quat(angleaxis)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.866025 + 0.288675⋅<span class="sgr1">i</span> + 0.288675⋅<span class="sgr1">j</span> + 0.288675⋅<span class="sgr1">k</span></code></pre><h2 id="Euler-Angles-to-Direction-Cosine-Matrices"><a class="docs-heading-anchor" href="#Euler-Angles-to-Direction-Cosine-Matrices">Euler Angles to Direction Cosine Matrices</a><a id="Euler-Angles-to-Direction-Cosine-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Direction-Cosine-Matrices" title="Permalink"></a></h2><p>Euler angles can be converted to DCMs using the following functions:</p><pre><code class="language-julia hljs">function angle_to_dcm(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX)
function angle_to_dcm(Θ::EulerAngles)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = angle_to_dcm(pi / 2, pi / 4, pi / 3, :ZYX)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  4.32978e-17  0.707107  -0.707107
 -0.5          0.612372   0.612372
  0.866025     0.353553   0.353553</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = angle_to_dcm(angles)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  4.32978e-17  0.707107  -0.707107
 -0.5          0.612372   0.612372
  0.866025     0.353553   0.353553</code></pre><p>Suppose the user desires to obtain the DCM that rotates the coordinate system about only one or two axes. In that case, it is better to use the following functions due to improved accuracy in some cases:</p><pre><code class="language-julia hljs">function angle_to_dcm(θ₁::Number, rot_seq::Symbol)
function angle_to_dcm(θ₁::Number, θ₂::Number, rot_seq::Symbol)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_dcm(-pi / 4, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.707107  -0.707107  0.0
 0.707107   0.707107  0.0
 0.0        0.0       1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_dcm(-pi / 4, pi / 7, :XY)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.900969  -0.306802  -0.306802
 0.0        0.707107  -0.707107
 0.433884   0.637081   0.637081</code></pre><h2 id="Euler-Angles-to-Euler-Angles"><a class="docs-heading-anchor" href="#Euler-Angles-to-Euler-Angles">Euler Angles to Euler Angles</a><a id="Euler-Angles-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Euler-Angles" title="Permalink"></a></h2><p>It is possible to change the rotation sequence of a set of Euler angles using the following functions:</p><pre><code class="language-julia hljs">function angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)
function angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)</code></pre><p>in which <code>rot_seq_dest</code> is the desired rotation sequence of the result.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span>-1.0472   rad  (-60.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.785398 rad  ( 45.0°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span>-1.5708   rad  (-90.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 0.0    rad  ( 0.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.0    rad  ( 0.0°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span>-1.5708 rad  (-90.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Θ = EulerAngles(1, 2, 3, :XYX)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Int64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 1 rad  ( 57.2958°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 2 rad  ( 114.592°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 3 rad  ( 171.887°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_angle(Θ, :ZYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Z) : </span></span>-2.70239 rad  (-154.836°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 1.46676 rad  ( 84.0393°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span>-1.05415 rad  (-60.3984°)</code></pre><h2 id="Euler-Angles-to-Euler-angle-and-axis"><a class="docs-heading-anchor" href="#Euler-Angles-to-Euler-angle-and-axis">Euler Angles to Euler angle and axis</a><a id="Euler-Angles-to-Euler-angle-and-axis-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Euler-angle-and-axis" title="Permalink"></a></h2><p>Euler angles can be converted to an Euler angle and axis using the following functions:</p><pre><code class="language-julia hljs">function angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)
function angle_to_angleaxis(Θ::EulerAngles)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_angleaxis(1, 0, 0, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.0 rad  (57.2958°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[1.0, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Θ = EulerAngles(1, 1, 1, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Int64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 1 rad  ( 57.2958°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 1 rad  ( 57.2958°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span> 1 rad  ( 57.2958°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_angleaxis(Θ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.93909 rad  (111.102°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[0.692363, 0.203145, 0.692363]</code></pre><h2 id="Euler-Angles-to-Quaternions"><a class="docs-heading-anchor" href="#Euler-Angles-to-Quaternions">Euler Angles to Quaternions</a><a id="Euler-Angles-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Angles-to-Quaternions" title="Permalink"></a></h2><p>Euler angles can be converted to quaternions using the following functions:</p><pre><code class="language-julia hljs">function angle_to_quat(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX)
function angle_to_quat(Θ::EulerAngles)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = angle_to_quat(pi / 2, pi / 4, pi / 3, :ZYX)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.701057 + 0.092296⋅<span class="sgr1">i</span> + 0.560986⋅<span class="sgr1">j</span> + 0.430459⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Z) : </span></span> 1.5708   rad  ( 90.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.785398 rad  ( 45.0°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 1.0472   rad  ( 60.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = angle_to_quat(angles)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.701057 + 0.092296⋅<span class="sgr1">i</span> + 0.560986⋅<span class="sgr1">j</span> + 0.430459⋅<span class="sgr1">k</span></code></pre><p>Suppose the user desires to obtain the quaternion that rotates the coordinate system about only one or two axes. In that case, it is better to use the following functions due to improved accuracy in some cases:</p><pre><code class="language-julia hljs">function angle_to_quat(θ₁::Number, rot_seq::Symbol)
function angle_to_quat(θ₁::Number, θ₂::Number, rot_seq::Symbol)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_quat(-pi / 4, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.92388 + 0.0⋅<span class="sgr1">i</span> + 0.0⋅<span class="sgr1">j</span> - 0.382683⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle_to_quat(-pi / 4, pi / 7, :XY)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.900716 - 0.373089⋅<span class="sgr1">i</span> + 0.205583⋅<span class="sgr1">j</span> - 0.0851551⋅<span class="sgr1">k</span></code></pre><h2 id="Small-Euler-Angles-to-Direction-Cosine-Matrices"><a class="docs-heading-anchor" href="#Small-Euler-Angles-to-Direction-Cosine-Matrices">Small Euler Angles to Direction Cosine Matrices</a><a id="Small-Euler-Angles-to-Direction-Cosine-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Euler-Angles-to-Direction-Cosine-Matrices" title="Permalink"></a></h2><p>Small Euler angles can be converted to DCMs using the following function:</p><pre><code class="language-julia hljs">function smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)</code></pre><p>in which the resulting matrix will be orthonormalized if the keyword <code>normalize</code> is <code>true</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = smallangle_to_dcm(0.001, -0.002, +0.003)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.999994     0.00299799   0.00200298
 -0.00299998   0.999995     0.000993989
 -0.00199999  -0.000999991  0.999998</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = smallangle_to_dcm(0.001, -0.002, +0.003; normalize = false)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  1.0     0.003  0.002
 -0.003   1.0    0.001
 -0.002  -0.001  1.0</code></pre><h2 id="Small-Euler-Angles-to-Quaternions"><a class="docs-heading-anchor" href="#Small-Euler-Angles-to-Quaternions">Small Euler Angles to Quaternions</a><a id="Small-Euler-Angles-to-Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Euler-Angles-to-Quaternions" title="Permalink"></a></h2><p>Small Euler angles can be converted to quaternions using the following function:</p><pre><code class="language-julia hljs">function smallangle_to_quat(θx::Number, θy::Number, θz::Number)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = smallangle_to_quat(0.001, -0.002, +0.003)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.999998 + 0.000499999⋅<span class="sgr1">i</span> - 0.000999998⋅<span class="sgr1">j</span> + 0.0015⋅<span class="sgr1">k</span></code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The computed quaternion <strong>is</strong> normalized.</p></div></div><h2 id="Quaternions-to-Direction-Cosine-Matrices"><a class="docs-heading-anchor" href="#Quaternions-to-Direction-Cosine-Matrices">Quaternions to Direction Cosine Matrices</a><a id="Quaternions-to-Direction-Cosine-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions-to-Direction-Cosine-Matrices" title="Permalink"></a></h2><p>A quaternion can be converted to DCM using the following method:</p><pre><code class="language-julia hljs">function quat_to_dcm(q::Quaternion)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.92388 + 0.382683⋅<span class="sgr1">i</span> + 0.0⋅<span class="sgr1">j</span> + 0.0⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = quat_to_dcm(q)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre><h2 id="Quaternions-to-Euler-Angle-and-Axis"><a class="docs-heading-anchor" href="#Quaternions-to-Euler-Angle-and-Axis">Quaternions to Euler Angle and Axis</a><a id="Quaternions-to-Euler-Angle-and-Axis-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions-to-Euler-Angle-and-Axis" title="Permalink"></a></h2><p>A quaternion can be converted to Euler Angle and Axis representation using the following function:</p><pre><code class="language-julia hljs">function quat_to_angleaxis(q::Quaternion)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.5773502691896257
 0.5773502691896257
 0.5773502691896257</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 60.0 * pi / 180</code><code class="nohighlight hljs ansi" style="display:block;">1.0471975511965976</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Quaternion(cos(a / 2), v * sin(a / 2))</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.866025 + 0.288675⋅<span class="sgr1">i</span> + 0.288675⋅<span class="sgr1">j</span> + 0.288675⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_to_angleaxis(q)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>1.0472 rad  (60.0°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[0.57735, 0.57735, 0.57735]</code></pre><h2 id="Quaternions-to-Euler-Angles"><a class="docs-heading-anchor" href="#Quaternions-to-Euler-Angles">Quaternions to Euler Angles</a><a id="Quaternions-to-Euler-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions-to-Euler-Angles" title="Permalink"></a></h2><p>There is one method to convert quaternions to Euler Angles:</p><pre><code class="language-julia hljs">function quat_to_angle(q::Quaternion, rot_seq=:ZYX)</code></pre><p>However, it first transforms the quaternion to DCM using <code>quat_to_dcm</code> and then transforms the DCM into the Euler Angles. Hence, the performance will be poor. The improvement of this conversion will be addressed in a future version of <strong>ReferenceFrameRotations.jl</strong>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.92388 + 0.382683⋅<span class="sgr1">i</span> + 0.0⋅<span class="sgr1">j</span> + 0.0⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_to_angle(q, :XYZ)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 0.785398 rad  ( 45.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.0      rad  ( 0.0°)
<span class="sgr34"><span class="sgr1">  R(Z) : </span></span> 0.0      rad  ( 0.0°)</code></pre><h2 id="Julia-API"><a class="docs-heading-anchor" href="#Julia-API">Julia API</a><a id="Julia-API-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-API" title="Permalink"></a></h2><p>All the rotation representations can be converted using the Julia API function <code>convert</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = angle_to_dcm(pi / 4, pi / 7, pi / 5)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.637081   0.637081  -0.433884
 -0.391728   0.752395   0.529576
  0.663835  -0.167419   0.728899</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Quaternion, dcm)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.882946 + 0.197349⋅<span class="sgr1">i</span> + 0.310811⋅<span class="sgr1">j</span> + 0.2913⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(EulerAngleAxis, dcm)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngleAxis{Float64}:
<span class="sgr32"><span class="sgr1">  Euler angle : </span></span>0.977391 rad  (56.0004°)
<span class="sgr33"><span class="sgr1">  Euler axis  : </span></span>[0.420362, 0.662041, 0.620481]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Quaternion(cos(pi / 4), 0, sin(pi / 4), 0)</code><code class="nohighlight hljs ansi" style="display:block;">Quaternion{Float64}:
  + 0.707107 + 0.0⋅<span class="sgr1">i</span> + 0.707107⋅<span class="sgr1">j</span> + 0.0⋅<span class="sgr1">k</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(DCM, q)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 2.22045e-16  0.0  -1.0
 0.0          1.0   0.0
 1.0          0.0   2.22045e-16</code></pre><p>If it is desired to convert to <code>EulerAngles</code>, then one should use the help function <code>EulerAngles(rot_seq)</code>, where <code>rot_seq</code> is a symbol specifying the rotation sequence. If <code>EulerAngles</code> is used, then it defaults to <code>ZYX</code> rotation sequence:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm = angle_to_dcm(pi / 4, pi / 7, pi / 5)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.637081   0.637081  -0.433884
 -0.391728   0.752395   0.529576
  0.663835  -0.167419   0.728899</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(EulerAngles, dcm)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Z) : </span></span> 0.785398 rad  ( 45.0°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.448799 rad  ( 25.7143°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span> 0.628319 rad  ( 36.0°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(EulerAngles(:YXY), dcm)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(Y) : </span></span>-0.636877 rad  (-36.4903°)
<span class="sgr33"><span class="sgr1">  R(X) : </span></span> 0.719106 rad  ( 41.2017°)
<span class="sgr34"><span class="sgr1">  R(Y) : </span></span> 1.31382  rad  ( 75.2761°)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(EulerAngles(:XYX), dcm)</code><code class="nohighlight hljs ansi" style="display:block;">EulerAngles{Float64}:
<span class="sgr32"><span class="sgr1">  R(X) : </span></span> 0.972902 rad  ( 55.7432°)
<span class="sgr33"><span class="sgr1">  R(Y) : </span></span> 0.880091 rad  ( 50.4255°)
<span class="sgr34"><span class="sgr1">  R(X) : </span></span>-0.533107 rad  (-30.5448°)</code></pre><p>Supporting this API enables us to perform interesting conversions like:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [
           Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),
           angle_to_dcm(pi / 5, pi / 10, 1),
           EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])
       ]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 Quaternion{Float64}: + 0.809017 + 0.587785⋅i + 0.0⋅j + 0.0⋅k
 [0.7694208842938134 0.5590169943749475 -0.3090169943749474; -0.10721398096693543 0.5899548616836684 0.8002864633748501; 0.6296798115691402 -0.5826261761848704 0.5138580287651915]
 EulerAngleAxis{Float64}: θ = 0.54 rad, v = [0.707107, 0.707107, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = Quaternion[
           Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),
           angle_to_dcm(pi / 5, pi / 10, 1),
           EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])
       ]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Quaternion}:
 Quaternion{Float64}: + 0.809017 + 0.587785⋅i + 0.0⋅j + 0.0⋅k
 Quaternion{Float64}: + 0.847531 + 0.407924⋅i + 0.276892⋅j + 0.196521⋅k
 Quaternion{Float64}: + 0.963771 + 0.188608⋅i + 0.188608⋅j + 0.0⋅k</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = EulerAngleAxis[
           Quaternion(cos(pi / 5), sin(pi / 5), 0, 0),
           angle_to_dcm(pi / 5, pi / 10, 1),
           EulerAngleAxis(0.54, [sqrt(2)/2, sqrt(2)/2, 0])
       ]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{EulerAngleAxis}:
 EulerAngleAxis{Float64}: θ = 1.25664 rad, v = [1.0, 0.0, 0.0]
 EulerAngleAxis{Float64}: θ = 1.11896 rad, v = [0.768586, 0.521703, 0.370273]
 EulerAngleAxis{Float64}: θ = 0.54 rad, v = [0.707107, 0.707107, 0.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quaternions/">« Quaternions</a><a class="docs-footer-nextpage" href="../kinematics/">Kinematics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 22 May 2024 16:11">Wednesday 22 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
