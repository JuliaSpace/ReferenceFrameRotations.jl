<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Reference Frame Rotations</title><meta name="title" content="Library · Reference Frame Rotations"/><meta property="og:title" content="Library · Reference Frame Rotations"/><meta property="twitter:title" content="Library · Reference Frame Rotations"/><meta name="description" content="Documentation for Reference Frame Rotations."/><meta property="og:description" content="Documentation for Reference Frame Rotations."/><meta property="twitter:description" content="Documentation for Reference Frame Rotations."/><meta property="og:url" content="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/lib/library/"/><meta property="twitter:url" content="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/lib/library/"/><link rel="canonical" href="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/lib/library/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Reference Frame Rotations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/crp/">Classical Rodrigues Parameters</a></li><li><a class="tocitem" href="../../man/dcm/">Direction Cosine Matrices</a></li><li><a class="tocitem" href="../../man/euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="tocitem" href="../../man/euler_angles/">Euler Angles</a></li><li><a class="tocitem" href="../../man/mrp/">Modified Rodrigues Parameters</a></li><li><a class="tocitem" href="../../man/quaternions/">Quaternions</a></li><li><a class="tocitem" href="../../man/conversions/">Conversions</a></li><li><a class="tocitem" href="../../man/kinematics/">Kinematics</a></li><li><a class="tocitem" href="../../man/composing_rotations/">Composing rotations</a></li><li><a class="tocitem" href="../../man/inv_rotations/">Inverting rotations</a></li><li><a class="tocitem" href="../../man/random/">Random rotations</a></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/master/docs/src/lib/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>ReferenceFrameRotations.jl</code>.</p><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.ReferenceFrameRotation"><a class="docstring-binding" href="#ReferenceFrameRotations.ReferenceFrameRotation"><code>ReferenceFrameRotations.ReferenceFrameRotation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReferenceFrameRotation</code></pre><p>A <code>Union</code> of all supported rotation types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L257-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.CRP"><a class="docstring-binding" href="#ReferenceFrameRotations.CRP"><code>ReferenceFrameRotations.CRP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CRP{T}</code></pre><p>The definition of Classical Rodrigues Parameters (CRP).</p><p><strong>Fields</strong></p><ul><li><code>q1::T</code>: First component of the CRP.</li><li><code>q2::T</code>: Second component of the CRP.</li><li><code>q3::T</code>: Third component of the CRP.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CRP(q1::T1, q2::T2, q3::T3) where {T1, T2, T3}</code></pre><p>Create a new instance of <code>CRP</code> with coordinates <code>q1</code>, <code>q2</code>, and <code>q3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L201-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.CRP-Tuple{AbstractVector}"><a class="docstring-binding" href="#ReferenceFrameRotations.CRP-Tuple{AbstractVector}"><code>ReferenceFrameRotations.CRP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CRP(v::AbstractVector)</code></pre><p>Create a <code>CRP</code> from the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.DCM"><a class="docstring-binding" href="#ReferenceFrameRotations.DCM"><code>ReferenceFrameRotations.DCM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCM{T}</code></pre><p>Direction Cosine Matrix (DCM) of type <code>T</code>, which is a 3x3 static matrix of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DCM(1.0I)
DCM{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; DCM([1 0 0; 0 -1 0; 0 0 -1])
DCM{Int64}:
 1   0   0
 0  -1   0
 0   0  -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.EulerAngleAxis"><a class="docstring-binding" href="#ReferenceFrameRotations.EulerAngleAxis"><code>ReferenceFrameRotations.EulerAngleAxis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EulerAngleAxis{T}</code></pre><p>The definition of Euler Angle and Axis to represent a 3D rotation.</p><p><strong>Fields</strong></p><ul><li><code>a::T</code>: The Euler angle [rad].</li><li><code>v::SVector{3, T}</code>: The unitary vector aligned with the Euler axis.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}</code></pre><p>Create an Euler Angle and Axis representation structure with angle <code>a</code> [rad] and vector <code>v</code>.</p><p>The vector <code>v</code> will not be normalized.</p><p>The returned structure type will be selected according to the input types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; EulerAngleAxis(pi / 3, [sqrt(2), sqrt(2), 0])
EulerAngleAxis{Float64}:
  Euler angle:   1.0472 rad ( 60.0000 deg)
   Euler axis: [  1.4142,   1.4142,   0.0000]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L125-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.EulerAngles"><a class="docstring-binding" href="#ReferenceFrameRotations.EulerAngles"><code>ReferenceFrameRotations.EulerAngles</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EulerAngles{T}</code></pre><p>The definition of Euler Angles, which is composed of three angles <code>a1</code>, <code>a2</code>, and <code>a3</code> together with a rotation sequence <code>rot_seq</code>.</p><p><strong>Fields</strong></p><ul><li><code>a1::T</code>: First rotation [rad].</li><li><code>a2::T</code>: Second rotation [rad].</li><li><code>a3::T</code>: Third rotation [rad].</li><li><code>rot_seq::Symbol</code>: Rotation sequence.</li></ul><div class="admonition is-info" id="Info-a07f25453f81101d"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-a07f25453f81101d" title="Permalink"></a></header><div class="admonition-body"><p><code>rot_seq</code> is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle, <em>e.g.</em> <code>:ZYX</code>. The valid values for <code>rot_seq</code> are:</p><ul><li><code>:XYX</code>, <code>:XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>,   <code>:ZXZ</code>, <code>:ZYX</code>, and <code>ZYZ</code>.</li></ul></div></div><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">EulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1, T2, T3}</code></pre><p>Create a new instance of <code>EulerAngles</code> with the angles <code>a1</code>, <code>a2</code>, and <code>a3</code> and the rotation sequence <code>rot_seq</code>.</p><p>The type will be inferred from <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p><p>If <code>rot_seq</code> is not provided, then it defaults to <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; EulerAngles(pi / 2, pi / 4, -pi, :XYZ)
EulerAngles{Float64}:
  R(X) :  1.5707963267948966 rad  ( 90.0°)
  R(Y) :  0.7853981633974483 rad  ( 45.0°)
  R(Z) : -3.141592653589793  rad  (-180.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L51-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.MRP"><a class="docstring-binding" href="#ReferenceFrameRotations.MRP"><code>ReferenceFrameRotations.MRP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MRP{T}</code></pre><p>The definition of Modified Rodrigues Parameters (MRP).</p><p><strong>Fields</strong></p><ul><li><code>q1::T</code>: First component of the MRP.</li><li><code>q2::T</code>: Second component of the MRP.</li><li><code>q3::T</code>: Third component of the MRP.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">MRP(q1::T1, q2::T2, q3::T3) where {T1, T2, T3}</code></pre><p>Create a new instance of <code>MRP</code> with coordinates <code>q1</code>, <code>q2</code>, and <code>q3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L229-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.MRP-Tuple{AbstractVector}"><a class="docstring-binding" href="#ReferenceFrameRotations.MRP-Tuple{AbstractVector}"><code>ReferenceFrameRotations.MRP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MRP(v::AbstractVector)</code></pre><p>Create a <code>MRP</code> from the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.Quaternion"><a class="docstring-binding" href="#ReferenceFrameRotations.Quaternion"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Quaternion{T}</code></pre><p>The definition of the quaternion.</p><p><strong>Fields</strong></p><ul><li><code>q0::T</code>: Quaternion real part.</li><li><code>q1::T</code>: X component of the quaternion imaginary part.</li><li><code>q2::T</code>: Y component of the quaternion imaginary part.</li><li><code>q3::T</code>: Z component of the quaternion imaginary part.</li></ul><div class="admonition is-info" id="Note-3a7851b403cb2dea"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3a7851b403cb2dea" title="Permalink"></a></header><div class="admonition-body"><p>The quaternion <code>q</code> in this structure is represented by:</p><pre><code class="nohighlight hljs">q = q0 + q1.i + q2.j + q3.k</code></pre></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(cosd(45), sind(45), 0, 0)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.7071067811865476.i + 0.0.j + 0.0.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L168-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}"><a class="docstring-binding" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0, T1, T2, T3}</code></pre><p>Create the following quaternion:</p><pre><code class="language-julia hljs">q0 + q1.i + q2.j + q3.k</code></pre><p>in which:</p><ul><li><code>q0</code> is the real part of the quaternion.</li><li><code>q1</code> is the X component of the quaternion vectorial part.</li><li><code>q2</code> is the Y component of the quaternion vectorial part.</li><li><code>q3</code> is the Z component of the quaternion vectorial part.</li></ul><div class="admonition is-info" id="Note-c742d4aa281efd2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c742d4aa281efd2" title="Permalink"></a></header><div class="admonition-body"><p>The quaternion type is obtained by promoting <code>T0</code>, <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; Quaternion(1, 0, 0, 0.0)
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre><hr/><pre><code class="language-julia hljs">Quaternion(v::AbstractVector)</code></pre><p>If the vector <code>v</code> has 3 components, then create a quaternion in which the real part is <code>0</code> and the vectorial or imaginary part has the same components of the vector <code>v</code>. In other words:</p><pre><code class="language-julia hljs">q = 0 + v[1].i + v[2].j + v[3].k</code></pre><p>Otherwise, if the vector <code>v</code> has 4 components, then create a quaternion in which the elements match those of the input vector:</p><pre><code class="language-julia hljs">q = v[1] + v[2].i + v[3].j + v[4].k</code></pre><div class="admonition is-info" id="Note-8472a5bb9f55ea41"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8472a5bb9f55ea41" title="Permalink"></a></header><div class="admonition-body"><p>If the length of <code>v</code> is not 3 or 4, then an error is thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion([0, cosd(45), sind(45)])
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k

julia&gt; Quaternion([cosd(45), 0, sind(45), 0])
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k</code></pre><hr/><pre><code class="language-julia hljs">Quaternion(r::Number, v::AbstractVector)</code></pre><p>Create a quaternion with real part <code>r</code> and vectorial or imaginary part <code>v</code>:</p><pre><code class="language-julia hljs">r + v[1].i + v[2].j + v[3].k</code></pre><div class="admonition is-info" id="Note-5ad7a5cc5eac959d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5ad7a5cc5eac959d" title="Permalink"></a></header><div class="admonition-body"><p>The quaternion type is obtained by promoting the type of <code>r</code> and the elements of <code>v</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(cosd(45), [0, sind(45), 0])
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k</code></pre><hr/><pre><code class="language-julia hljs">Quaternion(u::UniformScaling{T}) where T
Quaternion{T}(u::UniformScaling) where T
Quaternion(u::UniformScaling, Q::Quaternion{T}) where T</code></pre><p>Create the quaternion <code>u.λ + 0.i + 0.j + 0.k</code>.</p><p>If a quaternion is passed as in the third signature, then the new quaternion will have the same type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(I)
Quaternion{Bool}:
  + true + false⋅i + false⋅j + false⋅k

julia&gt; Quaternion(1.0I)
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k

julia&gt; q = Quaternion{Float32}(I)
Quaternion{Float32}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k

julia&gt; Quaternion(I, q)
Quaternion{Float32}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L13-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations._EulerAngleConversion"><a class="docstring-binding" href="#ReferenceFrameRotations._EulerAngleConversion"><code>ReferenceFrameRotations._EulerAngleConversion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct _EulerAngleConversion{R}</code></pre><p>This private structure is used only to enable the rotation conversion to Euler angles using the Julia API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/types.jl#L112-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{AbstractVector, Quaternion}"><a class="docstring-binding" href="#Base.:*-Tuple{AbstractVector, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(v::AbstractVector, q::Quaternion) -&gt; Quaternion
*(q::Quaternion, v::AbstractVector) -&gt; Quaternion</code></pre><p>Compute the multiplication <code>qv * q</code> or <code>q * qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; v = [0, cosd(60), sind(60)]
3-element Vector{Float64}:
 0.0
 0.5
 0.8660254037844386

julia&gt; q * v
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 0.5⋅j + 0.866025⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L320-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{CRP, CRP}"><a class="docstring-binding" href="#Base.:*-Tuple{CRP, CRP}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(c1::CRP, c2::CRP) -&gt; CRP</code></pre><p>Compute the composition of two CRPs <code>c1</code> and <code>c2</code>.</p><pre><code class="language-julia hljs">C3 = C2 * C1</code></pre><p>which means that <code>C3</code> acts as <code>C1</code> followed by <code>C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L242-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{EulerAngles, EulerAngles}"><a class="docstring-binding" href="#Base.:*-Tuple{EulerAngles, EulerAngles}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(Θ₂::EulerAngles, Θ₁::EulerAngles) -&gt; EulerAngles</code></pre><p>Compute the composed rotation of <code>Θ₁ -&gt; Θ₂</code>.</p><p>The rotation will be represented by Euler angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) with the same rotation sequence as <code>Θ₂</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ea1 = EulerAngles(deg2rad(35), 0, 0, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.610865 rad  ( 35.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(Z) :  0.0      rad  ( 0.0°)

julia&gt; ea2 = EulerAngles(0, 0, deg2rad(25), :ZYX)
EulerAngles{Float64}:
  R(Z) :  0.0      rad  ( 0.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(X) :  0.436332 rad  ( 25.0°)

julia&gt; ea2 * ea1
EulerAngles{Float64}:
  R(Z) :  0.0    rad  ( 0.0°)
  R(Y) : -0.0    rad  (-0.0°)
  R(X) :  1.0472 rad  ( 60.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/angle.jl#L11-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{MRP, MRP}"><a class="docstring-binding" href="#Base.:*-Tuple{MRP, MRP}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(m1::MRP, m2::MRP) -&gt; MRP</code></pre><p>Compute the composition of two MRPs <code>m1</code> and <code>m2</code>.</p><pre><code class="language-julia hljs">M3 = M2 * M1</code></pre><p>which means that <code>M3</code> acts as <code>M1</code> followed by <code>M2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L243-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{Number, Quaternion}"><a class="docstring-binding" href="#Base.:*-Tuple{Number, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(λ::Number, q::Quaternion) -&gt; Quaternion
*(q::Quaternion, λ::Number) -&gt; Quaternion</code></pre><p>Compute <code>λ * q</code> or <code>q * λ</code>, in which <code>λ</code> is a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; 2 * q
Quaternion{Int64}:
  + 2 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L255-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{Quaternion, Quaternion}"><a class="docstring-binding" href="#Base.:*-Tuple{Quaternion, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(q1::Quaternion, q2::Quaternion) -&gt; Quaternion</code></pre><p>Compute the quaternion multiplication <code>q1 * q2</code> (Hamilton product).</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="language-julia hljs">*(u::UniformScaling, q::Quaternion)
*(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(cosd(30), 0, sind(30), 0)
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k

julia&gt; q2 = Quaternion(cosd(60), 0, sind(60), 0)
Quaternion{Float64}:
  + 0.5 + 0.0⋅i + 0.866025⋅j + 0.0⋅k

julia&gt; q1 * q2
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 1.0⋅j + 0.0⋅k

julia&gt; I * q1
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L276-L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(av₂::EulerAngleAxis{T1}, av₁::EulerAngleAxis{T2}) where {T1, T2} -&gt; EulerAngleAxis{T3}</code></pre><p>Compute the composed rotation of <code>av₁ -&gt; av₂</code>.</p><p>The rotation will be represented by a Euler angle and axis (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>). By convention, the output angle will always be in the range <code>[0, π] rad</code>.</p><p>Notice that the vector representing the axis in <code>av₁</code> and <code>av₂</code> must be unitary. This function neither verifies this nor normalizes the vector.</p><div class="admonition is-info" id="Note-12b72173ade68a8a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-12b72173ade68a8a" title="Permalink"></a></header><div class="admonition-body"><p>The output type <code>T3</code> is obtained by promoting <code>T1</code> and <code>T2</code> to a float.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; av1 = EulerAngleAxis(deg2rad(45), [sqrt(2)/2, sqrt(2)/2, 0])
EulerAngleAxis{Float64}:
  Euler angle : 0.785398 rad  (45.0°)
  Euler axis  : [0.707107, 0.707107, 0.0]

julia&gt; av2 = EulerAngleAxis(deg2rad(22.5), [sqrt(2)/2, sqrt(2)/2, 0])
EulerAngleAxis{Float64}:
  Euler angle : 0.392699 rad  (22.5°)
  Euler axis  : [0.707107, 0.707107, 0.0]

julia&gt; av1 * av2
EulerAngleAxis{Float64}:
  Euler angle : 1.1781 rad  (67.5°)
  Euler axis  : [0.707107, 0.707107, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/angleaxis.jl#L11-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{Quaternion, Quaternion}"><a class="docstring-binding" href="#Base.:+-Tuple{Quaternion, Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(qa::Quaternion, qb::Quaternion) -&gt; Quaternion</code></pre><p>Compute <code>qa + qb</code>.</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="language-julia hljs">+(u::UniformScaling, q::Quaternion)
+(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; q2 = Quaternion(0, cosd(45), 0, sind(45))
Quaternion{Float64}:
  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.707107⋅k

julia&gt; q1 + q2
Quaternion{Float64}:
  + 1.0 + 0.707107⋅i + 0.0⋅j + 0.707107⋅k

julia&gt; q1 + I
Quaternion{Int64}:
  + 2 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L154-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Tuple{Quaternion, Quaternion}"><a class="docstring-binding" href="#Base.:--Tuple{Quaternion, Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">-(qa::Quaternion, qb::Quaternion) -&gt; Quaternion</code></pre><p>Compute <code>qa - qb</code>.</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="language-julia hljs">-(u::UniformScaling, q::Quaternion)
-(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; q2 = Quaternion(0, cosd(45), 0, sind(45))
Quaternion{Float64}:
  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.707107⋅k

julia&gt; q1 - q2
Quaternion{Float64}:
  + 1.0 - 0.707107⋅i + 0.0⋅j - 0.707107⋅k

julia&gt; q1 - I
Quaternion{Int64}:
  + 0 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L214-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Tuple{Quaternion}"><a class="docstring-binding" href="#Base.:--Tuple{Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">-(q::Quaternion) -&gt; Quaternion</code></pre><p>Return the quaterion <code>-q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; -q
Quaternion{Int64}:
  - 1 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L195-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:/-Tuple{Number, Quaternion}"><a class="docstring-binding" href="#Base.:/-Tuple{Number, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">/(λ::Number, q::Quaternion) -&gt; Quaternion
/(q::Quaternion, λ::Number) -&gt; Quaternion</code></pre><p>Compute the division <code>λ / q</code> or <code>q / λ</code>, in which <code>λ</code> is a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(2, 0, 0, 0)
Quaternion{Int64}:
  + 2 + 0⋅i + 0⋅j + 0⋅k

julia&gt; q / 2
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L365-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:/-Tuple{Quaternion, Quaternion}"><a class="docstring-binding" href="#Base.:/-Tuple{Quaternion, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">/(q1::Quaternion, q2::Quaternion) -&gt; Quaternion</code></pre><p>Compute <code>q1 * inv(q2)</code> (Hamilton product).</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="language-julia hljs">/(u::UniformScaling, q::Quaternion)
/(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k

julia&gt; q2 = Quaternion(cosd(30), 0, sind(30), 0)
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k

julia&gt; q1 / q2
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k

julia&gt; q1 / (2 * I)
Quaternion{Float64}:
  + 0.12941 + 0.0⋅i + 0.482963⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L397-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:\\-Tuple{Quaternion, AbstractVector}"><a class="docstring-binding" href="#Base.:\\-Tuple{Quaternion, AbstractVector}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">\(v::AbstractVector, q::Quaternion) -&gt; Quaternion
\(q::Quaternion, v::AbstractVector) -&gt; Quaternion</code></pre><p>Compute the division <code>qv \ q</code> or <code>q \ qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; v = [0, cosd(60), sind(60)]
3-element Vector{Float64}:
 0.0
 0.5
 0.8660254037844386

julia&gt; v \ q
Quaternion{Float64}:
  + 0.0 + 0.0⋅i - 0.5⋅j - 0.866025⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L467-L491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:\\-Tuple{Quaternion, Quaternion}"><a class="docstring-binding" href="#Base.:\\-Tuple{Quaternion, Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">\(q1::Quaternion, q2::Quaternion) -&gt; Quaternion</code></pre><p>Compute <code>inv(q1) * q2</code>.</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="language-julia hljs">\(u::UniformScaling, q::Quaternion)
\(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k

julia&gt; q2 = Quaternion(cosd(30), 0, sind(30), 0)
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.0⋅k

julia&gt; q2 \ q1
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L435-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.conj-Tuple{Quaternion}"><a class="docstring-binding" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conj(q::Quaternion) -&gt; Quaternion</code></pre><p>Compute the complex conjugate of the quaternion <code>q</code>:</p><pre><code class="language-julia hljs">q0 - q1.i - q2.j - q3.k</code></pre><p>See also: <a href="#Base.inv-Tuple{CRP}"><code>inv</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, cosd(75), 0, sind(75))
Quaternion{Float64}:
  + 1.0 + 0.258819⋅i + 0.0⋅j + 0.965926⋅k

julia&gt; conj(q)
Quaternion{Float64}:
  + 1.0 - 0.258819⋅i - 0.0⋅j - 0.965926⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L499-L519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Union{Tuple{CRP{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.copy-Union{Tuple{CRP{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy(c::CRP) -&gt; CRP</code></pre><p>Create a copy of the CRP <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L303-L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Union{Tuple{MRP{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.copy-Union{Tuple{MRP{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy(m::MRP) -&gt; MRP</code></pre><p>Create a copy of the MRP <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L321-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy(q::Quaternion{T}) where T -&gt; Quaternion</code></pre><p>Create a copy of the quaternion <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L522-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.imag-Tuple{Quaternion}"><a class="docstring-binding" href="#Base.imag-Tuple{Quaternion}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">imag(q::Quaternion{T}) -&gt; SVector{3, T}</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p><p>See also: <a href="#Base.real-Tuple{Quaternion}"><code>real</code></a>, <a href="#ReferenceFrameRotations.vect-Tuple{CRP}"><code>vect</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k

julia&gt; imag(q)
3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.9659258262890683
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L531-L552">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.inv-Tuple{CRP}"><a class="docstring-binding" href="#Base.inv-Tuple{CRP}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv(c::CRP) -&gt; CRP</code></pre><p>Compute the inverse of the CRP <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L281-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.inv-Tuple{EulerAngles}"><a class="docstring-binding" href="#Base.inv-Tuple{EulerAngles}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv(Θ::EulerAngles) -&gt; EulerAngles</code></pre><p>Return the Euler angles that represent the inverse rotation of <code>Θ</code>.</p><p>The rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, <code>:XYZ</code>, then the result will be represented using <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ea = EulerAngles(π / 3, π / 6,  2 / 3 * π, :ZYX)
EulerAngles{Float64}:
  R(Z) :  1.0472   rad  ( 60.0°)
  R(Y) :  0.523599 rad  ( 30.0°)
  R(X) :  2.0944   rad  ( 120.0°)

julia&gt; inv(ea)
EulerAngles{Float64}:
  R(X) : -2.0944   rad  (-120.0°)
  R(Y) : -0.523599 rad  (-30.0°)
  R(Z) : -1.0472   rad  (-60.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/angle.jl#L50-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.inv-Tuple{MRP}"><a class="docstring-binding" href="#Base.inv-Tuple{MRP}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv(m::MRP) -&gt; MRP</code></pre><p>Compute the inverse of the MRP <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L299-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.inv-Tuple{Quaternion}"><a class="docstring-binding" href="#Base.inv-Tuple{Quaternion}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv(q::Quaternion) -&gt; Quaternion</code></pre><p>Compute the inverse of the quaternion <code>q</code>:</p><pre><code class="language-julia hljs">conj(q)
───────
  |q|²</code></pre><p>See also: <a href="#Base.conj-Tuple{Quaternion}"><code>conj</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, cosd(75), sind(75))
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.258819⋅j + 0.965926⋅k

julia&gt; inv(q)
Quaternion{Float64}:
  + 0.5 - 0.0⋅i - 0.12941⋅j - 0.482963⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L555-L577">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number"><a class="docstring-binding" href="#Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv(av::EulerAngleAxis) -&gt; EulerAngleAxis</code></pre><p>Compute the inverse rotation of the Euler angle and axis <code>av</code>.</p><p>The Euler angle returned by this function will always be in the interval <code>[0, π]</code> rad.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; av = EulerAngleAxis(deg2rad(20), [sqrt(2) / 2, 0, sqrt(2) / 2])
EulerAngleAxis{Float64}:
  Euler angle : 0.349066 rad  (20.0°)
  Euler axis  : [0.707107, 0.0, 0.707107]

julia&gt; inv(av)
EulerAngleAxis{Float64}:
  Euler angle : 0.349066 rad  (20.0°)
  Euler axis  : [-0.707107, -0.0, -0.707107]

julia&gt; av = EulerAngleAxis(deg2rad(-20), [sqrt(2) / 2, 0, sqrt(2) / 2])
EulerAngleAxis{Float64}:
  Euler angle : -0.349066 rad  (-20.0°)
  Euler axis  : [0.707107, 0.0, 0.707107]

julia&gt; inv(av)
EulerAngleAxis{Float64}:
  Euler angle : 0.349066 rad  (20.0°)
  Euler axis  : [0.707107, 0.0, 0.707107]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/angleaxis.jl#L83-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.real-Tuple{Quaternion}"><a class="docstring-binding" href="#Base.real-Tuple{Quaternion}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">real(q::Quaternion{T}) -&gt; T</code></pre><p>Return the real part of the quaternion <code>q</code>: <code>q0</code>.</p><p>See also: <a href="#Base.imag-Tuple{Quaternion}"><code>imag</code></a>, <a href="#ReferenceFrameRotations.vect-Tuple{CRP}"><code>vect</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k

julia&gt; real(q)
0.25881904510252074</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L614-L631">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.norm-Tuple{CRP}"><a class="docstring-binding" href="#LinearAlgebra.norm-Tuple{CRP}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(c::CRP) -&gt; Number</code></pre><p>Compute the Euclidean norm of the CRP <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L288-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.norm-Tuple{MRP}"><a class="docstring-binding" href="#LinearAlgebra.norm-Tuple{MRP}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(m::MRP) -&gt; Number</code></pre><p>Compute the Euclidean norm of the MRP <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L306-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.norm-Tuple{Quaternion}"><a class="docstring-binding" href="#LinearAlgebra.norm-Tuple{Quaternion}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(q::Quaternion{T}) -&gt; float(T)</code></pre><p>Compute the Euclidean norm of the quaternion <code>q</code>:</p><pre><code class="language-julia hljs">√(q0² + q1² + q2² + q3²)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k

julia&gt; norm(q)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L590-L607">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}"><code>ReferenceFrameRotations.angle_to_angle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol) -&gt; EulerAngles
angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol) -&gt; EulerAngles</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq_orig</code> to a new set of Euler angles with rotation sequence <code>rot_seq_dest</code>.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X) : -1.0472   rad  (-60.0°)
  R(Y) :  0.785398 rad  ( 45.0°)
  R(Z) : -1.5708   rad  (-90.0°)

julia&gt; angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.0    rad  ( 0.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(Z) : -1.5708 rad  (-90.0°)

julia&gt; Θ = EulerAngles(1, 2, 3, :XYX)
EulerAngles{Int64}:
  R(X) :  1 rad  ( 57.2958°)
  R(Y) :  2 rad  ( 114.592°)
  R(X) :  3 rad  ( 171.887°)

julia&gt; angle_to_angle(Θ, :ZYZ)
EulerAngles{Float64}:
  R(Z) : -2.70239 rad  (-154.836°)
  R(Y) :  1.46676 rad  ( 84.0393°)
  R(Z) : -1.05415 rad  (-60.3984°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_angle.jl#L9-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_angleaxis"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_angleaxis"><code>ReferenceFrameRotations.angle_to_angleaxis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX) -&gt; EulerAngleAxis
angle_to_angleaxis(Θ::EulerAngles) -&gt; EulerAngleAxis</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to an Euler angle and axis representation.</p><p>Those values can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_angleaxis(1, 0, 0, :XYZ)
EulerAngleAxis{Float64}:
  Euler angle : 1.0 rad  (57.2958°)
  Euler axis  : [1.0, 0.0, 0.0]

julia&gt; Θ = EulerAngles(1, 1, 1, :XYZ);

julia&gt; angle_to_angleaxis(Θ)
EulerAngleAxis{Float64}:
  Euler angle : 1.93909 rad  (111.102°)
  Euler axis  : [0.692363, 0.203145, 0.692363]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_angleaxis.jl#L9-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_crp"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_crp"><code>ReferenceFrameRotations.angle_to_crp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">angle_to_crp(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX) -&gt; CRP
angle_to_crp(Θ::EulerAngles) -&gt; CRP</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to classical Rodrigues parameters.</p><p>Those values can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_crp.jl#L9-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_dcm-Union{Tuple{T}, Tuple{T, Symbol}} where T&lt;:Number"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_dcm-Union{Tuple{T}, Tuple{T, Symbol}} where T&lt;:Number"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angle_to_dcm(θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol = :ZYX) -&gt; DCM
angle_to_dcm(Θ::EulerAngles) -&gt; DCM</code></pre><p>Create a direction cosine matrix that perform a set of rotations (<code>θ₁</code>, <code>θ₂</code>, <code>θ₃</code>) about the coordinate axes specified in <code>rot_seq</code>.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>Symbol</code> specifing the rotation axes. The possible values depends on the number of rotations as follows:</p><ul><li><strong>1 rotation</strong> (<code>θ₁</code>): <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</li><li><strong>2 rotations</strong> (<code>θ₁</code>, <code>θ₂</code>): <code>:XY</code>, <code>:XZ</code>, <code>:YX</code>, <code>:YZ</code>, <code>:ZX</code>, or <code>:ZY</code>.</li><li><strong>3 rotations</strong> (<code>θ₁</code>, <code>θ₂</code>, <code>θ₃</code>): <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>,   <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, or <code>:ZYZ</code></li></ul><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i ∈ [1,2,3]</code>. If the <em>i</em>-th rotation is not specified, then <code>Ai = I</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_dcm(pi / 2, :X)
DCM{Float64}:
 1.0   0.0          0.0
 0.0   6.12323e-17  1.0
 0.0  -1.0          6.12323e-17

julia&gt; angle_to_dcm(pi / 5, pi / 7, :YZ)
DCM{Float64}:
  0.728899  0.433884  -0.529576
 -0.351019  0.900969   0.25503
  0.587785  0.0        0.809017

julia&gt; angle_to_dcm(pi / 5, pi / 7, 0, :YZY)
DCM{Float64}:
  0.728899  0.433884  -0.529576
 -0.351019  0.900969   0.25503
  0.587785  0.0        0.809017

julia&gt; dcm = angle_to_dcm(pi / 2, pi / 3, pi / 4, :ZYX)
DCM{Float64}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_dcm.jl#L9-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_mrp"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_mrp"><code>ReferenceFrameRotations.angle_to_mrp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">angle_to_mrp(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX) -&gt; MRP
angle_to_mrp(Θ::EulerAngles) -&gt; MRP</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to modified Rodrigues parameters.</p><p>Those values can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_mrp.jl#L9-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_quat-Tuple{Number, Symbol}"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_quat-Tuple{Number, Symbol}"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angle_to_quat(θ₁::T1[, θ₂::T2[, θ₃::T3]], rot_seq::Symbol = :ZYX) where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number} -&gt; Quaternion
angle_to_quat(eulerang::EulerAngles) -&gt; Quaternion</code></pre><p>Create a quaternion that perform a set of rotations (<code>θ₁</code>, <code>θ₂</code>, <code>θ₃</code>) about the coordinate axes specified in <code>rot_seq</code>.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>Symbol</code> specifing the rotation axes. The possible values depends on the number of rotations as follows:</p><ul><li><strong>1 rotation</strong> (<code>θ₁</code>): <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</li><li><strong>2 rotations</strong> (<code>θ₁</code>, <code>θ₂</code>): <code>:XY</code>, <code>:XZ</code>, <code>:YX</code>, <code>:YZ</code>, <code>:ZX</code>, or <code>:ZY</code>.</li><li><strong>3 rotations</strong> (<code>θ₁</code>, <code>θ₂</code>, <code>θ₃</code>): <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>,   <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, or <code>:ZYZ</code></li></ul><div class="admonition is-info" id="Note-7cdfec95489545c8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7cdfec95489545c8" title="Permalink"></a></header><div class="admonition-body"><p>The type of the new quaternion will be obtained by promiting <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p></div></div><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i ∈ [1,2,3]</code>. If the <em>i</em>-th rotation is not specified, then <code>qi = Quaternion(I)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_quat(pi / 2, :X)
Quaternion{Float64}:
  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k

julia&gt; angle_to_quat(pi / 5, pi / 7, :YZ)
Quaternion{Float64}:
  + 0.927212 + 0.0687628⋅i + 0.301269⋅j + 0.21163⋅k

julia&gt; angle_to_quat(pi / 5, pi / 7, 0, :YZX)
Quaternion{Float64}:
  + 0.927212 + 0.0687628⋅i + 0.301269⋅j + 0.21163⋅k

julia&gt; angle_to_quat(pi / 2, pi / 3, pi / 4, :ZYX)
Quaternion{Float64}:
  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.430459⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_quat.jl#L9-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angle_to_rot-Tuple{Number, Symbol}"><a class="docstring-binding" href="#ReferenceFrameRotations.angle_to_rot-Tuple{Number, Symbol}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angle_to_rot([T,] θ₁::Number[, θ₂::Number[, θ₃::Number]], rot_seq::Symbol) -&gt; T
angle_to_rot([T,] Θ::EulerAngles) -&gt; T</code></pre><p>Create a rotation description of type <code>T</code> that perform a set of rotations (<code>θ₁</code>, <code>θ₂</code>, <code>θ₃</code>) about the coordinate axes specified in <code>rot_seq</code>.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>Symbol</code> specifing the rotation axes. The possible values depends on the number of rotations as follows:</p><ul><li><strong>1 rotation</strong> (<code>θ₁</code>): <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</li><li><strong>2 rotations</strong> (<code>θ₁</code>, <code>θ₂</code>): <code>:XY</code>, <code>:XZ</code>, <code>:YX</code>, <code>:YZ</code>, <code>:ZX</code>, or <code>:ZY</code>.</li><li><strong>3 rotations</strong> (<code>θ₁</code>, <code>θ₂</code>, <code>θ₃</code>): <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>,   <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, or <code>:ZYZ</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_rot(pi / 5, :Z)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.809017  0.587785  0.0
 -0.587785  0.809017  0.0
  0.0       0.0       1.0

julia&gt; quat = angle_to_rot(Quaternion, pi / 5, :Z)
Quaternion{Float64}:
  + 0.951057 + 0.0⋅i + 0.0⋅j + 0.309017⋅k

julia&gt; dcm = angle_to_rot(pi / 5, pi / 7, :YZ)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.728899  0.433884  -0.529576
 -0.351019  0.900969   0.25503
  0.587785  0.0        0.809017

julia&gt; quat = angle_to_rot(Quaternion, pi / 5, pi / 7, :YZ)
Quaternion{Float64}:
  + 0.927212 + 0.0687628⋅i + 0.301269⋅j + 0.21163⋅k

julia&gt; dcm = angle_to_rot(pi / 2, pi / 3, pi / 4, :ZYX)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q = angle_to_rot(Quaternion, pi / 2, pi / 3, pi / 4, :ZYX)
Quaternion{Float64}:
  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.430459⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angle_to_rot.jl#L9-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector, Symbol}"><a class="docstring-binding" href="#ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector, Symbol}"><code>ReferenceFrameRotations.angleaxis_to_angle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol) -&gt; EulerAngles
angleaxis_to_angle(av::EulerAngleAxis, rot_seq::Symbol) -&gt; EulerAngles</code></pre><p>Convert the Euler angle <code>θ</code> [rad]  and Euler axis <code>v</code> to Euler angles with rotation sequence <code>rot_seq</code>.</p><p>Those values can also be passed inside the structure <code>av</code> (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p><div class="admonition is-warning" id="Warning-6af2496bfda1fde0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6af2496bfda1fde0" title="Permalink"></a></header><div class="admonition-body"><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; av = EulerAngleAxis(deg2rad(45), [1, 0, 0]);

julia&gt; angleaxis_to_angle(av, :ZXY)
EulerAngles{Float64}:
  R(Z) :  0.0      rad  ( 0.0°)
  R(X) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.0      rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angleaxis_to_angle.jl#L9-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angleaxis_to_dcm-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}}} where {T1, T2}"><a class="docstring-binding" href="#ReferenceFrameRotations.angleaxis_to_dcm-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}}} where {T1, T2}"><code>ReferenceFrameRotations.angleaxis_to_dcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angleaxis_to_dcm(a::Number, v::AbstractVector) -&gt; DCM
angleaxis_to_dcm(av::EulerAngleAxis) -&gt; DCM</code></pre><p>Convert the Euler angle <code>a</code> [rad] and Euler axis <code>v</code> to a DCM.</p><p>Those values can also be passed inside the structure <code>ea</code> (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>).</p><div class="admonition is-warning" id="Warning-6af2496bfda1fde0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6af2496bfda1fde0" title="Permalink"></a></header><div class="admonition-body"><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1, 1, 1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_dcm(pi / 2, v)
DCM{Float64}:
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333

julia&gt; ea = EulerAngleAxis(pi / 2, v);

julia&gt; angleaxis_to_dcm(ea)
DCM{Float64}:
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angleaxis_to_dcm.jl#L9-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.angleaxis_to_quat-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}}} where {T1, T2}"><a class="docstring-binding" href="#ReferenceFrameRotations.angleaxis_to_quat-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}}} where {T1, T2}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angleaxis_to_quat(θ::Number, v::AbstractVector) -&gt; Quaternion
angleaxis_to_quat(angleaxis::EulerAngleAxis) -&gt; Quaternion</code></pre><p>Convert the Euler angle <code>θ</code> [rad] and Euler axis <code>v</code> to a quaternion.</p><p>Those values can also be passed inside the structure <code>ea</code> (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>).</p><div class="admonition is-warning" id="Warning-6af2496bfda1fde0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6af2496bfda1fde0" title="Permalink"></a></header><div class="admonition-body"><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1, 1, 1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(pi / 2, v)
Quaternion{Float64}:
  + 0.707107 + 0.408248⋅i + 0.408248⋅j + 0.408248⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/angleaxis_to_quat.jl#L9-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.compose_rotation-Tuple{DCM}"><a class="docstring-binding" href="#ReferenceFrameRotations.compose_rotation-Tuple{DCM}"><code>ReferenceFrameRotations.compose_rotation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compose_rotation(R1::T, [, R2::T, R3::T, R4::T, R5::T, ...]) -&gt; T</code></pre><p>Compute a composed rotation using the rotations <code>R1</code>, <code>R2</code>, <code>R3</code>, <code>R4</code>, ..., in the following order:</p><pre><code class="language-julia hljs"> First rotation
 |
 |
R1 =&gt; R2 =&gt; R3 =&gt; R4 =&gt; ...
       |
       |
       Second rotation</code></pre><p>The rotations can be described by:</p><ul><li>A direction cosine matrix (<a href="#ReferenceFrameRotations.DCM"><code>DCM</code></a>);</li><li>An Euler angle and axis (<a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>);</li><li>A set of Euler angles (<a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>);</li><li>A quaternion (<a href="../../man/quaternions/#Quaternion"><code>Quaternion</code></a>);</li><li>Classical Rodrigues parameters (<a href="#ReferenceFrameRotations.CRP"><code>CRP</code></a>); or</li><li>Modified Rodrigues parameters (<a href="#ReferenceFrameRotations.MRP"><code>MRP</code></a>).</li></ul><p>Notice, however, that all rotations <strong>must be</strong> of the same type.</p><p>The output will have the same type as the inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D1 = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; D2 = angle_to_dcm(-pi / 5, -pi / 4, -pi / 3, :XYZ);

julia&gt; compose_rotation(D1, D2)
DCM{Float64}:
 1.0          1.08801e-17  3.54837e-17
 1.08801e-17  1.0          2.88714e-17
 3.54837e-17  2.88714e-17  1.0

julia&gt; ea1 = EulerAngleAxis(30 * pi / 180, [0, 1, 0]);

julia&gt; ea2 = EulerAngleAxis(45 * pi / 180, [0, 1, 0]);

julia&gt; compose_rotation(ea1, ea2)
EulerAngleAxis{Float64}:
  Euler angle : 1.309 rad  (75.0°)
  Euler axis  : [0.0, 1.0, 0.0]

julia&gt; Θ1 = EulerAngles(1, 2, 3, :ZYX);

julia&gt; Θ2 = EulerAngles(-3, -2, -1, :XYZ);

julia&gt; compose_rotation(Θ1, Θ2)
EulerAngles{Float64}:
  R(X) : -1.66533e-16 rad  (-9.54166e-15°)
  R(Y) :  9.24446e-33 rad  ( 5.29669e-31°)
  R(Z) : -1.11022e-16 rad  (-6.36111e-15°)

julia&gt; q1 = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; q2 = angle_to_quat(-pi / 5, -pi / 4, -pi / 3, :XYZ);

julia&gt; compose_rotation(q1, q2)
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 2.08167e-17⋅j + 5.55112e-17⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/compose_rotations.jl#L13-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.crp_to_angle"><a class="docstring-binding" href="#ReferenceFrameRotations.crp_to_angle"><code>ReferenceFrameRotations.crp_to_angle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">crp_to_angle(c::CRP, rot_seq::Symbol) -&gt; EulerAngles</code></pre><p>Convert CRP <code>c</code> to Euler Angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CRP(0.5, 0, 0)
CRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; crp_to_angle(c, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.927295 rad  ( 53.1301°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(Z) :  0.0      rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/crp_to_angle.jl#L9-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.crp_to_angleaxis-Tuple{CRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.crp_to_angleaxis-Tuple{CRP}"><code>ReferenceFrameRotations.crp_to_angleaxis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crp_to_angleaxis(c::CRP) -&gt; EulerAngleAxis</code></pre><p>Convert the CRP <code>c</code> to a Euler angle and axis representation (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>). By convention, the Euler angle will be kept between <code>[0, π]</code> rad.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CRP(0.5, 0, 0)
CRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; crp_to_angleaxis(c)
EulerAngleAxis{Float64}:
  Euler angle : 0.927295 rad  (53.1301°)
  Euler axis  : [1.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/crp_to_angleaxis.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.crp_to_dcm-Tuple{CRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.crp_to_dcm-Tuple{CRP}"><code>ReferenceFrameRotations.crp_to_dcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crp_to_dcm(c::CRP) -&gt; DCM</code></pre><p>Convert the CRP <code>c</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CRP(0.5, 0, 0)
CRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; crp_to_dcm(c)
DCM{Float64}:
 1.0   0.0  0.0
 0.0   0.6  0.8
 0.0  -0.8  0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/crp_to_dcm.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.crp_to_mrp-Tuple{CRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.crp_to_mrp-Tuple{CRP}"><code>ReferenceFrameRotations.crp_to_mrp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crp_to_mrp(c::CRP) -&gt; MRP</code></pre><p>Convert CRP <code>c</code> to MRP.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CRP(0.5, 0, 0)
CRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; crp_to_mrp(c)
MRP{Float64}:
  X : + 0.236068
  Y : + 0.0
  Z : + 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/crp_to_mrp.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.crp_to_quat-Tuple{CRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.crp_to_quat-Tuple{CRP}"><code>ReferenceFrameRotations.crp_to_quat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crp_to_quat(c::CRP) -&gt; Quaternion</code></pre><p>Convert CRP <code>c</code> to a quaternion.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CRP(0.5, 0, 0)
CRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; crp_to_quat(c)
Quaternion{Float64}:
  + 0.894427 + 0.447214⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/crp_to_quat.jl#L9-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dcm_to_angle-Union{Tuple{DCM{T}}, Tuple{T}, Tuple{DCM{T}, Symbol}} where T&lt;:Number"><a class="docstring-binding" href="#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{DCM{T}}, Tuple{T}, Tuple{DCM{T}, Symbol}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX) -&gt; EulerAngles</code></pre><p>Convert the <code>dcm</code> to Euler Angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p><p><strong>Gimbal-lock and special cases</strong></p><p>If the rotations are about three different axes, <em>e.g.</em> <code>:XYZ</code>, <code>:ZYX</code>, etc., then a second rotation of <code>±90˚</code> yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation, and the angle of the third rotation is set to 0.</p><p>If the rotations are about two different axes, <em>e.g.</em> <code>:XYX</code>, <code>:YXY</code>, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);

julia&gt; dcm_to_angle(D,:XYZ)
EulerAngles{Float64}:
  R(X) :  1.5708 rad  ( 90.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(Z) :  0.0    rad  ( 0.0°)

julia&gt; D = angle_to_dcm(1, -pi / 2, 2, :ZYX);

julia&gt; dcm_to_angle(D, :ZYX)
EulerAngles{Float64}:
  R(Z) :  3.0    rad  ( 171.887°)
  R(Y) : -1.5708 rad  (-90.0°)
  R(X) :  0.0    rad  ( 0.0°)

julia&gt; D = angle_to_dcm(1, :X) * angle_to_dcm(2, :X);

julia&gt; dcm_to_angle(D, :XYX)
EulerAngles{Float64}:
  R(X) :  3.0 rad  ( 171.887°)
  R(Y) :  0.0 rad  ( 0.0°)
  R(X) :  0.0 rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/dcm_to_angle.jl#L9-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{DCM{T}}, Tuple{T}} where T&lt;:Number"><a class="docstring-binding" href="#ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{DCM{T}}, Tuple{T}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angleaxis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcm_to_angleaxis(dcm::DCM{T}) where T&lt;:Number -&gt; EulerAngleAxis</code></pre><p>Convert the <code>dcm</code> to an Euler angle and axis representation.</p><p>By convention, the returned Euler angle will always be in the interval [0, π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/dcm_to_angleaxis.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dcm_to_crp-Tuple{DCM}"><a class="docstring-binding" href="#ReferenceFrameRotations.dcm_to_crp-Tuple{DCM}"><code>ReferenceFrameRotations.dcm_to_crp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcm_to_crp(dcm::DCM) -&gt; CRP</code></pre><p>Convert DCM <code>dcm</code> to CRP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/dcm_to_crp.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dcm_to_mrp-Tuple{DCM}"><a class="docstring-binding" href="#ReferenceFrameRotations.dcm_to_mrp-Tuple{DCM}"><code>ReferenceFrameRotations.dcm_to_mrp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcm_to_mrp(dcm::DCM) -&gt; MRP</code></pre><p>Convert DCM <code>dcm</code> to MRP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/dcm_to_mrp.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dcm_to_quat-Tuple{DCM}"><a class="docstring-binding" href="#ReferenceFrameRotations.dcm_to_quat-Tuple{DCM}"><code>ReferenceFrameRotations.dcm_to_quat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcm_to_quat(dcm::DCM) -&gt; Quaternion</code></pre><p>Convert the <code>dcm</code> to a quaternion.</p><p>The type of the quaternion will be automatically selected by the constructor <a href="../../man/quaternions/#Quaternion"><code>Quaternion</code></a> to avoid <code>InexactError</code>.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p>This algorithm was obtained from <strong>[1]</strong>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_dcm(pi / 2, 0.0, 0.0, :XYZ);

julia&gt; q = dcm_to_quat(dcm)
Quaternion{Float64}:
  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k</code></pre><p><strong>References</strong></p><ul><li><strong>[1]</strong>: http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/dcm_to_quat.jl#L9-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dcrp-Tuple{CRP, AbstractVector}"><a class="docstring-binding" href="#ReferenceFrameRotations.dcrp-Tuple{CRP, AbstractVector}"><code>ReferenceFrameRotations.dcrp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcrp(c::CRP, wba_b::AbstractVector) -&gt; CRP</code></pre><p>Compute the time-derivative of the CRP <code>c</code> that rotates a reference frame <code>a</code> into alignment with the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code> <strong>[1]</strong>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CRP(0.0, 0.0, 0.0)
CRP{Float64}:
  X : + 0.0
  Y : + 0.0
  Z : + 0.0

julia&gt; dcrp(c, [1.0, 0.0, 0.0])
CRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0</code></pre><p><strong>References</strong></p><ul><li><strong>[1]</strong> Schaub, H.; Junkins, J. L (1996). <em>Stereographic Orientation Parameters for   Attitude Dynamics: A Generalization of the Rodrigues Parameters</em>. In: <strong>Journal of the   Astronautical Sciences</strong>, Vol. 44, No. 1, pp. 1 – 19.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L113-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.ddcm-Tuple{DCM, AbstractArray}"><a class="docstring-binding" href="#ReferenceFrameRotations.ddcm-Tuple{DCM, AbstractArray}"><code>ReferenceFrameRotations.ddcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ddcm(Dba::DCM, wba_b::AbstractArray) -&gt; SMatrix{3, 3}</code></pre><p>Compute the time-derivative of the <code>dcm</code> that rotates a reference frame <code>a</code> into alignment with the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = DCM(1.0I);

julia&gt; ddcm(D, [1, 0, 0])
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.0   0.0  0.0
 0.0   0.0  1.0
 0.0  -1.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/dcm.jl#L79-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dmrp-Tuple{MRP, AbstractVector}"><a class="docstring-binding" href="#ReferenceFrameRotations.dmrp-Tuple{MRP, AbstractVector}"><code>ReferenceFrameRotations.dmrp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dmrp(m::MRP, wba_b::AbstractVector) -&gt; MRP</code></pre><p>Compute the time-derivative of the MRP <code>m</code> that rotates a reference frame <code>a</code> into alignment with the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code> <strong>[1]</strong>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MRP(0.0, 0.0, 0.0)
MRP{Float64}:
  X : + 0.0
  Y : + 0.0
  Z : + 0.0

julia&gt; dmrp(m, [1.0, 0.0, 0.0])
MRP{Float64}:
  X : + 0.25
  Y : + 0.0
  Z : + 0.0</code></pre><p><strong>References</strong></p><ul><li><strong>[1]</strong> Schaub, H.; Junkins, J. L (1996). <em>Stereographic Orientation Parameters for   Attitude Dynamics: A Generalization of the Rodrigues Parameters</em>. In: <strong>Journal of the   Astronautical Sciences</strong>, Vol. 44, No. 1, pp. 1 – 19.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L113-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector}"><a class="docstring-binding" href="#ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector}"><code>ReferenceFrameRotations.dquat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dquat(qba::Quaternion, wba_b::AbstractVector) -&gt; Quaternion</code></pre><p>Compute the time-derivative of the quaternion <code>qba</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1.0I);

julia&gt; dquat(q,[1;0;0])
Quaternion{Float64}:
  - 0.0 + 0.5⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L820-L836">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.inv_rotation-Tuple{DCM}"><a class="docstring-binding" href="#ReferenceFrameRotations.inv_rotation-Tuple{DCM}"><code>ReferenceFrameRotations.inv_rotation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv_rotation(R::T) -&gt; T</code></pre><p>Compute the inverse rotation of <code>R</code>, which can be:</p><ul><li>A direction cosine matrix (<code>DCM</code>);</li><li>An Euler angle and axis (<code>EulerAngleAxis</code>);</li><li>A set of Euler angles (<code>EulerAngles</code>);</li><li>A quaternion (<code>Quaternion</code>);</li><li>A classical Rodrigues parameter (<code>CRP</code>); or</li><li>A modified Rodrigues parameter (<code>MRP</code>).</li></ul><p>The output will have the same type as <code>R</code>.</p><div class="admonition is-info" id="Note-68b5c90373b80d9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-68b5c90373b80d9" title="Permalink"></a></header><div class="admonition-body"><p>If <code>R</code> is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the user.</p></div></div><div class="admonition is-info" id="Note-25dba3741139651"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-25dba3741139651" title="Permalink"></a></header><div class="admonition-body"><p>If <code>R</code> is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the user.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; inv_rotation(D)
DCM{Float64}:
  0.353553  -0.492816  0.795068
  0.612372   0.764452  0.201527
 -0.707107   0.415627  0.572061

julia&gt; ea = EulerAngleAxis(30 * pi / 180, [1, 0, 0]);

julia&gt; inv_rotation(ea)
EulerAngleAxis{Float64}:
  Euler angle : 0.523599 rad  (30.0°)
  Euler axis  : [-1.0, -0.0, -0.0]

julia&gt; Θ = EulerAngles(-pi / 3, -pi / 2, -pi, :YXZ);

julia&gt; inv_rotation(Θ)
EulerAngles{Float64}:
  R(Z) :  3.14159 rad  ( 180.0°)
  R(X) :  1.5708  rad  ( 90.0°)
  R(Y) :  1.0472  rad  ( 60.0°)

julia&gt; q = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; inv_rotation(q)
Quaternion{Float64}:
  + 0.820071 - 0.0652687⋅i - 0.45794⋅j - 0.336918⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/inv_rotations.jl#L13-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.mrp_to_angle"><a class="docstring-binding" href="#ReferenceFrameRotations.mrp_to_angle"><code>ReferenceFrameRotations.mrp_to_angle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mrp_to_angle(m::MRP, rot_seq::Symbol) -&gt; EulerAngles</code></pre><p>Convert MRP <code>m</code> to Euler Angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MRP(0.5, 0, 0)
MRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; mrp_to_angle(m, :XYZ)
EulerAngles{Float64}:
  R(X) :  1.85459 rad  ( 106.26°)
  R(Y) :  0.0     rad  ( 0.0°)
  R(Z) :  0.0     rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/mrp_to_angle.jl#L9-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.mrp_to_angleaxis-Tuple{MRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.mrp_to_angleaxis-Tuple{MRP}"><code>ReferenceFrameRotations.mrp_to_angleaxis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mrp_to_angleaxis(m::MRP) -&gt; EulerAngleAxis</code></pre><p>Convert the MRP <code>m</code> to a Euler angle and axis representation (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>). By convention, the Euler angle will be kept between <code>[0, π]</code> rad.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MRP(0.5, 0, 0)
MRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; mrp_to_angleaxis(m)
EulerAngleAxis{Float64}:
  Euler angle : 1.85459 rad  (106.26°)
  Euler axis  : [1.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/mrp_to_angleaxis.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.mrp_to_crp-Tuple{MRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.mrp_to_crp-Tuple{MRP}"><code>ReferenceFrameRotations.mrp_to_crp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mrp_to_crp(m::MRP) -&gt; CRP</code></pre><p>Convert MRP <code>m</code> to CRP.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MRP(0.5, 0, 0)
MRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; mrp_to_crp(m)
CRP{Float64}:
  X : + 1.33333
  Y : + 0.0
  Z : + 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/mrp_to_crp.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.mrp_to_dcm-Tuple{MRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.mrp_to_dcm-Tuple{MRP}"><code>ReferenceFrameRotations.mrp_to_dcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mrp_to_dcm(m::MRP) -&gt; DCM</code></pre><p>Convert MRP <code>m</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MRP(0.5, 0, 0)
MRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; mrp_to_dcm(m)
DCM{Float64}:
 1.0   0.0    0.0
 0.0  -0.28   0.96
 0.0  -0.96  -0.28</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/mrp_to_dcm.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.mrp_to_quat-Tuple{MRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.mrp_to_quat-Tuple{MRP}"><code>ReferenceFrameRotations.mrp_to_quat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mrp_to_quat(m::MRP) -&gt; Quaternion</code></pre><p>Convert MRP <code>m</code> to a quaternion.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MRP(0.5, 0, 0)
MRP{Float64}:
  X : + 0.5
  Y : + 0.0
  Z : + 0.0

julia&gt; mrp_to_quat(m)
Quaternion{Float64}:
  + 0.6 + 0.8⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/mrp_to_quat.jl#L9-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.orthonormalize-Tuple{DCM}"><a class="docstring-binding" href="#ReferenceFrameRotations.orthonormalize-Tuple{DCM}"><code>ReferenceFrameRotations.orthonormalize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">orthonormalize(dcm::DCM) -&gt; DCM</code></pre><p>Perform the Gram-Schmidt orthonormalization process in the <code>dcm</code> and return the new matrix.</p><div class="admonition is-warning" id="Warning-855965a777b9ebcf"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-855965a777b9ebcf" title="Permalink"></a></header><div class="admonition-body"><p>This function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have <code>NaN</code>. Notice, however, that such input matrix is not a valid direction cosine matrix.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = DCM(3I)

julia&gt; orthonormalize(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/dcm.jl#L37-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.quat_to_angle"><a class="docstring-binding" href="#ReferenceFrameRotations.quat_to_angle"><code>ReferenceFrameRotations.quat_to_angle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX) -&gt; EulerAngles</code></pre><p>Convert the quaternion <code>q</code> to Euler Angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, it defaults to <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angle(q, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(Z) :  0.0      rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/quat_to_angle.jl#L9-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.quat_to_angleaxis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quat_to_angleaxis(q::Quaternion{T}) where T -&gt; EulerAngleAxis</code></pre><p>Convert the quaternion <code>q</code> to a Euler angle and axis representation (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>). By convention, the Euler angle will be kept between <code>[0, π]</code> rad.</p><p><strong>Remarks</strong></p><p>This function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angleaxis(q)
EulerAngleAxis{Float64}:
  Euler angle : 0.785398 rad  (45.0°)
  Euler axis  : [1.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/quat_to_angleaxis.jl#L9-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.quat_to_crp-Tuple{Quaternion}"><a class="docstring-binding" href="#ReferenceFrameRotations.quat_to_crp-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_crp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quat_to_crp(q::Quaternion) -&gt; CRP</code></pre><p>Convert Quaternion <code>q</code> to CRP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/quat_to_crp.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}"><a class="docstring-binding" href="#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_dcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quat_to_dcm(q::Quaternion) -&gt; DCM</code></pre><p>Convert the quaternion <code>q</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_dcm(q)
DCM{Float64}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/quat_to_dcm.jl#L9-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.quat_to_mrp-Tuple{Quaternion}"><a class="docstring-binding" href="#ReferenceFrameRotations.quat_to_mrp-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_mrp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quat_to_mrp(q::Quaternion) -&gt; MRP</code></pre><p>Convert Quaternion <code>q</code> to MRP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/quat_to_mrp.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.shadow_rotation-Tuple{CRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.shadow_rotation-Tuple{CRP}"><code>ReferenceFrameRotations.shadow_rotation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shadow_rotation(c::CRP) -&gt; CRP</code></pre><p>Compute the shadow rotation of the CRP <code>c</code>.</p><p>The shadow rotation of a CRP is the rotation itself: <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/shadow_rotation.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.shadow_rotation-Tuple{MRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.shadow_rotation-Tuple{MRP}"><code>ReferenceFrameRotations.shadow_rotation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shadow_rotation(m::MRP) -&gt; MRP</code></pre><p>Compute the shadow rotation of the MRP <code>m</code>.</p><p>The shadow rotation of a MRP <code>m</code> is formed by the values <code>q</code> such that:</p><pre><code class="language-julia hljs">|q| &gt; 1</code></pre><p>and represents the same rotation as <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/shadow_rotation.jl#L18-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.smallangle_to_dcm-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><a class="docstring-binding" href="#ReferenceFrameRotations.smallangle_to_dcm-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ReferenceFrameRotations.smallangle_to_dcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true) -&gt; DCM</code></pre><p>Create a direction cosine matrix from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>If the keyword <code>normalize</code> is <code>true</code>, the matrix will be normalized using the function <code>orthonormalize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01)
DCM{Float64}:
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01; normalize = false)
DCM{Float64}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/smallangle_to_dcm.jl#L9-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.smallangle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><a class="docstring-binding" href="#ReferenceFrameRotations.smallangle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ReferenceFrameRotations.smallangle_to_quat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smallangle_to_quat(θx::Number, θy::Number, θz::Number) -&gt; Quaternion</code></pre><p>Create a quaternion from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><div class="admonition is-info" id="Note-c5481d9d3ba7be45"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c5481d9d3ba7be45" title="Permalink"></a></header><div class="admonition-body"><p>The quaternion is always normalized.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; smallangle_to_quat(+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j + 0.00499981⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/smallangle_to_quat.jl#L9-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}"><a class="docstring-binding" href="#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_rot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number[; normalize = true]) -&gt; T</code></pre><p>Create a rotation description of type <code>T</code> from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>The type <code>T</code> of the rotation description can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, if defaults to <code>DCM</code>.</p><p>If <code>T</code> is <code>DCM</code>, the resulting matrix will be orthonormalized using the <code>orthonormalize</code> function if the keyword <code>normalize</code> is <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01)
DCM{Float64}:
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01; normalize = false)
DCM{Float64}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0

julia&gt; q = smallangle_to_rot(Quaternion, +0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j + 0.00499981⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/conversions/smallangle_to_rot.jl#L10-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.vect-Tuple{CRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.vect-Tuple{CRP}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vect(c::CRP) -&gt; SVector{3, T}</code></pre><p>Return the vector definition of the CRP <code>c</code>:</p><pre><code class="language-julia hljs">[q1, q2, q3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/crp.jl#L310-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.vect-Tuple{MRP}"><a class="docstring-binding" href="#ReferenceFrameRotations.vect-Tuple{MRP}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vect(m::MRP) -&gt; SVector{3, T}</code></pre><p>Return the vector definition of the MRP <code>m</code>:</p><pre><code class="language-julia hljs">[q1, q2, q3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/mrp.jl#L328-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ReferenceFrameRotations.vect-Tuple{Quaternion}"><a class="docstring-binding" href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vect(q::Quaternion{T}) -&gt; SVector{3, T}</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3, T}</code>.</p><p>See also: <a href="#Base.imag-Tuple{Quaternion}"><code>imag</code></a>, <a href="#Base.real-Tuple{Quaternion}"><code>real</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.0⋅k

julia&gt; vect(q)
3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.9659258262890683
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/e1501849957fe6f8031e72f9ca40899c03fbf962/src/quaternion.jl#L634-L655">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/random/">« Random rotations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Thursday 26 February 2026 20:50">Thursday 26 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
