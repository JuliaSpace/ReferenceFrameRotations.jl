<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Reference Frame Rotations</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/lib/library/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Reference Frame Rotations</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/dcm/">Direction Cosine Matrices</a></li><li><a class="tocitem" href="../../man/euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="tocitem" href="../../man/euler_angles/">Euler Angles</a></li><li><a class="tocitem" href="../../man/quaternions/">Quaternions</a></li><li><a class="tocitem" href="../../man/conversions/">Conversions</a></li><li><a class="tocitem" href="../../man/kinematics/">Kinematics</a></li><li><a class="tocitem" href="../../man/composing_rotations/">Composing rotations</a></li><li><a class="tocitem" href="../../man/inv_rotations/">Inverting rotations</a></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/master/docs/src/lib/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>ReferenceFrameRotations.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.DCM" href="#ReferenceFrameRotations.DCM"><code>ReferenceFrameRotations.DCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DCM{T}</code></pre><p>The Direction Cosine Matrix (DCM) of type <code>T</code> is a <code>SMatrix{3,3,T,9}</code>, which is a 3x3 static matrix of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DCM(1.0I)
3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; DCM([1 0 0; 0 -1 0; 0 0 -1])
3×3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):
 1   0   0
 0  -1   0
 0   0  -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/types.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngleAxis" href="#ReferenceFrameRotations.EulerAngleAxis"><code>ReferenceFrameRotations.EulerAngleAxis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EulerAngleAxis{T}</code></pre><p>The definition of Euler Angle and Axis to represent a 3D rotation.</p><p><strong>Fields</strong></p><ul><li><code>a::T</code>: The Euler angle [rad].</li><li><code>v::SVector{3, T}</code>: The unitary vector aligned with the Euler axis.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}</code></pre><p>Create an Euler Angle and Axis representation structure with angle <code>a</code> [rad] and vector <code>v</code>.</p><p>The vector <code>v</code> will not be normalized.</p><p>The returned structure type will be selected according to the input types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; EulerAngleAxis(pi / 3, [sqrt(2), sqrt(2), 0])
EulerAngleAxis{Float64}:
  Euler angle:   1.0472 rad ( 60.0000 deg)
   Euler axis: [  1.4142,   1.4142,   0.0000]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/types.jl#L98-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngles" href="#ReferenceFrameRotations.EulerAngles"><code>ReferenceFrameRotations.EulerAngles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EulerAngles{T}</code></pre><p>The definition of Euler Angles, which is composed of three angles <code>a1</code>, <code>a2</code>, and <code>a3</code> together with a rotation sequence <code>rot_seq</code>.</p><p><strong>Fields</strong></p><ul><li><code>a1::T</code>: First rotation [rad].</li><li><code>a2::T</code>: Second rotation [rad].</li><li><code>a3::T</code>: Third rotation [rad].</li><li><code>rot_seq::Symbol</code>: Rotation sequence.</li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><code>rot_seq</code> is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle, <em>e.g.</em> <code>:ZYX</code>. The valid values for <code>rot_seq</code> are:</p><ul><li><code>:XYX</code>, <code>:XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>,   <code>:ZXZ</code>, <code>:ZYX</code>, and <code>ZYZ</code>.</li></ul></div></div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1, T2, T3}</code></pre><p>Create a new instance of <code>EulerAngles</code> with the angles <code>a1</code>, <code>a2</code>, and <code>a3</code> and the rotation sequence <code>rot_seq</code>.</p><p>The type will be inferred from <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p><p>If <code>rot_seq</code> is not provided, then it defaults to <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; EulerAngles(pi / 2, pi / 4, -pi, :XYZ)
EulerAngles{Float64}:
  R(X) :  1.5707963267948966 rad  ( 90.0°)
  R(Y) :  0.7853981633974483 rad  ( 45.0°)
  R(Z) : -3.141592653589793  rad  (-180.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/types.jl#L36-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion" href="#ReferenceFrameRotations.Quaternion"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Quaternion{T} &lt;: AbstractVector{T}</code></pre><p>The definition of the quaternion.</p><p><strong>Fields</strong></p><ul><li><code>q0::T</code>: Quaternion real part.</li><li><code>q1::T</code>: X component of the quaternion imaginary part.</li><li><code>q2::T</code>: Y component of the quaternion imaginary part.</li><li><code>q3::T</code>: Z component of the quaternion imaginary part.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The quaternion <code>q</code> in this structure is represented by:</p><pre><code class="nohighlight hljs">q = q0 + q1.i + q2.j + q3.k</code></pre></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(cosd(45), sind(45), 0, 0)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.7071067811865476.i + 0.0.j + 0.0.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/types.jl#L144-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0, T1, T2, T3}</code></pre><p>Create the following quaternion:</p><pre><code class="nohighlight hljs">q0 + q1.i + q2.j + q3.k</code></pre><p>in which:</p><ul><li><code>q0</code> is the real part of the quaternion.</li><li><code>q1</code> is the X component of the quaternion vectorial part.</li><li><code>q2</code> is the Y component of the quaternion vectorial part.</li><li><code>q3</code> is the Z component of the quaternion vectorial part.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The quaternion type is obtained by promoting <code>T0</code>, <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; Quaternion(1, 0, 0, 0.0)
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre><hr/><pre><code class="nohighlight hljs">Quaternion(v::AbstractVector)</code></pre><p>If the vector <code>v</code> has 3 components, then create a quaternion in which the real part is <code>0</code> and the vectorial or imaginary part has the same components of the vector <code>v</code>. In other words:</p><pre><code class="nohighlight hljs">q = 0 + v[1].i + v[2].j + v[3].k</code></pre><p>Otherwise, if the vector <code>v</code> has 4 components, then create a quaternion in which the elements match those of the input vector:</p><pre><code class="nohighlight hljs">q = v[1] + v[2].i + v[3].j + v[4].k</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the length of <code>v</code> is not 3 or 4, then an error is thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion([0, cosd(45), sind(45)])
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k

julia&gt; Quaternion([cosd(45), 0, sind(45), 0])
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k</code></pre><hr/><pre><code class="nohighlight hljs">Quaternion(r::Number, v::AbstractVector)</code></pre><p>Create a quaternion with real part <code>r</code> and vectorial or imaginary part <code>v</code>:</p><pre><code class="nohighlight hljs">r + v[1].i + v[2].j + v[3].k</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The quaternion type is obtained by promoting the type of <code>r</code> and the elements of <code>v</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(cosd(45), [0, sind(45), 0])
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k</code></pre><hr/><pre><code class="nohighlight hljs">Quaternion(u::UniformScaling{T}) where T
Quaternion{T}(u::UniformScaling) where T
Quaternion(u::UniformScaling, Q::Quaternion{T}) where T</code></pre><p>Create the quaternion <code>u.λ + 0.i + 0.j + 0.k</code>.</p><p>If a quaternion is passed as in the third signature, then the new quaternion will have the same type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Quaternion(I)
Quaternion{Bool}:
  + true + false⋅i + false⋅j + false⋅k

julia&gt; Quaternion(1.0I)
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k

julia&gt; q = Quaternion{Float32}(I)
Quaternion{Float32}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k

julia&gt; Quaternion(I, q)
Quaternion{Float32}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L16-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractVector{T} where T, Quaternion}" href="#Base.:*-Tuple{AbstractVector{T} where T, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(v::AbstractVector, q::Quaternion)
*(q::Quaternion, v::AbstractVector)</code></pre><p>Compute the multiplication <code>qv * q</code> or <code>q * qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; v = [0, cosd(60), sind(60)]
3-element Vector{Float64}:
 0.0
 0.5
 0.8660254037844386

julia&gt; q * v
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 0.5⋅j + 0.5⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L324-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{EulerAngles, EulerAngles}" href="#Base.:*-Tuple{EulerAngles, EulerAngles}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(Θ₂::EulerAngles, Θ₁::EulerAngles)</code></pre><p>Compute the composed rotation of <code>Θ₁ -&gt; Θ₂</code>.</p><p>The rotation will be represented by Euler angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) with the same rotation sequence as <code>Θ₂</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ea1 = EulerAngles(deg2rad(35), 0, 0, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.610865 rad  ( 35.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(Z) :  0.0      rad  ( 0.0°)

julia&gt; ea2 = EulerAngles(0, 0, deg2rad(25), :ZYX)
EulerAngles{Float64}:
  R(Z) :  0.0      rad  ( 0.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(X) :  0.436332 rad  ( 25.0°)

julia&gt; ea2 * ea1
EulerAngles{Float64}:
  R(Z) :  0.0    rad  ( 0.0°)
  R(Y) : -0.0    rad  (-0.0°)
  R(X) :  1.0472 rad  ( 60.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/angle.jl#L14-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Number, Quaternion}" href="#Base.:*-Tuple{Number, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(λ::Number, q::Quaternion)
*(q::Quaternion, λ::Number)</code></pre><p>Compute <code>λ * q</code> or <code>q * λ</code>, in which <code>λ</code> is a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; 2 * q
Quaternion{Int64}:
  + 2 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L259-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Quaternion, Quaternion}" href="#Base.:*-Tuple{Quaternion, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute the quaternion multiplication <code>q1 * q2</code> (Hamilton product).</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="nohighlight hljs">*(u::UniformScaling, q::Quaternion)
*(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(cosd(30), 0, sind(30), 0)
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k

julia&gt; q2 = Quaternion(cosd(60), 0, sind(60), 0)
Quaternion{Float64}:
  + 0.5 + 0.0⋅i + 0.866025⋅j + 0.866025⋅k

julia&gt; q1 * q2
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 1.0⋅j + 1.0⋅k

julia&gt; I * q1
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L280-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}" href="#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(av₂::EulerAngleAxis{T1}, av₁::EulerAngleAxis{T2}) where {T1,T2}</code></pre><p>Compute the composed rotation of <code>av₁ -&gt; av₂</code>.</p><p>The rotation will be represented by a Euler angle and axis (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>). By convention, the output angle will always be in the range <code>[0, π] rad</code>.</p><p>Notice that the vector representing the axis in <code>av₁</code> and <code>av₂</code> must be unitary. This function neither verifies this nor normalizes the vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; av1 = EulerAngleAxis(deg2rad(45), [sqrt(2)/2, sqrt(2)/2, 0])
EulerAngleAxis{Float64}:
  Euler angle : 0.785398 rad  (45.0°)
  Euler axis  : [0.707107, 0.707107, 0.0]

julia&gt; av2 = EulerAngleAxis(deg2rad(22.5), [sqrt(2)/2, sqrt(2)/2, 0])
EulerAngleAxis{Float64}:
  Euler angle : 0.392699 rad  (22.5°)
  Euler axis  : [0.707107, 0.707107, 0.0]

julia&gt; av1 * av2
EulerAngleAxis{Float64}:
  Euler angle : 1.1781 rad  (67.5°)
  Euler axis  : [0.707107, 0.707107, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/angleaxis.jl#L14-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Quaternion, Quaternion}" href="#Base.:+-Tuple{Quaternion, Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa + qb</code>.</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="nohighlight hljs">+(u::UniformScaling, q::Quaternion)
+(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; q2 = Quaternion(0, cosd(45), 0, sind(45))
Quaternion{Float64}:
  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.0⋅k

julia&gt; q1 + q2
Quaternion{Float64}:
  + 1.0 + 0.707107⋅i + 0.0⋅j + 0.0⋅k

julia&gt; q1 + I
Quaternion{Int64}:
  + 2 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L156-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Quaternion, Quaternion}" href="#Base.:--Tuple{Quaternion, Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa - qb</code>.</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="nohighlight hljs">-(u::UniformScaling, q::Quaternion)
-(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; q2 = Quaternion(0, cosd(45), 0, sind(45))
Quaternion{Float64}:
  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.0⋅k

julia&gt; q1 - q2
Quaternion{Float64}:
  + 1.0 - 0.707107⋅i + 0.0⋅j + 0.0⋅k

julia&gt; q1 - I
Quaternion{Int64}:
  + 0 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L217-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Quaternion}" href="#Base.:--Tuple{Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(q::Quaternion)</code></pre><p>Return the quaterion <code>-q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; -q
Quaternion{Int64}:
  - 1 + 0⋅i + 0⋅j + 0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L198-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Number, Quaternion}" href="#Base.:/-Tuple{Number, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">/(λ::Number, q::Quaternion)
/(q::Quaternion, λ::Number)</code></pre><p>Compute the division <code>λ / q</code> or <code>q / λ</code>, in which <code>λ</code> is a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(2, 0, 0, 0)
Quaternion{Int64}:
  + 2 + 0⋅i + 0⋅j + 0⋅k

julia&gt; q / 2
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L370-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Quaternion, Quaternion}" href="#Base.:/-Tuple{Quaternion, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">/(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute <code>q1 * inv(q2)</code> (Hamilton product).</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="nohighlight hljs">/(u::UniformScaling, q::Quaternion)
/(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k

julia&gt; q2 = Quaternion(cosd(30), 0, sind(30), 0)
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k

julia&gt; q1 / q2
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k

julia&gt; q1 / (2 * I)
Quaternion{Float64}:
  + 0.12941 + 0.0⋅i + 0.482963⋅j + 0.482963⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L402-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion, AbstractVector{T} where T}" href="#Base.:\\-Tuple{Quaternion, AbstractVector{T} where T}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">\(v::AbstractVector, q::Quaternion)
\(q::Quaternion, v::AbstractVector)</code></pre><p>Compute the division <code>qv \ q</code> or <code>q \ qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, 0, 0)
Quaternion{Int64}:
  + 1 + 0⋅i + 0⋅j + 0⋅k

julia&gt; v = [0, cosd(60), sind(60)]
3-element Vector{Float64}:
 0.0
 0.5
 0.8660254037844386

julia&gt; v \ q
Quaternion{Float64}:
  + 0.0 + 0.0⋅i - 0.5⋅j - 0.5⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L473-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion, Quaternion}" href="#Base.:\\-Tuple{Quaternion, Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">\(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute <code>inv(q1) * q2</code>.</p><p>If one of the operands is a <code>UniformScaling</code>:</p><pre><code class="nohighlight hljs">\(u::UniformScaling, q::Quaternion)
\(q::Quaternion, u::UniformScaling)</code></pre><p>then it is considered as the quaternion <code>u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q1 = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k

julia&gt; q2 = Quaternion(cosd(30), 0, sind(30), 0)
Quaternion{Float64}:
  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k

julia&gt; q2 \ q1
Quaternion{Float64}:
  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L441-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Quaternion}" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(q::Quaternion)</code></pre><p>Compute the complex conjugate of the quaternion <code>q</code>:</p><pre><code class="nohighlight hljs">q0 - q1.i - q2.j - q3.k</code></pre><p>See also: <a href="#Base.inv-Tuple{EulerAngles}"><code>inv</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, cosd(75), 0, sind(75))
Quaternion{Float64}:
  + 1.0 + 0.258819⋅i + 0.0⋅j + 0.0⋅k

julia&gt; conj(q)
Quaternion{Float64}:
  + 1.0 - 0.258819⋅i - 0.0⋅j - 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L505-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(q::Quaternion{T}) where T</code></pre><p>Create a copy of the quaternion <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L528-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.imag-Tuple{Quaternion}" href="#Base.imag-Tuple{Quaternion}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imag(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p><p>See also: <a href="#Base.real-Tuple{Quaternion}"><code>real</code></a>, <a href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>vect</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k

julia&gt; imag(q)
3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.9659258262890683
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L538-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{EulerAngles}" href="#Base.inv-Tuple{EulerAngles}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(Θ::EulerAngles)</code></pre><p>Return the Euler angles that represent the inverse rotation of <code>Θ</code>.</p><p>The rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, <code>:XYZ</code>, then the result will be represented using <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ea = EulerAngles(π / 3, π / 6,  2 / 3 * π, :ZYX)
EulerAngles{Float64}:
  R(Z) :  1.0472   rad  ( 60.0°)
  R(Y) :  0.523599 rad  ( 30.0°)
  R(X) :  2.0944   rad  ( 120.0°)

julia&gt; inv(ea)
EulerAngles{Float64}:
  R(X) : -2.0944   rad  (-120.0°)
  R(Y) : -0.523599 rad  (-30.0°)
  R(Z) : -1.0472   rad  (-60.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/angle.jl#L53-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Quaternion}" href="#Base.inv-Tuple{Quaternion}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(q::Quaternion)</code></pre><p>Compute the inverse of the quaternion <code>q</code>:</p><pre><code class="nohighlight hljs">conj(q)
-------
  |q|²</code></pre><p>See also: <a href="#Base.conj-Tuple{Quaternion}"><code>conj</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1, 0, cosd(75), sind(75))
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 0.258819⋅j + 0.258819⋅k

julia&gt; inv(q)
Quaternion{Float64}:
  + 0.5 - 0.0⋅i - 0.12941⋅j - 0.12941⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L562-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number" href="#Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(av::EulerAngleAxis)</code></pre><p>Compute the inverse rotation of the Euler angle and axis <code>av</code>.</p><p>The Euler angle returned by this function will always be in the interval <code>[0, π] rad</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; av = EulerAngleAxis(deg2rad(20), [sqrt(2) / 2, 0, sqrt(2) / 2])
EulerAngleAxis{Float64}:
  Euler angle : 0.349066 rad  (20.0°)
  Euler axis  : [0.707107, 0.0, 0.707107]

julia&gt; inv(av)
EulerAngleAxis{Float64}:
  Euler angle : 0.349066 rad  (20.0°)
  Euler axis  : [-0.707107, -0.0, -0.707107]

julia&gt; av = EulerAngleAxis(deg2rad(-20), [sqrt(2) / 2, 0, sqrt(2) / 2])
EulerAngleAxis{Float64}:
  Euler angle : -0.349066 rad  (-20.0°)
  Euler axis  : [0.707107, 0.0, 0.707107]

julia&gt; inv(av)
EulerAngleAxis{Float64}:
  Euler angle : 0.349066 rad  (20.0°)
  Euler axis  : [0.707107, 0.0, 0.707107]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/angleaxis.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{Quaternion}" href="#Base.real-Tuple{Quaternion}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(q::Quaternion)</code></pre><p>Return the real part of the quaternion <code>q</code>: <code>q0</code>.</p><p>See also: <a href="#Base.imag-Tuple{Quaternion}"><code>imag</code></a>, <a href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>vect</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k

julia&gt; real(q)
0.25881904510252074</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L617-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros(::Type{Quaternion{T}}) where T</code></pre><p>Create the null quaternion: <code>0 + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k</code>.</p><p>The type of the new quaternion will be <code>T</code>. If the type <code>T</code> is omitted, then it defaults to <code>Float64</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zeros(Quaternion{Float32})
Quaternion{Float32}:
  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k

julia&gt; zeros(Quaternion)
Quaternion{Float64}:
  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre><hr/><pre><code class="nohighlight hljs">zeros(q::Quaternion{T}) where T</code></pre><p>Create the null quaternion with the same type <code>T</code> of another quaternion <code>q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion{Float32}(1, 0, 0, 0)
Quaternion{Float32}:
  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k

julia&gt; zeros(q)
Quaternion{Float32}:
  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L661-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Quaternion}" href="#LinearAlgebra.norm-Tuple{Quaternion}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(q::Quaternion)</code></pre><p>Compute the Euclidean norm of the quaternion <code>q</code>:</p><pre><code class="nohighlight hljs">√(q0² + q1² + q2² + q3²)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k

julia&gt; norm(q)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L597-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}" href="#ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}"><code>ReferenceFrameRotations.angle_to_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)
angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq_orig</code> to a new set of Euler angles with rotation sequence <code>rot_seq_dest</code>.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X) : -1.0472   rad  (-60.0°)
  R(Y) :  0.785398 rad  ( 45.0°)
  R(Z) : -1.5708   rad  (-90.0°)

julia&gt; angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.0    rad  ( 0.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(Z) : -1.5708 rad  (-90.0°)

julia&gt; Θ = EulerAngles(1, 2, 3, :XYX)
EulerAngles{Int64}:
  R(X) :  1 rad  ( 57.2958°)
  R(Y) :  2 rad  ( 114.592°)
  R(X) :  3 rad  ( 171.887°)

julia&gt; angle_to_angle(Θ, :ZYZ)
EulerAngles{Float64}:
  R(Z) : -2.70239 rad  (-154.836°)
  R(Y) :  1.46676 rad  ( 84.0393°)
  R(Z) : -1.05415 rad  (-60.3984°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angle_to_angle.jl#L12-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_angleaxis" href="#ReferenceFrameRotations.angle_to_angleaxis"><code>ReferenceFrameRotations.angle_to_angleaxis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)
angle_to_angleaxis(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to an Euler angle and axis representation.</p><p>Those values can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_angleaxis(1, 0, 0, :XYZ)
EulerAngleAxis{Float64}:
  Euler angle : 1.0 rad  (57.2958°)
  Euler axis  : [1.0, 0.0, 0.0]

julia&gt; Θ = EulerAngles(1, 1, 1, :XYZ);

julia&gt; angle_to_angleaxis(Θ)
EulerAngleAxis{Float64}:
  Euler angle : 1.93909 rad  (111.102°)
  Euler axis  : [0.692363, 0.203145, 0.692363]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angle_to_angleaxis.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm" href="#ReferenceFrameRotations.angle_to_dcm"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">angle_to_dcm(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)
angle_to_dcm(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a direction cosine matrix.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_dcm(pi / 2, pi / 3, pi / 4, :ZYX)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angle_to_dcm.jl#L12-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}, Tuple{T1, T2, T3, Symbol}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}, Tuple{T1, T2, T3, Symbol}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle_to_quat(θ₁::T1, θ₂::T2, θ₃::T3, rot_seq::Symbol = :ZYX) where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}
angle_to_quat(eulerang::EulerAngles)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a quaternion.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type of the new quaternion will be obtained by promiting <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p></div></div><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; angle_to_quat(pi / 2, pi / 3, pi / 4, :ZYX)
Quaternion{Float64}:
  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.560986⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angle_to_quat.jl#L12-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{Number, Number, Number, Symbol}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{Number, Number, Number, Symbol}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle_to_rot([T,] θx::Number, θy::Number, θz::Number, rot_seq::Symbol)
angle_to_rot([T,] Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θx</code>, <code>Θy</code>, and <code>Θz</code> [rad] with the rotation sequence <code>rot_seq</code> to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>.</p><p>The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>).</p><p>If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_rot(pi / 2, pi / 3, pi / 4, :ZYX)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q = angle_to_rot(Quaternion, pi / 2, pi / 3, pi / 4, :ZYX)
Quaternion{Float64}:
  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.560986⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angle_to_rot.jl#L13-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector{T} where T, Symbol}" href="#ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector{T} where T, Symbol}"><code>ReferenceFrameRotations.angleaxis_to_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)
angleaxis_to_angle(av::EulerAngleAxis, rot_seq::Symbol)</code></pre><p>Convert the Euler angle <code>θ</code> [rad]  and Euler axis <code>v</code> to Euler angles with rotation sequence <code>rot_seq</code>.</p><p>Those values can also be passed inside the structure <code>av</code> (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; av = EulerAngleAxis(deg2rad(45), [1, 0, 0]);

julia&gt; angleaxis_to_angle(av, :ZXY)
EulerAngles{Float64}:
  R(Z) :  0.0      rad  ( 0.0°)
  R(X) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.0      rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angleaxis_to_angle.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number, AbstractVector{T} where T}" href="#ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number, AbstractVector{T} where T}"><code>ReferenceFrameRotations.angleaxis_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angleaxis_to_dcm(a::Number, v::AbstractVector)
angleaxis_to_dcm(av::EulerAngleAxis)</code></pre><p>Convert the Euler angle <code>a</code> [rad] and Euler axis <code>v</code> to a DCM.</p><p>Those values can also be passed inside the structure <code>ea</code> (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1, 1, 1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_dcm(pi / 2, v)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333

julia&gt; ea = EulerAngleAxis(pi / 2, v);

julia&gt; angleaxis_to_dcm(ea)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angleaxis_to_dcm.jl#L12-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number, AbstractVector{T} where T}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number, AbstractVector{T} where T}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angleaxis_to_quat(θ::Number, v::AbstractVector)
angleaxis_to_quat(angleaxis::EulerAngleAxis)</code></pre><p>Convert the Euler angle <code>θ</code> [rad] and Euler axis <code>v</code> to a quaternion.</p><p>Those values can also be passed inside the structure <code>ea</code> (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1, 1, 1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(pi/2,v)
Quaternion{Float64}:
  + 0.707107 + 0.408248⋅i + 0.408248⋅j + 0.408248⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/angleaxis_to_quat.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.compose_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose_rotation(R1, [, R2, R3, R4, R5, ...])</code></pre><p>Compute a composed rotation using the rotations <code>R1</code>, <code>R2</code>, <code>R3</code>, <code>R4</code>, ..., in the following order:</p><pre><code class="nohighlight hljs"> First rotation
 |
 |
R1 =&gt; R2 =&gt; R3 =&gt; R4 =&gt; ...
       |
       |
       Second rotation</code></pre><p>The rotations can be described by:</p><ul><li>A direction cosine matrix (<a href="#ReferenceFrameRotations.DCM"><code>DCM</code></a>);</li><li>An Euler angle and axis (<a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>);</li><li>A set of Euler angles (<a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>); or</li><li>A quaternion (<a href="#ReferenceFrameRotations.Quaternion"><code>Quaternion</code></a>).</li></ul><p>Notice, however, that all rotations <strong>must be</strong> of the same type (DCM or quaternion).</p><p>The output will have the same type as the inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D1 = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; D2 = angle_to_dcm(-pi / 5, -pi / 4, -pi / 3, :XYZ);

julia&gt; compose_rotation(D1, D2)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 1.0          1.08801e-17  3.54837e-17
 1.08801e-17  1.0          2.88714e-17
 3.54837e-17  2.88714e-17  1.0

julia&gt; ea1 = EulerAngleAxis(30 * pi / 180, [0, 1, 0]);

julia&gt; ea2 = EulerAngleAxis(45 * pi / 180, [0, 1, 0]);

julia&gt; compose_rotation(ea1, ea2)
EulerAngleAxis{Float64}:
  Euler angle : 1.309 rad  (75.0°)
  Euler axis  : [0.0, 1.0, 0.0]

julia&gt; Θ1 = EulerAngles(1, 2, 3, :ZYX);

julia&gt; Θ2 = EulerAngles(-3, -2, -1, :XYZ);

julia&gt; compose_rotation(Θ1, Θ2)
EulerAngles{Float64}:
  R(X) : -1.66533e-16 rad  (-9.54166e-15°)
  R(Y) :  9.24446e-33 rad  ( 5.29669e-31°)
  R(Z) : -1.11022e-16 rad  (-6.36111e-15°)

julia&gt; q1 = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; q2 = angle_to_quat(-pi / 5, -pi / 4, -pi / 3, :XYZ);

julia&gt; compose_rotation(q1, q2)
Quaternion{Float64}:
  + 1.0 + 0.0⋅i + 2.08167e-17⋅j + 2.08167e-17⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/compose_rotations.jl#L16-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.create_rotation_matrix" href="#ReferenceFrameRotations.create_rotation_matrix"><code>ReferenceFrameRotations.create_rotation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_rotation_matrix(angle::Number, axis::Symbol = :X)</code></pre><p>Compute a rotation matrix that rotates a coordinate frame about the <code>axis</code> by the <code>angle</code>.</p><p>The <code>axis</code> must be one of the following symbols: <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</p><p><strong>Example</strong></p><pre><code class="language-jldocstest hljs">julia&gt; create_rotation_matrix(pi/2, :X)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0          0.0
 0.0   6.12323e-17  1.0
 0.0  -1.0          6.12323e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/dcm.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angle-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, 9}, Symbol}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, 9}, Symbol}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX)</code></pre><p>Convert the <code>dcm</code> to Euler Angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Gimbal-lock and special cases</strong></p><p>If the rotations are about three different axes, <em>e.g.</em> <code>:XYZ</code>, <code>:ZYX</code>, etc., then a second rotation of <code>±90˚</code> yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation, and the angle of the third rotation is set to 0.</p><p>If the rotations are about two different axes, <em>e.g.</em> <code>:XYX</code>, <code>:YXY</code>, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);

julia&gt; dcm_to_angle(D,:XYZ)
EulerAngles{Float64}:
  R(X) :  1.5708 rad  ( 90.0°)
  R(Y) :  0.0    rad  ( 0.0°)
  R(Z) :  0.0    rad  ( 0.0°)

julia&gt; D = angle_to_dcm(1, -pi / 2, 2, :ZYX);

julia&gt; dcm_to_angle(D, :ZYX)
EulerAngles{Float64}:
  R(Z) :  3.0    rad  ( 171.887°)
  R(Y) : -1.5708 rad  (-90.0°)
  R(X) :  0.0    rad  ( 0.0°)

julia&gt; D = create_rotation_matrix(1, :X) * create_rotation_matrix(2, :X);

julia&gt; dcm_to_angle(D, :XYX)
EulerAngles{Float64}:
  R(X) :  3.0 rad  ( 171.887°)
  R(Y) :  0.0 rad  ( 0.0°)
  R(X) :  0.0 rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/dcm_to_angle.jl#L12-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angleaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcm_to_angleaxis(dcm::DCM{T}) where T&lt;:Number</code></pre><p>Convert the <code>dcm</code> to an Euler angle and axis representation.</p><p>By convention, the returned Euler angle will always be in the interval [0, π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/dcm_to_angleaxis.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.dcm_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcm_to_quat(dcm::DCM)</code></pre><p>Convert the <code>dcm</code> to a quaternion.</p><p>The type of the quaternion will be automatically selected by the constructor <a href="#ReferenceFrameRotations.Quaternion"><code>Quaternion</code></a> to avoid <code>InexactError</code>.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p>This algorithm was obtained from <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = angle_to_dcm(pi / 2, 0.0, 0.0, :XYZ);

julia&gt; q = dcm_to_quat(dcm)
Quaternion{Float64}:
  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k</code></pre><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/dcm_to_quat.jl#L12-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T, AbstractArray}" href="#ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T, AbstractArray}"><code>ReferenceFrameRotations.ddcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddcm(Dba::DCM, wba_b::AbstractArray)</code></pre><p>Compute the time-derivative of the <code>dcm</code> that rotates a reference frame <code>a</code> into alignment with the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = DCM(1.0I);

julia&gt; ddcm(D, [1, 0, 0])
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.0   0.0  0.0
 0.0   0.0  1.0
 0.0  -1.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/dcm.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector{T} where T}" href="#ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector{T} where T}"><code>ReferenceFrameRotations.dquat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dquat(qba::Quaternion, wba_b::AbstractVector)</code></pre><p>Compute the time-derivative of the quaternion <code>qba</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(1.0I);

julia&gt; dquat(q,[1;0;0])
Quaternion{Float64}:
  - 0.0 + 0.5⋅i + 0.0⋅j + 0.0⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L794-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.inv_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv_rotation(R)</code></pre><p>Compute the inverse rotation of <code>R</code>, which can be:</p><ul><li>A direction cosina matrix (<code>DCM</code>);</li><li>An Euler angle and axis (<code>EulerAngleAxis</code>);</li><li>A set of Euler anlges (<code>EulerAngles</code>); or</li><li>A quaternion (<code>Quaternion</code>).</li></ul><p>The output will have the same type as <code>R</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>R</code> is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the user.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>R</code> is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the used.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; inv_rotation(D)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.353553  -0.492816  0.795068
  0.612372   0.764452  0.201527
 -0.707107   0.415627  0.572061

julia&gt; ea = EulerAngleAxis(30 * pi / 180, [1, 0, 0]);

julia&gt; inv_rotation(ea)
EulerAngleAxis{Float64}:
  Euler angle : 0.523599 rad  (30.0°)
  Euler axis  : [-1.0, -0.0, -0.0]

julia&gt; Θ = EulerAngles(-pi / 3, -pi / 2, -pi, :YXZ);

julia&gt; inv_rotation(Θ)
EulerAngles{Float64}:
  R(Z) :  3.14159 rad  ( 180.0°)
  R(X) :  1.5708  rad  ( 90.0°)
  R(Y) :  1.0472  rad  ( 60.0°)

julia&gt; q = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);

julia&gt; inv_rotation(q)
Quaternion{Float64}:
  + 0.820071 - 0.0652687⋅i - 0.45794⋅j - 0.45794⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/inv_rotations.jl#L16-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.orthonormalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthonormalize(dcm::DCM)</code></pre><p>Perform the Gram-Schmidt orthonormalization process in the <code>dcm</code> and return the new matrix.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have <code>NaN</code>. Notice, however, that such input matrix is not a valid direction cosine matrix.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = DCM(3I)

julia&gt; orthonormalize(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/dcm.jl#L57-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angle" href="#ReferenceFrameRotations.quat_to_angle"><code>ReferenceFrameRotations.quat_to_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the quaternion <code>q</code> to Euler Angles (see <a href="#ReferenceFrameRotations.EulerAngles"><code>EulerAngles</code></a>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angle(q, :XYZ)
EulerAngles{Float64}:
  R(X) :  0.785398 rad  ( 45.0°)
  R(Y) :  0.0      rad  ( 0.0°)
  R(Z) :  0.0      rad  ( 0.0°)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/quat_to_angle.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.quat_to_angleaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quat_to_angleaxis(q::Quaternion{T}) where T</code></pre><p>Convert the quaternion <code>q</code> to a Euler angle and axis representation (see <a href="#ReferenceFrameRotations.EulerAngleAxis"><code>EulerAngleAxis</code></a>). By convention, the Euler angle will be kept between <code>[0, π] rad</code>.</p><p><strong>Remarks</strong></p><p>This function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angleaxis(q)
EulerAngleAxis{Float64}:
  Euler angle : 0.785398 rad  (45.0°)
  Euler axis  : [1.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/quat_to_angleaxis.jl#L12-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}" href="#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quat_to_dcm(q::Quaternion)</code></pre><p>Convert the quaternion <code>q</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_dcm(q)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/quat_to_dcm.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number, Number, Number}" href="#ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)</code></pre><p>Create a direction cosine matrix from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>If the keyword <code>normalize</code> is <code>true</code>, then the matrix will be normalized using the function <code>orthonormalize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01; normalize = false)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/smallangle_to_dcm.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_quat-Tuple{Number, Number, Number}" href="#ReferenceFrameRotations.smallangle_to_quat-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smallangle_to_quat(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a quaternion from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The quaternion is always normalized.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; smallangle_to_quat(+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j - 0.00499981⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/smallangle_to_quat.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}" href="#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number[; normalize = true])</code></pre><p>Create a rotation description of type <code>T</code> from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>The type <code>T</code> of the rotation description can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then if defaults to <code>DCM</code>.</p><p>If <code>T</code> is <code>DCM</code>, then the resulting matrix will be orthonormalized using the <code>orthonormalize</code> function if the keyword <code>normalize</code> is <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01; normalize = false)
3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0

julia&gt; q = smallangle_to_rot(Quaternion, +0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j - 0.00499981⋅k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/conversions/smallangle_to_rot.jl#L13-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.vect-Tuple{Quaternion}" href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vect(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p><p>See also: <a href="#Base.imag-Tuple{Quaternion}"><code>imag</code></a>, <a href="#Base.real-Tuple{Quaternion}"><code>real</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Quaternion(cosd(75), 0, sind(75), 0)
Quaternion{Float64}:
  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k

julia&gt; vect(q)
3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.9659258262890683
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/9fb9d422cb373c62e9b2aa86e21cdbb101afa43a/src/quaternion.jl#L637-L658">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/inv_rotations/">« Inverting rotations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 25 August 2021 15:51">Wednesday 25 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
