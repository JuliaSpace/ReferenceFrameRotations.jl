<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Reference Frame Rotations</title><link rel="canonical" href="https://juliaspace.github.io/ReferenceFrameRotations.jl/stable/lib/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><div class="docs-package-name"><span class="docs-autofit">Reference Frame Rotations</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/dcm/">Direction Cosine Matrices</a></li><li><a class="tocitem" href="../../man/euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="tocitem" href="../../man/euler_angles/">Euler Angles</a></li><li><a class="tocitem" href="../../man/quaternions/">Quaternions</a></li><li><a class="tocitem" href="../../man/conversions/">Conversions</a></li><li><a class="tocitem" href="../../man/kinematics/">Kinematics</a></li><li><a class="tocitem" href="../../man/composing_rotations/">Composing rotations</a></li><li><a class="tocitem" href="../../man/inv_rotations/">Inverting rotations</a></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/master/docs/src/lib/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>ReferenceFrameRotations.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.DCM" href="#ReferenceFrameRotations.DCM"><code>ReferenceFrameRotations.DCM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Direction Cosine Matrix of type <code>T</code> is a <code>SMatrix{3,3,T,9}</code>, which is a 3x3 static matrix of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/ReferenceFrameRotations.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngleAxis" href="#ReferenceFrameRotations.EulerAngleAxis"><code>ReferenceFrameRotations.EulerAngleAxis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EulerAngleAxis{T}</code></pre><p>The definition of Euler Angle and Axis to represent a 3D rotation.</p><p><strong>Fields</strong></p><ul><li><code>a</code>: The Euler angle [rad].</li><li><code>v</code>: The unitary vector aligned with the Euler axis.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}</code></pre><p>Create an Euler Angle and Axis representation structure with angle <code>a</code> [rad] and vector <code>v</code>. Notice that the vector <code>v</code> will not be normalized. The type of the returned structure will be selected according to the input types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/ReferenceFrameRotations.jl#L62-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngles" href="#ReferenceFrameRotations.EulerAngles"><code>ReferenceFrameRotations.EulerAngles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EulerAngles{T}</code></pre><p>The definition of Euler Angles, which is composed of three angles <code>a1</code>, <code>a2</code>, and <code>a3</code> together with a rotation sequence <code>rot_seq</code>. The latter is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle (for example, <code>:ZYX</code>). The valid values for <code>rot_seq</code> are:</p><ul><li><code>:XYX</code>, <code>:XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>ZYZ</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">EulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1,T2,T3}</code></pre><p>Create a new instance of <code>EulerAngles</code> with the angles <code>a1</code>, <code>a2</code>, and <code>a3</code> and the rotation sequence <code>rot_seq</code>. The type will be inferred from <code>T1</code>, <code>T2</code>, and <code>T3</code>. If <code>rot_seq</code> is not provided, then it defaults to <code>:ZYX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/ReferenceFrameRotations.jl#L28-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion" href="#ReferenceFrameRotations.Quaternion"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quaternion{T} &lt;: AbstractVector{T}</code></pre><p>The definition of the quaternion. It has four values of type <code>T</code>. The quaternion representation is:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/ReferenceFrameRotations.jl#L94-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{AbstractVector{T} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{AbstractVector{T} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(v::AbstractVector)</code></pre><p>If the vector <code>v</code> has 3 components, then create a quaternion in which the real part is <code>0</code> and the vectorial or imaginary part has the same components of the vector <code>v</code>. In other words:</p><pre><code class="language-none">q = 0 + v[1].i + v[2].j + v[3].k</code></pre><p>Otherwise, if the vector <code>v</code> has 4 components, then create a quaternion in which the elements match those of the input vector:</p><pre><code class="language-none">q = v[1] + v[2].i + v[3].j + v[4].k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L31-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{Number, AbstractVector{T} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{Number, AbstractVector{T} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(r::Number, v::AbstractVector)</code></pre><p>Create a quaternion with real part <code>r</code> and vectorial or imaginary part <code>v</code>:</p><pre><code class="language-none">r + v[1].i + v[2].j + v[3].k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{LinearAlgebra.UniformScaling{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{LinearAlgebra.UniformScaling{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(u::UniformScaling{T}) where T
Quaternion{T}(u::UniformScaling) where T</code></pre><p>Create the quaternion <code>u.λ + 0.i + 0.j + 0.k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0,T1,T2,T3}</code></pre><p>Create the following quaternion:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre><p>in which:</p><ul><li><code>q0</code> is the real part of the quaternion.</li><li><code>q1</code> is the X component of the quaternion vectorial part.</li><li><code>q2</code> is the Y component of the quaternion vectorial part.</li><li><code>q3</code> is the Z component of the quaternion vectorial part.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L11-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T}, Tuple{LinearAlgebra.UniformScaling, Quaternion{T}}} where T" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T}, Tuple{LinearAlgebra.UniformScaling, Quaternion{T}}} where T"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quaternion(::UniformScaling,::Quaternion{T}) where T</code></pre><p>Create an identity quaternion of type <code>T</code>:</p><pre><code class="language-none">T(1) + T(0).i + T(0).j + T(0).k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractVector{T} where T, Quaternion}" href="#Base.:*-Tuple{AbstractVector{T} where T, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(v::AbstractVector, q::Quaternion)
*(q::Quaternion, v::AbstractVector)</code></pre><p>Compute the multiplication <code>qv*q</code> or <code>q*qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L176-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{EulerAngles, EulerAngles}" href="#Base.:*-Tuple{EulerAngles, EulerAngles}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(Θ₂::EulerAngles, Θ₁::EulerAngles)</code></pre><p>Compute the composed rotation of <code>Θ₁ -&gt; Θ₂</code>. Notice that the rotation will be represented by Euler angles (see <code>EulerAngles</code>) with the same rotation sequence as <code>Θ₂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{LinearAlgebra.UniformScaling, Quaternion}" href="#Base.:*-Tuple{LinearAlgebra.UniformScaling, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(u::UniformScaling, q::Quaternion)
*(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu*q</code> or <code>q*qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L196-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Number, Quaternion}" href="#Base.:*-Tuple{Number, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(λ::Number, q::Quaternion)
*(q::Quaternion, λ::Number)</code></pre><p>Compute <code>λ*q</code> or <code>q*λ</code>, in which <code>λ</code> is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Quaternion, Quaternion}" href="#Base.:*-Tuple{Quaternion, Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute the quaternion multiplication <code>q1*q2</code> (Hamilton product).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}" href="#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(ea₂::EulerAngleAxis{T1}, ea₁::EulerAngleAxis{T2}) where {T1,T2}</code></pre><p>Compute the composed rotation of <code>ea₁ -&gt; ea₂</code>. Notice that the rotation will be represented by a Euler angle and axis (see <code>EulerAngleAxis</code>). By convention, the output angle will always be in the range [0, π] [rad].</p><p>Notice that the vector representing the axis in <code>ea₁</code> and <code>ea₂</code> must be unitary. This function neither verifies this nor normalizes the vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{LinearAlgebra.UniformScaling, Quaternion}" href="#Base.:+-Tuple{LinearAlgebra.UniformScaling, Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(u::UniformScaling, q::Quaternion)
+(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu + q</code> or <code>q + qu</code>, in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Quaternion, Quaternion}" href="#Base.:+-Tuple{Quaternion, Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa + qb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{LinearAlgebra.UniformScaling, Quaternion}" href="#Base.:--Tuple{LinearAlgebra.UniformScaling, Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(u::UniformScaling, q::Quaternion)
-(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu - q</code> or <code>q - qu</code>, in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Quaternion, Quaternion}" href="#Base.:--Tuple{Quaternion, Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa - qb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Quaternion}" href="#Base.:--Tuple{Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(q::Quaternion)</code></pre><p>Return the quaterion <code>-q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{LinearAlgebra.UniformScaling, Quaternion}" href="#Base.:/-Tuple{LinearAlgebra.UniformScaling, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">/(u::UniformScaling, q::Quaternion)
/(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu/q</code> or <code>q/qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L233-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Number, Quaternion}" href="#Base.:/-Tuple{Number, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">/(λ::Number, q::Quaternion)
/(q::Quaternion, λ::Number)</code></pre><p>Compute the division <code>λ/q</code> or <code>q/λ</code>, in which <code>λ</code> is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Quaternion, Quaternion}" href="#Base.:/-Tuple{Quaternion, Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">/(q1::Quaternion, q2::Quaternion) = q1*inv(q2)</code></pre><p>Compute <code>q1*inv(q2)</code> (Hamilton product).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{LinearAlgebra.UniformScaling, Quaternion}" href="#Base.:\\-Tuple{LinearAlgebra.UniformScaling, Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">\(u::UniformScaling, q::Quaternion)
\(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>inv(qu)*q</code> or <code>inv(q)*qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L266-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion, AbstractVector{T} where T}" href="#Base.:\\-Tuple{Quaternion, AbstractVector{T} where T}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">\(q::Quaternion, v::AbstractVector)
\(v::AbstractVector, q::Quaternion)</code></pre><p>Compute <code>inv(q)*qv</code> or <code>inv(qv)*q</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion, Quaternion}" href="#Base.:\\-Tuple{Quaternion, Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">\(q1::Quaternion, q2::Quaternion) = inv(q1)*q2</code></pre><p>Compute <code>inv(q1)*q2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Quaternion}" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conj(q::Quaternion)</code></pre><p>Compute the complex conjugate of the quaternion <code>q</code>:</p><pre><code class="language-none">q0 - q1.i - q2.j - q3.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L281-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy(q::Quaternion{T}) where T</code></pre><p>Create a copy of the quaternion <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L291-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.imag-Tuple{Quaternion}" href="#Base.imag-Tuple{Quaternion}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">imag(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L299-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{EulerAngles}" href="#Base.inv-Tuple{EulerAngles}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv(Θ::EulerAngles)</code></pre><p>Return the Euler angles that represent the inverse rotation of <code>Θ</code>. Notice that the rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, <code>:XYZ</code>, then the result will be represented using <code>:ZYX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Quaternion}" href="#Base.inv-Tuple{Quaternion}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv(q::Quaternion)</code></pre><p>Compute the inverse of the quaternion <code>q</code>:</p><pre><code class="language-none">conj(q)
-------
  |q|²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L308-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number" href="#Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv(ea::EulerAngleAxis)</code></pre><p>Compute the inverse rotation of <code>ea</code>. The Euler angle returned by this function will always be in the interval [0, π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{Quaternion}" href="#Base.real-Tuple{Quaternion}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">real(q::Quaternion)</code></pre><p>Return the real part of the quaternion <code>q</code>: <code>q0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L334-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, EulerAngleAxis{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO, EulerAngleAxis{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">display(ea::EulerAngleAxis{T}) where T
show(io::IO, mime::MIME&quot;text/plain&quot;, ea::EulerAngleAxis{T}) where T</code></pre><p>Display in <code>stdout</code> the Euler angle and axis <code>ea</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, EulerAngles{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO, EulerAngles{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, Θ::EulerAngles{T}) where T
show(io::IO, mime::MIME&quot;text/plain&quot;, Θ::EulerAngles{T}) where T</code></pre><p>Print the Euler angles <code>Θ</code> to the IO <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, Quaternion{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO, Quaternion{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, q::Quaternion{T}) where T
show(io::IO, mime::MIME&quot;text/plain&quot;, q::Quaternion{T}) where T</code></pre><p>Print the quaternion <code>q</code> to the stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L421-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zeros(q::Quaternion{T}) where T</code></pre><p>Create the null quaternion with the same type <code>T</code> of another quaternion <code>q</code>:</p><pre><code class="language-none">T(0) + T(0).i + T(0).j + T(0).k</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q1 = Quaternion{Float32}(cosd(45/2),sind(45/2),0,0);

julia&gt; zeros(q1)
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L378-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zeros(::Type{Quaternion{T}}) where T</code></pre><p>Create the null quaternion of type <code>T</code>:</p><pre><code class="language-none">T(0) + T(0).i + T(0).j + T(0).k</code></pre><p>If the type <code>T</code> is omitted, then it defaults to <code>Float64</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; zeros(Quaternion{Float32})
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k

julia&gt; zeros(Quaternion)
Quaternion{Float64}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L351-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Quaternion}" href="#LinearAlgebra.norm-Tuple{Quaternion}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(q::Quaternion)</code></pre><p>Compute the Euclidean norm of the quaternion <code>q</code>:</p><pre><code class="language-none">sqrt(q0² + q1² + q2² + q3²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L324-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}" href="#ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}"><code>ReferenceFrameRotations.angle_to_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)
angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq_orig</code> to a new set of Euler angles with rotation sequence <code>rot_seq_dest</code>. The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <code>EulerAngles</code>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_angle(-pi/2, -pi/3, -pi/4, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X):  -1.0472 rad ( -60.0000 deg)
  R(Y):   0.7854 rad (  45.0000 deg)
  R(Z):  -1.5708 rad ( -90.0000 deg)

julia&gt; angle_to_angle(-pi/2, 0, 0, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X):   0.0000 rad (   0.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(Z):  -1.5708 rad ( -90.0000 deg)

julia&gt; Θ = EulerAngles(1,2,3,:XYX)
EulerAngles{Int64}:
  R(X):   1.0000 rad (  57.2958 deg)
  R(Y):   2.0000 rad ( 114.5916 deg)
  R(X):   3.0000 rad ( 171.8873 deg)

julia&gt; angle_to_angle(Θ,:ZYZ)
EulerAngles{Float64}:
  R(Z):  -2.7024 rad (-154.8356 deg)
  R(Y):   1.4668 rad (  84.0393 deg)
  R(Z):  -1.0542 rad ( -60.3984 deg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L153-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_angleaxis" href="#ReferenceFrameRotations.angle_to_angleaxis"><code>ReferenceFrameRotations.angle_to_angleaxis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)
angle_to_angleaxis(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to an Euler angle and axis representation.  Those values can also be passed inside the structure <code>Θ</code> (see <code>EulerAngles</code>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_angleaxis(1,0,0,:XYZ)
EulerAngleAxis{Float64}:
  Euler angle:   1.0000 rad ( 57.2958 deg)
   Euler axis: [  1.0000,   0.0000,   0.0000]

julia&gt; Θ = EulerAngles(1,1,1,:XYZ);

julia&gt; angle_to_angleaxis(Θ)
EulerAngleAxis{Float64}:
  Euler angle:   1.9391 rad (111.1015 deg)
   Euler axis: [  0.6924,   0.2031,   0.6924]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L112-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm" href="#ReferenceFrameRotations.angle_to_dcm"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">angle_to_dcm(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a direction cosine matrix.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">dcm = angle_to_dcm(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L204-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_dcm-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle_to_dcm(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θ</code> (see <code>EulerAngles</code>) to a direction cosine matrix.</p><p><strong>Returns</strong></p><p>The direction cosine matrix.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_dcm(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L301-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_quat-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle_to_quat(eulerang::EulerAngles)</code></pre><p>Convert the Euler angles <code>eulerang</code> (see <code>EulerAngles</code>) to a quaternion.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L512-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}, Tuple{T1, T2, T3, Symbol}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}, Tuple{T1, T2, T3, Symbol}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle_to_quat(θ₁::T1, θ₂::T2, θ₃::T3, rot_seq::Symbol = :ZYX) where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a quaternion.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L365-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle_to_rot([T,] Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θ</code> (see <code>EulerAngles</code>) to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_rot(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle_to_rot(Quaternion,EulerAngles(pi/2, pi/3, pi/4, :ZYX))
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j +
  0.43045933457687935.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L603-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{Number, Number, Number, Symbol}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{Number, Number, Number, Symbol}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle_to_rot([T,] θx::Number, θy::Number, θz::Number, rot_seq::Symbol)</code></pre><p>Convert the Euler angles <code>Θx</code>, <code>Θy</code>, and <code>Θz</code> [rad] with the rotation sequence <code>rot_seq</code> to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_rot(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle_to_rot(Quaternion,pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L566-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector{T} where T, Symbol}" href="#ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector{T} where T, Symbol}"><code>ReferenceFrameRotations.angleaxis_to_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)
angleaxis_to_angle(ea::EulerAngleAxis, rot_seq::Symbol)</code></pre><p>Convert the Euler angle <code>θ</code> [rad]  and Euler axis <code>v</code>, which must be a unit vector, to Euler angles with rotation sequence <code>rot_seq</code>. Those values can also be passed inside the structure <code>ea</code> (see <code>EulerAngleAxis</code>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ea = EulerAngleAxis(45*pi/180, [1;0;0]);

julia&gt; angleaxis_to_angles(ea, :ZXY)
EulerAngles{Float64}:
  R(Z):   0.0000 rad (   0.0000 deg)
  R(X):   0.7854 rad (  45.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L123-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number, AbstractVector{T} where T}" href="#ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number, AbstractVector{T} where T}"><code>ReferenceFrameRotations.angleaxis_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angleaxis_to_dcm(a::Number, v::AbstractVector)
angleaxis_to_dcm(ea::EulerAngleAxis)</code></pre><p>Convert the Euler angle <code>a</code> [rad] and Euler axis <code>v</code>, which must be a unit vector to a DCM. Those values can also be passed inside the structure <code>ea</code> (see <code>EulerAngleAxis</code>).</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_dcm(pi/2,v)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333

julia&gt; ea = EulerAngleAxis(pi/2,v);

julia&gt; angleaxis_to_dcm(ea)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L160-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{EulerAngleAxis}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{EulerAngleAxis}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angleaxis_to_quat(angleaxis::EulerAngleAxis)</code></pre><p>Convert a Euler angle and Euler axis <code>angleaxis</code> (see <code>EulerAngleAxis</code>) to a quaternion.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>angleaxis.v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(EulerAngleAxis(pi/2,v))
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L247-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number, AbstractVector{T} where T}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number, AbstractVector{T} where T}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angleaxis_to_quat(θ::Number, v::AbstractVector)</code></pre><p>Convert the Euler angle <code>θ</code> [rad] and Euler axis <code>v</code>, which must be a unit vector, to a quaternion.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(pi/2,v)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angle_axis.jl#L210-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.compose_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compose_rotation(R1, [, R2, R3, R4, R5, ...])</code></pre><p>Compute a composed rotation using the rotations <code>R1</code>, <code>R2</code>, <code>R3</code>, <code>R4</code>, ..., in the following order:</p><pre><code class="language-none"> First rotation
 |
 |
R1 =&gt; R2 =&gt; R3 =&gt; R4 =&gt; ...
       |
       |
       Second rotation</code></pre><p>The rotations can be described by:</p><ul><li>A direction cosina matrix (<code>DCM</code>);</li><li>An Euler angle and axis (<code>EulerAngleAxis</code>);</li><li>A set of Euler anlges (<code>EulerAngles</code>); or</li><li>A quaternion (<code>Quaternion</code>).</li></ul><p>Notice, however, that all rotations <strong>must be</strong> of the same type (DCM or quaternion).</p><p>The output will have the same type as the inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D1 = angle_to_dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; D2 = angle_to_dcm(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(D1,D2)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0          0.0          5.55112e-17
 0.0          1.0          5.55112e-17
 5.55112e-17  5.55112e-17  1.0

julia&gt; ea1 = EulerAngleAxis(30*pi/180, [0;1;0]);

julia&gt; ea2 = EulerAngleAxis(45*pi/180, [0;1;0]);

julia&gt; compose_rotation(ea1,ea2)
EulerAngleAxis{Float64}:
  Euler angle:   1.3090 rad ( 75.0000 deg)
   Euler axis: [  0.0000,   1.0000,   0.0000]

julia&gt; Θ1 = EulerAngles(1,2,3,:ZYX);

julia&gt; Θ2 = EulerAngles(-3,-2,-1,:XYZ);

julia&gt; compose_rotation(Θ1, Θ2)
EulerAngles{Float64}:
  R(X):  -0.0000 rad (  -0.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(Z):  -0.0000 rad (  -0.0000 deg)

julia&gt; q1 = angle_to_quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; q2 = angle_to_quat(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(q1,q2)
Quaternion{Float64}:
  + 1.0 + 0.0.i + 2.0816681711721685e-17.j + 5.551115123125783e-17.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/compose_rotations.jl#L7-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.create_rotation_matrix" href="#ReferenceFrameRotations.create_rotation_matrix"><code>ReferenceFrameRotations.create_rotation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_rotation_matrix(angle::Number, axis::Symbol = :X)</code></pre><p>Compute a rotation matrix that rotates a coordinate frame about the axis <code>axis</code> by the angle <code>angle</code>. The <code>axis</code> must be one of the following symbols: <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</p><p><strong>Example</strong></p><pre><code class="language-jldocstest">julia&gt; create_rotation_matrix(pi/2, :X)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0          0.0
 0.0   6.12323e-17  1.0
 0.0  -1.0          6.12323e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/DCM.jl#L12-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angle-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, 9}, Symbol}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, 9}, Symbol}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX)</code></pre><p>Convert the DCM <code>dcm</code> to Euler Angles (see <code>EulerAngles</code>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Gimbal-lock and special cases</strong></p><p>If the rotations are about three different axes, <em>e.g.</em> <code>:XYZ</code>, <code>:ZYX</code>, etc., then a second rotation of <code>±90˚</code> yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation and the angle of the third rotation is set to 0.</p><p>If the rotations are about two different axes, <em>e.g.</em> <code>:XYX</code>, <code>:YXY</code>, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);

julia&gt; dcm_to_angle(D,:XYZ)
EulerAngles{Float64}:
  R(X):   1.5708 rad (  90.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(Z):   0.0000 rad (   0.0000 deg)

julia&gt; D = angle_to_dcm(1, -pi/2, 2, :ZYX);

julia&gt; dcm_to_angle(D,:ZYX)
EulerAngles{Float64}:
  R(Z):   3.0000 rad ( 171.8873 deg)
  R(Y):  -1.5708 rad ( -90.0000 deg)
  R(X):   0.0000 rad (   0.0000 deg)

julia&gt; D = create_rotation_matrix(1,:X)*create_rotation_matrix(2,:X);

julia&gt; dcm_to_angle(D,:XYX)
EulerAngles{Float64}:
  R(X):   3.0000 rad ( 171.8873 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(X):   0.0000 rad (   0.0000 deg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/DCM.jl#L130-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angleaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcm_to_angleaxis(dcm::DCM{T}) where T&lt;:Number</code></pre><p>Convert the DCM <code>dcm</code> to an Euler angle and axis representation. By convention, the returned Euler angle will always be in the interval [0, π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/DCM.jl#L369-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.dcm_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcm_to_quat(dcm::DCM)</code></pre><p>Convert the DCM <code>dcm</code> to a quaternion. The type of the quaternion will be automatically selected by the constructor <code>Quaternion</code> to avoid <code>InexactError</code>.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p>This algorithm was obtained from:</p><pre><code class="language-none">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_dcm(pi/2,0.0,0.0,:XYZ);

julia&gt; q   = dcm_to_quat(dcm)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.7071067811865475.i + 0.0.j + 0.0.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/DCM.jl#L423-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T, AbstractArray}" href="#ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T, AbstractArray}"><code>ReferenceFrameRotations.ddcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ddcm(Dba::DCM, wba_b::AbstractArray)</code></pre><p>Compute the time-derivative of the DCM <code>dcm</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Returns</strong></p><p>The time-derivative of the DCM <code>Dba</code> (3x3 matrix of type <code>SMatrix{3,3}</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM(Matrix{Float64}(I,3,3));

julia&gt; ddcm(D,[1;0;0])
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.0   0.0  0.0
 0.0   0.0  1.0
 0.0  -1.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/DCM.jl#L511-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector{T} where T}" href="#ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector{T} where T}"><code>ReferenceFrameRotations.dquat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dquat(qba::Quaternion, wba_b::AbstractVector)</code></pre><p>Compute the time-derivative of the quaternion <code>qba</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1.0I);

julia&gt; dquat(q,[1;0;0])
Quaternion{Float64}:
  + 0.0 + 0.5.i + 0.0.j + 0.0.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L603-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.inv_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv_rotation(R)</code></pre><p>Compute the inverse rotation of <code>R</code>, which can be:</p><ul><li>A direction cosina matrix (<code>DCM</code>);</li><li>An Euler angle and axis (<code>EulerAngleAxis</code>);</li><li>A set of Euler anlges (<code>EulerAngles</code>); or</li><li>A quaternion (<code>Quaternion</code>).</li></ul><p>The output will have the same type as <code>R</code> (DCM or quaternion).</p><p><strong>Remarks</strong></p><p>If <code>R</code> is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the user.</p><p>If <code>R</code> is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = angle_to_dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.353553  -0.492816  0.795068
  0.612372   0.764452  0.201527
 -0.707107   0.415627  0.572061

julia&gt; ea = EulerAngleAxis(30*pi/180, [1;0;0]);

julia&gt; inv_rotation(ea)
EulerAngleAxis{Float64}:
  Euler angle:   0.5236 rad ( 30.0000 deg)
   Euler axis: [ -1.0000,  -0.0000,  -0.0000]

julia&gt; Θ = EulerAngles(-pi/3, -pi/2, -pi, :YXZ);

julia&gt; inv_rotation(Θ)
EulerAngles{Float64}:
  R(Z):   3.1416 rad ( 180.0000 deg)
  R(X):   1.5708 rad (  90.0000 deg)
  R(Y):   1.0472 rad (  60.0000 deg)

julia&gt; q = angle_to_quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(q)
Quaternion{Float64}:
  + 0.8200711519756747 - 0.06526868310243991.i - 0.45794027732580056.j - 0.336918398289752.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/inv_rotations.jl#L7-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}" href="#ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}"><code>ReferenceFrameRotations.orthonormalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthonormalize(dcm::DCM)</code></pre><p>Perform the Gram-Schmidt orthonormalization process in the DCM <code>dcm</code> and return the new matrix.</p><p><strong>Warning</strong>: This function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have <code>NaN</code>. Notice, however, that such input matrix is not a valid direction cosine matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM(3I)

julia&gt; orthonormalize(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/DCM.jl#L50-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angle" href="#ReferenceFrameRotations.quat_to_angle"><code>ReferenceFrameRotations.quat_to_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the quaternion <code>q</code> to Euler Angles (see <code>EulerAngles</code>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angle(q,:XYZ)
EulerAngles{Float64}(0.7853981633974484, 0.0, -0.0, :XYZ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L567-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.quat_to_angleaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quat_to_angleaxis(q::Quaternion{T}) where T</code></pre><p>Convert the quaternion <code>q</code> to a Euler angle and axis representation (see <code>EulerAngleAxis</code>). By convention, the Euler angle will be kept between [0, π] rad.</p><p><strong>Remarks</strong></p><p>This function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angleaxis(q)
EulerAngleAxis{Float64}(0.7853981633974484, [1.0, 0.0, 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L517-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}" href="#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quat_to_dcm(q::Quaternion)</code></pre><p>Convert the quaternion <code>q</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_dcm(q)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L484-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number, Number, Number}" href="#ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)</code></pre><p>Create a direction cosine matrix from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively. If the keyword <code>normalize</code> is <code>true</code>, then the matrix will be normalized using the function <code>orthonormalize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01; normalize = false)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L328-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_quat-Tuple{Number, Number, Number}" href="#ReferenceFrameRotations.smallangle_to_quat-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_quat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smallangle_to_quat(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a quaternion from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p><strong>Remarks</strong></p><p>The quaternion is normalized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle_to_quat(+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L533-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}" href="#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}"><code>ReferenceFrameRotations.smallangle_to_rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number[; normalize = true])</code></pre><p>Create a rotation description of type <code>T</code> from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>The type <code>T</code> of the rotation description can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then if defaults to <code>DCM</code>.</p><p>If <code>T</code> is <code>DCM</code>, then the resulting matrix will be orthonormalized using the <code>orthonormalize</code> function if the keyword <code>normalize</code> is <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01; normalize = false)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0

julia&gt; q   = smallangle_to_rot(Quaternion,+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/euler_angles.jl#L634-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReferenceFrameRotations.vect-Tuple{Quaternion}" href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vect(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl/blob/327b49fb4c933d5119c2d1f9f2242726025033cc/src/quaternion.jl#L342-L348">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/inv_rotations/">« Inverting rotations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 March 2021 19:47">Friday 5 March 2021</span>. Using Julia version 1.6.0-rc1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
