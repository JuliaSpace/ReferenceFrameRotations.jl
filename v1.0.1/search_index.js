var documenterSearchIndex = {"docs":
[{"location":"man/euler_angles/#Euler-Angles","page":"Euler Angles","title":"Euler Angles","text":"","category":"section"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"The Euler Angles are defined by the following immutable structure:","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"struct EulerAngles{T}\n    a1::T\n    a2::T\n    a3::T\n    rot_seq::Symbol\nend","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"in which a1, a2, and a3 define the angles and the rot_seq is a symbol that defines the axes. The valid values for rot_seq are:","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":":XYX, :XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and ZYZ.","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"The constructor for this structure is:","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"function EulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1,T2,T3}","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"in which a EulerAngles with angles a1, a2, and a3 [rad] and rotation sequence rot_seq will be created. Notice that the type of the returned structure will be selected according to the input types T1, T2, and T3. If rot_seq is omitted, then it defaults to :ZYX.","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"julia> EulerAngles(1, 1, 1)\nEulerAngles{Int64}:\n  R(Z) :  1 rad  ( 57.2958°)\n  R(Y) :  1 rad  ( 57.2958°)\n  R(X) :  1 rad  ( 57.2958°)\n\njulia> EulerAngles(1, 1, 1.0f0, :XYZ)\nEulerAngles{Float32}:\n  R(X) :  1.0 rad  ( 57.2958°)\n  R(Y) :  1.0 rad  ( 57.2958°)\n  R(Z) :  1.0 rad  ( 57.2958°)\n\njulia> EulerAngles(1., 1, 1, :XYX)\nEulerAngles{Float64}:\n  R(X) :  1.0 rad  ( 57.2958°)\n  R(Y) :  1.0 rad  ( 57.2958°)\n  R(X) :  1.0 rad  ( 57.2958°)","category":"page"},{"location":"man/euler_angles/#Operations","page":"Euler Angles","title":"Operations","text":"","category":"section"},{"location":"man/euler_angles/#Multiplication","page":"Euler Angles","title":"Multiplication","text":"","category":"section"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"The multiplication of two Euler angles is defined here as the composition of the rotations. Let Theta_1 and Theta_2 be two sequences of Euler angles (instances of the structure EulerAngles). Thus, the operation:","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"Theta_21 = Theta_2 cdot Theta_1","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"will return a new set of Euler angles Theta_21 that represents the composed rotation of Theta_1 followed by Theta_2. Notice that Theta_21 will be represented using the same rotation sequence as Theta_2.","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"julia> a1 = EulerAngles(1, 0, 0, :ZYX);\n\njulia> a2 = EulerAngles(0, -1, 0, :YZY);\n\njulia> a2 * a1\nEulerAngles{Float64}:\n  R(Y) :  0.0 rad  ( 0.0°)\n  R(Z) :  0.0 rad  ( 0.0°)\n  R(Y) :  0.0 rad  ( 0.0°)\n\njulia> a1 = EulerAngles(1, 1, 1, :YZY);\n\njulia> a2 = EulerAngles(0, 0, -1, :YZY);\n\njulia> a2 * a1\nEulerAngles{Float64}:\n  R(Y) :  1.0         rad  ( 57.2958°)\n  R(Z) :  1.0         rad  ( 57.2958°)\n  R(Y) :  1.31938e-16 rad  ( 7.55951e-15°)\n\njulia> a1 = EulerAngles(1.3, 2.2, 1.4, :XYZ);\n\njulia> a2 = EulerAngles(-1.4, -2.2, -1.3, :ZYX);\n\njulia> a2 * a1\nEulerAngles{Float64}:\n  R(Z) : -8.32667e-17 rad  (-4.77083e-15°)\n  R(Y) :  3.33067e-16 rad  ( 1.90833e-14°)\n  R(X) : -1.11022e-16 rad  (-6.36111e-15°)","category":"page"},{"location":"man/euler_angles/#Inversion","page":"Euler Angles","title":"Inversion","text":"","category":"section"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"The inv function applied to Euler angles will return the inverse rotation. If the Euler angles Theta represent a rotation through the axes a_1, a_2, and a_3 by angles alpha_1, alpha_2, and alpha_3, then Theta^-1 is a rotation through the axes a_3, a_2, and a_1 by angles -alpha_3, -alpha_2, and -alpha_1.","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"julia> a = EulerAngles(1, 2, 3, :ZYX);\n\njulia> inv(a)\nEulerAngles{Int64}:\n  R(X) : -3 rad  (-171.887°)\n  R(Y) : -2 rad  (-114.592°)\n  R(Z) : -1 rad  (-57.2958°)\n\njulia> a = EulerAngles(1.2, 3.3, 4.6, :XYX);\n\njulia> a * inv(a)\nEulerAngles{Float64}:\n  R(X) : -1.92593e-34 rad  (-1.10348e-32°)\n  R(Y) :  0.0         rad  ( 0.0°)\n  R(X) :  0.0         rad  ( 0.0°)","category":"page"},{"location":"man/euler_angles/","page":"Euler Angles","title":"Euler Angles","text":"warning: Warning\nAll the operations related to Euler angles first convert them to DCM or Quaternions, and then the result is converted back to Euler angles. Hence, the performance will not be good.","category":"page"},{"location":"man/conversions/#Conversions","page":"Conversions","title":"Conversions","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using LinearAlgebra\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"There are several functions available to convert between the different types of 3D rotation representations.","category":"page"},{"location":"man/conversions/#DCMs-to-Euler-Angles","page":"Conversions","title":"DCMs to Euler Angles","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"A Direction Cosine Matrix (DCM) can be converted to Euler Angles using the following function:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function dcm_to_angle(dcm::DCM, rot_seq=:ZYX)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"note: Note\nGimbal-lock and special casesIf the rotations are about three different axes, e.g. :XYZ, :ZYX, etc., then a second rotation of pm 90^circ yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation and the angle of the third rotation is set to 0.If the rotations are about two different axes, e.g. :XYX, :YXY, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> dcm = DCM([1 0 0; 0 0 -1; 0 1 0]);\n\njulia> dcm_to_angle(dcm)\nEulerAngles{Float64}:\n  R(Z) :  0.0    rad  ( 0.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(X) : -1.5708 rad  (-90.0°)\n\njulia> dcm_to_angle(dcm, :XYZ)\nEulerAngles{Float64}:\n  R(X) : -1.5708 rad  (-90.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(Z) :  0.0    rad  ( 0.0°)\n\njulia> D = angle_to_dcm(1, -pi / 2, 2, :ZYX);\n\njulia> dcm_to_angle(D, :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  3.0    rad  ( 171.887°)\n  R(Y) : -1.5708 rad  (-90.0°)\n  R(X) :  0.0    rad  ( 0.0°)\n\njulia> D = create_rotation_matrix(1, :X) * create_rotation_matrix(2, :X);\n\njulia> dcm_to_angle(D, :XYX)\nEulerAngles{Float64}:\n  R(X) :  3.0 rad  ( 171.887°)\n  R(Y) :  0.0 rad  ( 0.0°)\n  R(X) :  0.0 rad  ( 0.0°)","category":"page"},{"location":"man/conversions/#DCMs-to-Euler-Angle-and-Axis","page":"Conversions","title":"DCMs to Euler Angle and Axis","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"A DCM can be converto to an Euler angle and axis representation using the following method:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function dcm_to_angleaxis(dcm::DCM)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> dcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0]);\n\njulia> ea  = dcm_to_angleaxis(dcm)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.5708 rad  (90.0°)\n  Euler axis  : [-1.0, 0.0, 0.0]","category":"page"},{"location":"man/conversions/#DCMs-to-Quaternions","page":"Conversions","title":"DCMs to Quaternions","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"A DCM can be converted to quaternion using the following method:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function dcm_to_quat(dcm::DCM)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> dcm = DCM([1.0 0.0 0.0; 0.0 0.0 -1.0; 0.0 1.0 0.0]);\n\njulia> q   = dcm_to_quat(dcm)\nQuaternion{Float64}:\n  + 0.707107 - 0.707107⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/conversions/#Euler-Angle-and-Axis-to-DCMs","page":"Conversions","title":"Euler Angle and Axis to DCMs","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"An Euler angle and axis representation can be converted to DCM using using these two methods:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angleaxis_to_dcm(a::Number, v::AbstractVector)\nfunction angleaxis_to_dcm(ea::EulerAngleAxis)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> a = 60.0 * pi / 180;\n\njulia> v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3)/3];\n\njulia> angleaxis_to_dcm(a, v)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.666667   0.666667  -0.333333\n -0.333333   0.666667   0.666667\n  0.666667  -0.333333   0.666667\n\njulia> angleaxis = EulerAngleAxis(a, v);\n\njulia> angleaxis_to_dcm(angleaxis)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.666667   0.666667  -0.333333\n -0.333333   0.666667   0.666667\n  0.666667  -0.333333   0.666667","category":"page"},{"location":"man/conversions/#Euler-Angle-and-Axis-to-Euler-Angles","page":"Conversions","title":"Euler Angle and Axis to Euler Angles","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"An Euler angle and axis representaion can be converto to Euler angles using these two methods:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)\nfunction angleaxis_to_angle(ea::EulerAngleAxis, rot_seq::Symbol)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> a = 19.86 * pi / 180;\n\njulia> v = [0, 1, 0];\n\njulia> angleaxis_to_angle(a, v, :XYX)\nEulerAngles{Float64}:\n  R(X) :  0.0      rad  ( 0.0°)\n  R(Y) :  0.346622 rad  ( 19.86°)\n  R(X) :  0.0      rad  ( 0.0°)\n\njulia> a = 60.0 * pi / 180;\n\njulia> v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3];\n\njulia> angleaxis = EulerAngleAxis(a, v)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0472 rad  (60.0°)\n  Euler axis  : [0.57735, 0.57735, 0.57735]\n\njulia> angleaxis_to_angle(angleaxis, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.463648 rad  ( 26.5651°)\n  R(Y) :  0.729728 rad  ( 41.8103°)\n  R(Z) :  0.463648 rad  ( 26.5651°)\n\njulia> angleaxis_to_angle(angleaxis, :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  0.785398 rad  ( 45.0°)\n  R(Y) :  0.339837 rad  ( 19.4712°)\n  R(X) :  0.785398 rad  ( 45.0°)","category":"page"},{"location":"man/conversions/#Euler-Angle-and-Axis-to-Quaternions","page":"Conversions","title":"Euler Angle and Axis to Quaternions","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"An Euler angle and axis representation can be converted to quaternion using these two methods:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angleaxis_to_quat(a::Number, v::AbstractVector)\nfunction angleaxis_to_quat(angleaxis::EulerAngleAxis)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> a = 60.0 * pi / 180;\n\njulia> v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3];\n\njulia> angleaxis_to_quat(a,v)\nQuaternion{Float64}:\n  + 0.866025 + 0.288675⋅i + 0.288675⋅j + 0.288675⋅k\n\njulia> angleaxis = EulerAngleAxis(a,v);\n\njulia> angleaxis_to_quat(angleaxis)\nQuaternion{Float64}:\n  + 0.866025 + 0.288675⋅i + 0.288675⋅j + 0.288675⋅k","category":"page"},{"location":"man/conversions/#Euler-Angles-to-Direction-Cosine-Matrices","page":"Conversions","title":"Euler Angles to Direction Cosine Matrices","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"Euler angles can be converted to DCMs using the following functions:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angle_to_dcm(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)\nfunction angle_to_dcm(Θ::EulerAngles)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> dcm = angle_to_dcm(pi / 2, pi / 4, pi / 3, :ZYX)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  4.32978e-17  0.707107  -0.707107\n -0.5          0.612372   0.612372\n  0.866025     0.353553   0.353553\n\njulia> angles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX);\n\njulia> dcm = angle_to_dcm(angles)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  4.32978e-17  0.707107  -0.707107\n -0.5          0.612372   0.612372\n  0.866025     0.353553   0.353553","category":"page"},{"location":"man/conversions/#Euler-Angles-to-Euler-Angles","page":"Conversions","title":"Euler Angles to Euler Angles","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"It is possible to change the rotation sequence of a set of Euler angles using the following functions:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)\nfunction angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"in which rot_seq_dest is the desired rotation sequence of the result.","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)\nEulerAngles{Float64}:\n  R(X) : -1.0472   rad  (-60.0°)\n  R(Y) :  0.785398 rad  ( 45.0°)\n  R(Z) : -1.5708   rad  (-90.0°)\n\njulia> angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.0    rad  ( 0.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(Z) : -1.5708 rad  (-90.0°)\n\njulia> Θ = EulerAngles(1, 2, 3, :XYX)\nEulerAngles{Int64}:\n  R(X) :  1 rad  ( 57.2958°)\n  R(Y) :  2 rad  ( 114.592°)\n  R(X) :  3 rad  ( 171.887°)\n\njulia> angle_to_angle(Θ, :ZYZ)\nEulerAngles{Float64}:\n  R(Z) : -2.70239 rad  (-154.836°)\n  R(Y) :  1.46676 rad  ( 84.0393°)\n  R(Z) : -1.05415 rad  (-60.3984°)","category":"page"},{"location":"man/conversions/#Euler-Angles-to-Quaternions","page":"Conversions","title":"Euler Angles to Quaternions","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"Euler angles can be converted to an Euler angle and axis using the following functions:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)\nfunction angle_to_angleaxis(Θ::EulerAngles)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> angle_to_angleaxis(1, 0, 0, :XYZ)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0 rad  (57.2958°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\njulia> Θ = EulerAngles(1, 1, 1, :XYZ);\n\njulia> angle_to_angleaxis(Θ)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.93909 rad  (111.102°)\n  Euler axis  : [0.692363, 0.203145, 0.692363]","category":"page"},{"location":"man/conversions/#Euler-Angles-to-Quaternions-2","page":"Conversions","title":"Euler Angles to Quaternions","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"Euler angles can be converted to quaternions using the following functions:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function angle_to_quat(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)\nfunction angle_to_quat(Θ::EulerAngles)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> q = angle_to_quat(pi / 2, pi / 4, pi / 3, :ZYX)\nQuaternion{Float64}:\n  + 0.701057 + 0.092296⋅i + 0.560986⋅j + 0.560986⋅k\n\njulia> angles = EulerAngles(pi / 2, pi / 4, pi / 3, :ZYX);\n\njulia> q = angle_to_quat(angles)\nQuaternion{Float64}:\n  + 0.701057 + 0.092296⋅i + 0.560986⋅j + 0.560986⋅k","category":"page"},{"location":"man/conversions/#Small-Euler-Angles-to-Direction-Cosine-Matrices","page":"Conversions","title":"Small Euler Angles to Direction Cosine Matrices","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"Small Euler angles can be converted to DCMs using the following function:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"in which the resulting matrix will be orthonormalized if the keyword normalize is true.","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> dcm = smallangle_to_dcm(0.001, -0.002, +0.003)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.999994     0.00299799   0.00200298\n -0.00299998   0.999995     0.000993989\n -0.00199999  -0.000999991  0.999998\n\njulia> dcm = smallangle_to_dcm(0.001, -0.002, +0.003; normalize = false)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0     0.003  0.002\n -0.003   1.0    0.001\n -0.002  -0.001  1.0","category":"page"},{"location":"man/conversions/#Small-Euler-Angles-to-Quaternions","page":"Conversions","title":"Small Euler Angles to Quaternions","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"Small Euler angles can be converted to quaternions using the following function:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function smallangle_to_quat(θx::Number, θy::Number, θz::Number)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> q = smallangle_to_quat(0.001, -0.002, +0.003)\nQuaternion{Float64}:\n  + 0.999998 + 0.000499999⋅i - 0.000999998⋅j - 0.000999998⋅k","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"note: Note\nThe computed quaternion is normalized.","category":"page"},{"location":"man/conversions/#Quaternions-to-Direction-Cosine-Matrices","page":"Conversions","title":"Quaternions to Direction Cosine Matrices","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"A quaternion can be converted to DCM using the following method:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function quat_to_dcm(q::Quaternion)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> q = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);\n\njulia> dcm = quat_to_dcm(q)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0   0.0       0.0\n 0.0   0.707107  0.707107\n 0.0  -0.707107  0.707107","category":"page"},{"location":"man/conversions/#Quaternions-to-Euler-Angle-and-Axis","page":"Conversions","title":"Quaternions to Euler Angle and Axis","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"A quaternion can be converted to Euler Angle and Axis representation using the following function:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function quat_to_angleaxis(q::Quaternion)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> v = [sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3];\n\njulia> a = 60.0 * pi / 180;\n\njulia> q = Quaternion(cos(a / 2), v * sin(a / 2));\n\njulia> quat_to_angleaxis(q)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0472 rad  (60.0°)\n  Euler axis  : [0.57735, 0.57735, 0.57735]","category":"page"},{"location":"man/conversions/#Quaternions-to-Euler-Angles","page":"Conversions","title":"Quaternions to Euler Angles","text":"","category":"section"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"There is one method to convert quaternions to Euler Angles:","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"function quat_to_angle(q::Quaternion, rot_seq=:ZYX)","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"However, it first transforms the quaternion to DCM using quat_to_dcm and then transforms the DCM into the Euler Angles. Hence, the performance will be poor. The improvement of this conversion will be addressed in a future version of ReferenceFrameRotations.jl.","category":"page"},{"location":"man/conversions/","page":"Conversions","title":"Conversions","text":"julia> q = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);\n\njulia> quat_to_angle(q, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.785398 rad  ( 45.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(Z) :  0.0      rad  ( 0.0°)","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for ReferenceFrameRotations.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [ReferenceFrameRotations]","category":"page"},{"location":"lib/library/#ReferenceFrameRotations.DCM","page":"Library","title":"ReferenceFrameRotations.DCM","text":"DCM{T}\n\nThe Direction Cosine Matrix (DCM) of type T is a SMatrix{3,3,T,9}, which is a 3x3 static matrix of type T.\n\nExamples\n\njulia> DCM(1.0I)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> DCM([1 0 0; 0 -1 0; 0 0 -1])\n3×3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):\n 1   0   0\n 0  -1   0\n 0   0  -1\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.EulerAngleAxis","page":"Library","title":"ReferenceFrameRotations.EulerAngleAxis","text":"EulerAngleAxis{T}\n\nThe definition of Euler Angle and Axis to represent a 3D rotation.\n\nFields\n\na::T: The Euler angle [rad].\nv::SVector{3, T}: The unitary vector aligned with the Euler axis.\n\nConstructor\n\nEulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}\n\nCreate an Euler Angle and Axis representation structure with angle a [rad] and vector v.\n\nThe vector v will not be normalized.\n\nThe returned structure type will be selected according to the input types.\n\nExamples\n\njulia> EulerAngleAxis(pi / 3, [sqrt(2), sqrt(2), 0])\nEulerAngleAxis{Float64}:\n  Euler angle:   1.0472 rad ( 60.0000 deg)\n   Euler axis: [  1.4142,   1.4142,   0.0000]\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.EulerAngles","page":"Library","title":"ReferenceFrameRotations.EulerAngles","text":"EulerAngles{T}\n\nThe definition of Euler Angles, which is composed of three angles a1, a2, and a3 together with a rotation sequence rot_seq.\n\nFields\n\na1::T: First rotation [rad].\na2::T: Second rotation [rad].\na3::T: Third rotation [rad].\nrot_seq::Symbol: Rotation sequence.\n\ninfo: Info\nrot_seq is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle, e.g. :ZYX. The valid values for rot_seq are::XYX, :XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY,   :ZXZ, :ZYX, and ZYZ.\n\nConstructor\n\nEulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1, T2, T3}\n\nCreate a new instance of EulerAngles with the angles a1, a2, and a3 and the rotation sequence rot_seq.\n\nThe type will be inferred from T1, T2, and T3.\n\nIf rot_seq is not provided, then it defaults to :ZYX.\n\nExamples\n\njulia> EulerAngles(pi / 2, pi / 4, -pi, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  1.5707963267948966 rad  ( 90.0°)\n  R(Y) :  0.7853981633974483 rad  ( 45.0°)\n  R(Z) : -3.141592653589793  rad  (-180.0°)\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.Quaternion","page":"Library","title":"ReferenceFrameRotations.Quaternion","text":"Quaternion{T} <: AbstractVector{T}\n\nThe definition of the quaternion.\n\nFields\n\nq0::T: Quaternion real part.\nq1::T: X component of the quaternion imaginary part.\nq2::T: Y component of the quaternion imaginary part.\nq3::T: Z component of the quaternion imaginary part.\n\nnote: Note\nThe quaternion q in this structure is represented by:q = q0 + q1.i + q2.j + q3.k\n\nExample\n\njulia> Quaternion(cosd(45), sind(45), 0, 0)\nQuaternion{Float64}:\n  + 0.7071067811865476 + 0.7071067811865476.i + 0.0.j + 0.0.k\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0, T1, T2, T3}} where {T0, T1, T2, T3}","page":"Library","title":"ReferenceFrameRotations.Quaternion","text":"Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0, T1, T2, T3}\n\nCreate the following quaternion:\n\nq0 + q1.i + q2.j + q3.k\n\nin which:\n\nq0 is the real part of the quaternion.\nq1 is the X component of the quaternion vectorial part.\nq2 is the Y component of the quaternion vectorial part.\nq3 is the Z component of the quaternion vectorial part.\n\nnote: Note\nThe quaternion type is obtained by promoting T0, T1, T2, and T3.\n\nExamples\n\njulia> Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> Quaternion(1, 0, 0, 0.0)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\nQuaternion(v::AbstractVector)\n\nIf the vector v has 3 components, then create a quaternion in which the real part is 0 and the vectorial or imaginary part has the same components of the vector v. In other words:\n\nq = 0 + v[1].i + v[2].j + v[3].k\n\nOtherwise, if the vector v has 4 components, then create a quaternion in which the elements match those of the input vector:\n\nq = v[1] + v[2].i + v[3].j + v[4].k\n\nnote: Note\nIf the length of v is not 3 or 4, then an error is thrown.\n\nExamples\n\njulia> Quaternion([0, cosd(45), sind(45)])\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k\n\njulia> Quaternion([cosd(45), 0, sind(45), 0])\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k\n\n\n\nQuaternion(r::Number, v::AbstractVector)\n\nCreate a quaternion with real part r and vectorial or imaginary part v:\n\nr + v[1].i + v[2].j + v[3].k\n\nnote: Note\nThe quaternion type is obtained by promoting the type of r and the elements of v.\n\nExamples\n\njulia> Quaternion(cosd(45), [0, sind(45), 0])\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k\n\n\n\nQuaternion(u::UniformScaling{T}) where T\nQuaternion{T}(u::UniformScaling) where T\nQuaternion(u::UniformScaling, Q::Quaternion{T}) where T\n\nCreate the quaternion u.λ + 0.i + 0.j + 0.k.\n\nIf a quaternion is passed as in the third signature, then the new quaternion will have the same type.\n\nExamples\n\njulia> Quaternion(I)\nQuaternion{Bool}:\n  + true + false⋅i + false⋅j + false⋅k\n\njulia> Quaternion(1.0I)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = Quaternion{Float32}(I)\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> Quaternion(I, q)\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{AbstractVector{T} where T, Quaternion}","page":"Library","title":"Base.:*","text":"*(v::AbstractVector, q::Quaternion)\n*(q::Quaternion, v::AbstractVector)\n\nCompute the multiplication qv * q or q * qv in which qv is a quaternion with real part 0 and vectorial/imaginary part v (Hamilton product).\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> v = [0, cosd(60), sind(60)]\n3-element Vector{Float64}:\n 0.0\n 0.5\n 0.8660254037844386\n\njulia> q * v\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.5⋅j + 0.5⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{EulerAngles, EulerAngles}","page":"Library","title":"Base.:*","text":"*(Θ₂::EulerAngles, Θ₁::EulerAngles)\n\nCompute the composed rotation of Θ₁ -> Θ₂.\n\nThe rotation will be represented by Euler angles (see EulerAngles) with the same rotation sequence as Θ₂.\n\nExamples\n\njulia> ea1 = EulerAngles(deg2rad(35), 0, 0, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.610865 rad  ( 35.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(Z) :  0.0      rad  ( 0.0°)\n\njulia> ea2 = EulerAngles(0, 0, deg2rad(25), :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  0.0      rad  ( 0.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(X) :  0.436332 rad  ( 25.0°)\n\njulia> ea2 * ea1\nEulerAngles{Float64}:\n  R(Z) :  0.0    rad  ( 0.0°)\n  R(Y) : -0.0    rad  (-0.0°)\n  R(X) :  1.0472 rad  ( 60.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{Number, Quaternion}","page":"Library","title":"Base.:*","text":"*(λ::Number, q::Quaternion)\n*(q::Quaternion, λ::Number)\n\nCompute λ * q or q * λ, in which λ is a scalar.\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> 2 * q\nQuaternion{Int64}:\n  + 2 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:*","text":"*(q1::Quaternion, q2::Quaternion)\n\nCompute the quaternion multiplication q1 * q2 (Hamilton product).\n\nIf one of the operands is a UniformScaling:\n\n*(u::UniformScaling, q::Quaternion)\n*(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(cosd(30), 0, sind(30), 0)\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k\n\njulia> q2 = Quaternion(cosd(60), 0, sind(60), 0)\nQuaternion{Float64}:\n  + 0.5 + 0.0⋅i + 0.866025⋅j + 0.866025⋅k\n\njulia> q1 * q2\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 1.0⋅j + 1.0⋅k\n\njulia> I * q1\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1}, EulerAngleAxis{T2}}} where {T1, T2}","page":"Library","title":"Base.:*","text":"*(av₂::EulerAngleAxis{T1}, av₁::EulerAngleAxis{T2}) where {T1,T2}\n\nCompute the composed rotation of av₁ -> av₂.\n\nThe rotation will be represented by a Euler angle and axis (see EulerAngleAxis). By convention, the output angle will always be in the range [0, π] rad.\n\nNotice that the vector representing the axis in av₁ and av₂ must be unitary. This function neither verifies this nor normalizes the vector.\n\nExamples\n\njulia> av1 = EulerAngleAxis(deg2rad(45), [sqrt(2)/2, sqrt(2)/2, 0])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.785398 rad  (45.0°)\n  Euler axis  : [0.707107, 0.707107, 0.0]\n\njulia> av2 = EulerAngleAxis(deg2rad(22.5), [sqrt(2)/2, sqrt(2)/2, 0])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.392699 rad  (22.5°)\n  Euler axis  : [0.707107, 0.707107, 0.0]\n\njulia> av1 * av2\nEulerAngleAxis{Float64}:\n  Euler angle : 1.1781 rad  (67.5°)\n  Euler axis  : [0.707107, 0.707107, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:+-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:+","text":"+(qa::Quaternion, qb::Quaternion)\n\nCompute qa + qb.\n\nIf one of the operands is a UniformScaling:\n\n+(u::UniformScaling, q::Quaternion)\n+(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> q2 = Quaternion(0, cosd(45), 0, sind(45))\nQuaternion{Float64}:\n  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q1 + q2\nQuaternion{Float64}:\n  + 1.0 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q1 + I\nQuaternion{Int64}:\n  + 2 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:--Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:-","text":"-(qa::Quaternion, qb::Quaternion)\n\nCompute qa - qb.\n\nIf one of the operands is a UniformScaling:\n\n-(u::UniformScaling, q::Quaternion)\n-(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> q2 = Quaternion(0, cosd(45), 0, sind(45))\nQuaternion{Float64}:\n  + 0.0 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q1 - q2\nQuaternion{Float64}:\n  + 1.0 - 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q1 - I\nQuaternion{Int64}:\n  + 0 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:--Tuple{Quaternion}","page":"Library","title":"Base.:-","text":"-(q::Quaternion)\n\nReturn the quaterion -q.\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> -q\nQuaternion{Int64}:\n  - 1 + 0⋅i + 0⋅j + 0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:/-Tuple{Number, Quaternion}","page":"Library","title":"Base.:/","text":"/(λ::Number, q::Quaternion)\n/(q::Quaternion, λ::Number)\n\nCompute the division λ / q or q / λ, in which λ is a scalar.\n\nExamples\n\njulia> q = Quaternion(2, 0, 0, 0)\nQuaternion{Int64}:\n  + 2 + 0⋅i + 0⋅j + 0⋅k\n\njulia> q / 2\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:/-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:/","text":"/(q1::Quaternion, q2::Quaternion)\n\nCompute q1 * inv(q2) (Hamilton product).\n\nIf one of the operands is a UniformScaling:\n\n/(u::UniformScaling, q::Quaternion)\n/(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k\n\njulia> q2 = Quaternion(cosd(30), 0, sind(30), 0)\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k\n\njulia> q1 / q2\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k\n\njulia> q1 / (2 * I)\nQuaternion{Float64}:\n  + 0.12941 + 0.0⋅i + 0.482963⋅j + 0.482963⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:\\-Tuple{Quaternion, AbstractVector{T} where T}","page":"Library","title":"Base.:\\","text":"\\(v::AbstractVector, q::Quaternion)\n\\(q::Quaternion, v::AbstractVector)\n\nCompute the division qv \\ q or q \\ qv in which qv is a quaternion with real part 0 and vectorial/imaginary part v (Hamilton product).\n\nExamples\n\njulia> q = Quaternion(1, 0, 0, 0)\nQuaternion{Int64}:\n  + 1 + 0⋅i + 0⋅j + 0⋅k\n\njulia> v = [0, cosd(60), sind(60)]\n3-element Vector{Float64}:\n 0.0\n 0.5\n 0.8660254037844386\n\njulia> v \\ q\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i - 0.5⋅j - 0.5⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.:\\-Tuple{Quaternion, Quaternion}","page":"Library","title":"Base.:\\","text":"\\(q1::Quaternion, q2::Quaternion)\n\nCompute inv(q1) * q2.\n\nIf one of the operands is a UniformScaling:\n\n\\(u::UniformScaling, q::Quaternion)\n\\(q::Quaternion, u::UniformScaling)\n\nthen it is considered as the quaternion u.λ + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nExamples\n\njulia> q1 = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k\n\njulia> q2 = Quaternion(cosd(30), 0, sind(30), 0)\nQuaternion{Float64}:\n  + 0.866025 + 0.0⋅i + 0.5⋅j + 0.5⋅k\n\njulia> q2 \\ q1\nQuaternion{Float64}:\n  + 0.707107 + 0.0⋅i + 0.707107⋅j + 0.707107⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.conj-Tuple{Quaternion}","page":"Library","title":"Base.conj","text":"conj(q::Quaternion)\n\nCompute the complex conjugate of the quaternion q:\n\nq0 - q1.i - q2.j - q3.k\n\nSee also: inv\n\nExamples\n\njulia> q = Quaternion(1, cosd(75), 0, sind(75))\nQuaternion{Float64}:\n  + 1.0 + 0.258819⋅i + 0.0⋅j + 0.0⋅k\n\njulia> conj(q)\nQuaternion{Float64}:\n  + 1.0 - 0.258819⋅i - 0.0⋅j - 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Library","title":"Base.copy","text":"copy(q::Quaternion{T}) where T\n\nCreate a copy of the quaternion q.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.imag-Tuple{Quaternion}","page":"Library","title":"Base.imag","text":"imag(q::Quaternion)\n\nReturn the vectorial or imaginary part of the quaternion q represented by a 3 × 1 vector of type SVector{3}.\n\nSee also: real, vect\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k\n\njulia> imag(q)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.9659258262890683\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Tuple{EulerAngles}","page":"Library","title":"Base.inv","text":"inv(Θ::EulerAngles)\n\nReturn the Euler angles that represent the inverse rotation of Θ.\n\nThe rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, :XYZ, then the result will be represented using :ZYX.\n\nExamples\n\njulia> ea = EulerAngles(π / 3, π / 6,  2 / 3 * π, :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  1.0472   rad  ( 60.0°)\n  R(Y) :  0.523599 rad  ( 30.0°)\n  R(X) :  2.0944   rad  ( 120.0°)\n\njulia> inv(ea)\nEulerAngles{Float64}:\n  R(X) : -2.0944   rad  (-120.0°)\n  R(Y) : -0.523599 rad  (-30.0°)\n  R(Z) : -1.0472   rad  (-60.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Tuple{Quaternion}","page":"Library","title":"Base.inv","text":"inv(q::Quaternion)\n\nCompute the inverse of the quaternion q:\n\nconj(q)\n-------\n  |q|²\n\nSee also: conj\n\nExamples\n\njulia> q = Quaternion(1, 0, cosd(75), sind(75))\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.258819⋅j + 0.258819⋅k\n\njulia> inv(q)\nQuaternion{Float64}:\n  + 0.5 - 0.0⋅i - 0.12941⋅j - 0.12941⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T<:Number","page":"Library","title":"Base.inv","text":"inv(av::EulerAngleAxis)\n\nCompute the inverse rotation of the Euler angle and axis av.\n\nThe Euler angle returned by this function will always be in the interval [0, π] rad.\n\nExamples\n\njulia> av = EulerAngleAxis(deg2rad(20), [sqrt(2) / 2, 0, sqrt(2) / 2])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.349066 rad  (20.0°)\n  Euler axis  : [0.707107, 0.0, 0.707107]\n\njulia> inv(av)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.349066 rad  (20.0°)\n  Euler axis  : [-0.707107, -0.0, -0.707107]\n\njulia> av = EulerAngleAxis(deg2rad(-20), [sqrt(2) / 2, 0, sqrt(2) / 2])\nEulerAngleAxis{Float64}:\n  Euler angle : -0.349066 rad  (-20.0°)\n  Euler axis  : [0.707107, 0.0, 0.707107]\n\njulia> inv(av)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.349066 rad  (20.0°)\n  Euler axis  : [0.707107, 0.0, 0.707107]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.real-Tuple{Quaternion}","page":"Library","title":"Base.real","text":"real(q::Quaternion)\n\nReturn the real part of the quaternion q: q0.\n\nSee also: imag, vect\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k\n\njulia> real(q)\n0.25881904510252074\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T","page":"Library","title":"Base.zeros","text":"zeros(::Type{Quaternion{T}}) where T\n\nCreate the null quaternion: 0 + 0 ⋅ i + 0 ⋅ j + 0 ⋅ k.\n\nThe type of the new quaternion will be T. If the type T is omitted, then it defaults to Float64.\n\nExample\n\njulia> zeros(Quaternion{Float32})\nQuaternion{Float32}:\n  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> zeros(Quaternion)\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\nzeros(q::Quaternion{T}) where T\n\nCreate the null quaternion with the same type T of another quaternion q.\n\nExamples\n\njulia> q = Quaternion{Float32}(1, 0, 0, 0)\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> zeros(q)\nQuaternion{Float32}:\n  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#LinearAlgebra.norm-Tuple{Quaternion}","page":"Library","title":"LinearAlgebra.norm","text":"norm(q::Quaternion)\n\nCompute the Euclidean norm of the quaternion q:\n\n√(q0² + q1² + q2² + q3²)\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k\n\njulia> norm(q)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_angle-Tuple{Number, Number, Number, Symbol, Symbol}","page":"Library","title":"ReferenceFrameRotations.angle_to_angle","text":"angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)\nangle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)\n\nConvert the Euler angles θ₁, θ₂, and θ₃ [rad] with the rotation sequence rot_seq_orig to a new set of Euler angles with rotation sequence rot_seq_dest.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ.\n\nExample\n\njulia> angle_to_angle(-pi / 2, -pi / 3, -pi / 4, :ZYX, :XYZ)\nEulerAngles{Float64}:\n  R(X) : -1.0472   rad  (-60.0°)\n  R(Y) :  0.785398 rad  ( 45.0°)\n  R(Z) : -1.5708   rad  (-90.0°)\n\njulia> angle_to_angle(-pi / 2, 0, 0, :ZYX, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.0    rad  ( 0.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(Z) : -1.5708 rad  (-90.0°)\n\njulia> Θ = EulerAngles(1, 2, 3, :XYX)\nEulerAngles{Int64}:\n  R(X) :  1 rad  ( 57.2958°)\n  R(Y) :  2 rad  ( 114.592°)\n  R(X) :  3 rad  ( 171.887°)\n\njulia> angle_to_angle(Θ, :ZYZ)\nEulerAngles{Float64}:\n  R(Z) : -2.70239 rad  (-154.836°)\n  R(Y) :  1.46676 rad  ( 84.0393°)\n  R(Z) : -1.05415 rad  (-60.3984°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_angleaxis","page":"Library","title":"ReferenceFrameRotations.angle_to_angleaxis","text":"angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)\nangle_to_angleaxis(Θ::EulerAngles)\n\nConvert the Euler angles θ₁, θ₂, and θ₃ [rad] with the rotation sequence rot_seq to an Euler angle and axis representation.\n\nThose values can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nExample\n\njulia> angle_to_angleaxis(1, 0, 0, :XYZ)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0 rad  (57.2958°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\njulia> Θ = EulerAngles(1, 1, 1, :XYZ);\n\njulia> angle_to_angleaxis(Θ)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.93909 rad  (111.102°)\n  Euler axis  : [0.692363, 0.203145, 0.692363]\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_dcm","page":"Library","title":"ReferenceFrameRotations.angle_to_dcm","text":"angle_to_dcm(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)\nangle_to_dcm(Θ::EulerAngles)\n\nConvert the Euler angles θ₁, θ₂, and θ₃ [rad] with the rotation sequence rot_seq to a direction cosine matrix.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nRemarks\n\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3].\n\nExample\n\njulia> dcm = angle_to_dcm(pi / 2, pi / 3, pi / 4, :ZYX)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  3.06162e-17  0.5       -0.866025\n -0.707107     0.612372   0.353553\n  0.707107     0.612372   0.353553\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}, Tuple{T1, T2, T3, Symbol}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"ReferenceFrameRotations.angle_to_quat","text":"angle_to_quat(θ₁::T1, θ₂::T2, θ₃::T3, rot_seq::Symbol = :ZYX) where {T1<:Number, T2<:Number, T3<:Number}\nangle_to_quat(eulerang::EulerAngles)\n\nConvert the Euler angles θ₁, θ₂, and θ₃ [rad] with the rotation sequence rot_seq to a quaternion.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nnote: Note\nThe type of the new quaternion will be obtained by promiting T1, T2, and T3.\n\nRemarks\n\nThis function assigns q = q1 * q2 * q3 in which qi is the quaternion related with the i-th rotation, i Є [1,2,3].\n\nExample\n\njulia> angle_to_quat(pi / 2, pi / 3, pi / 4, :ZYX)\nQuaternion{Float64}:\n  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.560986⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angle_to_rot-Tuple{Number, Number, Number, Symbol}","page":"Library","title":"ReferenceFrameRotations.angle_to_rot","text":"angle_to_rot([T,] θx::Number, θy::Number, θz::Number, rot_seq::Symbol)\nangle_to_rot([T,] Θ::EulerAngles)\n\nConvert the Euler angles Θx, Θy, and Θz [rad] with the rotation sequence rot_seq to a rotation description of type T, which can be DCM or Quaternion.\n\nThe input values of the origin Euler angles can also be passed inside the structure Θ (see EulerAngles).\n\nIf the type T is not specified, then it defaults to DCM.\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nExample\n\njulia> dcm = angle_to_rot(pi / 2, pi / 3, pi / 4, :ZYX)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  3.06162e-17  0.5       -0.866025\n -0.707107     0.612372   0.353553\n  0.707107     0.612372   0.353553\n\njulia> q = angle_to_rot(Quaternion, pi / 2, pi / 3, pi / 4, :ZYX)\nQuaternion{Float64}:\n  + 0.701057 - 0.092296⋅i + 0.560986⋅j + 0.560986⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number, AbstractVector{T} where T, Symbol}","page":"Library","title":"ReferenceFrameRotations.angleaxis_to_angle","text":"angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)\nangleaxis_to_angle(av::EulerAngleAxis, rot_seq::Symbol)\n\nConvert the Euler angle θ [rad]  and Euler axis v to Euler angles with rotation sequence rot_seq.\n\nThose values can also be passed inside the structure av (see EulerAngleAxis).\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nwarning: Warning\nIt is expected that the vector v is unitary. However, no verification is performed inside the function. The user must handle this situation.\n\nExample\n\njulia> av = EulerAngleAxis(deg2rad(45), [1, 0, 0]);\n\njulia> angleaxis_to_angle(av, :ZXY)\nEulerAngles{Float64}:\n  R(Z) :  0.0      rad  ( 0.0°)\n  R(X) :  0.785398 rad  ( 45.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number, AbstractVector{T} where T}","page":"Library","title":"ReferenceFrameRotations.angleaxis_to_dcm","text":"angleaxis_to_dcm(a::Number, v::AbstractVector)\nangleaxis_to_dcm(av::EulerAngleAxis)\n\nConvert the Euler angle a [rad] and Euler axis v to a DCM.\n\nThose values can also be passed inside the structure ea (see EulerAngleAxis).\n\nwarning: Warning\nIt is expected that the vector v is unitary. However, no verification is performed inside the function. The user must handle this situation.\n\nExample\n\njulia> v = [1, 1, 1];\n\njulia> v /= norm(v);\n\njulia> angleaxis_to_dcm(pi / 2, v)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.333333   0.910684  -0.244017\n -0.244017   0.333333   0.910684\n  0.910684  -0.244017   0.333333\n\njulia> ea = EulerAngleAxis(pi / 2, v);\n\njulia> angleaxis_to_dcm(ea)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.333333   0.910684  -0.244017\n -0.244017   0.333333   0.910684\n  0.910684  -0.244017   0.333333\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number, AbstractVector{T} where T}","page":"Library","title":"ReferenceFrameRotations.angleaxis_to_quat","text":"angleaxis_to_quat(θ::Number, v::AbstractVector)\nangleaxis_to_quat(angleaxis::EulerAngleAxis)\n\nConvert the Euler angle θ [rad] and Euler axis v to a quaternion.\n\nThose values can also be passed inside the structure ea (see EulerAngleAxis).\n\nwarning: Warning\nIt is expected that the vector v is unitary. However, no verification is performed inside the function. The user must handle this situation.\n\nExample\n\njulia> v = [1, 1, 1];\n\njulia> v /= norm(v);\n\njulia> angleaxis_to_quat(pi/2,v)\nQuaternion{Float64}:\n  + 0.707107 + 0.408248⋅i + 0.408248⋅j + 0.408248⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}","page":"Library","title":"ReferenceFrameRotations.compose_rotation","text":"compose_rotation(R1, [, R2, R3, R4, R5, ...])\n\nCompute a composed rotation using the rotations R1, R2, R3, R4, ..., in the following order:\n\n First rotation\n |\n |\nR1 => R2 => R3 => R4 => ...\n       |\n       |\n       Second rotation\n\nThe rotations can be described by:\n\nA direction cosine matrix (DCM);\nAn Euler angle and axis (EulerAngleAxis);\nA set of Euler angles (EulerAngles); or\nA quaternion (Quaternion).\n\nNotice, however, that all rotations must be of the same type (DCM or quaternion).\n\nThe output will have the same type as the inputs.\n\nExample\n\njulia> D1 = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> D2 = angle_to_dcm(-pi / 5, -pi / 4, -pi / 3, :XYZ);\n\njulia> compose_rotation(D1, D2)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0          1.08801e-17  3.54837e-17\n 1.08801e-17  1.0          2.88714e-17\n 3.54837e-17  2.88714e-17  1.0\n\njulia> ea1 = EulerAngleAxis(30 * pi / 180, [0, 1, 0]);\n\njulia> ea2 = EulerAngleAxis(45 * pi / 180, [0, 1, 0]);\n\njulia> compose_rotation(ea1, ea2)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.309 rad  (75.0°)\n  Euler axis  : [0.0, 1.0, 0.0]\n\njulia> Θ1 = EulerAngles(1, 2, 3, :ZYX);\n\njulia> Θ2 = EulerAngles(-3, -2, -1, :XYZ);\n\njulia> compose_rotation(Θ1, Θ2)\nEulerAngles{Float64}:\n  R(X) : -1.66533e-16 rad  (-9.54166e-15°)\n  R(Y) :  9.24446e-33 rad  ( 5.29669e-31°)\n  R(Z) : -1.11022e-16 rad  (-6.36111e-15°)\n\njulia> q1 = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> q2 = angle_to_quat(-pi / 5, -pi / 4, -pi / 3, :XYZ);\n\njulia> compose_rotation(q1, q2)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 2.08167e-17⋅j + 2.08167e-17⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.create_rotation_matrix","page":"Library","title":"ReferenceFrameRotations.create_rotation_matrix","text":"create_rotation_matrix(angle::Number, axis::Symbol = :X)\n\nCompute a rotation matrix that rotates a coordinate frame about the axis by the angle.\n\nThe axis must be one of the following symbols: :X, :Y, or :Z.\n\nExample\n\njulia> create_rotation_matrix(pi/2, :X)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 1.0   0.0          0.0\n 0.0   6.12323e-17  1.0\n 0.0  -1.0          6.12323e-17\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}, Tuple{StaticArrays.SMatrix{3, 3, T, 9}, Symbol}} where T<:Number","page":"Library","title":"ReferenceFrameRotations.dcm_to_angle","text":"dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX)\n\nConvert the dcm to Euler Angles (see EulerAngles) given a rotation sequence rot_seq.\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nGimbal-lock and special cases\n\nIf the rotations are about three different axes, e.g. :XYZ, :ZYX, etc., then a second rotation of ±90˚ yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation, and the angle of the third rotation is set to 0.\n\nIf the rotations are about two different axes, e.g. :XYX, :YXY, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.\n\nExample\n\njulia> D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);\n\njulia> dcm_to_angle(D,:XYZ)\nEulerAngles{Float64}:\n  R(X) :  1.5708 rad  ( 90.0°)\n  R(Y) :  0.0    rad  ( 0.0°)\n  R(Z) :  0.0    rad  ( 0.0°)\n\njulia> D = angle_to_dcm(1, -pi / 2, 2, :ZYX);\n\njulia> dcm_to_angle(D, :ZYX)\nEulerAngles{Float64}:\n  R(Z) :  3.0    rad  ( 171.887°)\n  R(Y) : -1.5708 rad  (-90.0°)\n  R(X) :  0.0    rad  ( 0.0°)\n\njulia> D = create_rotation_matrix(1, :X) * create_rotation_matrix(2, :X);\n\njulia> dcm_to_angle(D, :XYX)\nEulerAngles{Float64}:\n  R(X) :  3.0 rad  ( 171.887°)\n  R(Y) :  0.0 rad  ( 0.0°)\n  R(X) :  0.0 rad  ( 0.0°)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{StaticArrays.SMatrix{3, 3, T, 9}}, Tuple{T}} where T<:Number","page":"Library","title":"ReferenceFrameRotations.dcm_to_angleaxis","text":"dcm_to_angleaxis(dcm::DCM{T}) where T<:Number\n\nConvert the dcm to an Euler angle and axis representation.\n\nBy convention, the returned Euler angle will always be in the interval [0, π].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}","page":"Library","title":"ReferenceFrameRotations.dcm_to_quat","text":"dcm_to_quat(dcm::DCM)\n\nConvert the dcm to a quaternion.\n\nThe type of the quaternion will be automatically selected by the constructor Quaternion to avoid InexactError.\n\nRemarks\n\nBy convention, the real part of the quaternion will always be positive. Moreover, the function does not check if dcm is a valid direction cosine matrix. This must be handle by the user.\n\nThis algorithm was obtained from [1].\n\nExample\n\njulia> dcm = angle_to_dcm(pi / 2, 0.0, 0.0, :XYZ);\n\njulia> q = dcm_to_quat(dcm)\nQuaternion{Float64}:\n  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\nReferences\n\n[1]: http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T, AbstractArray}","page":"Library","title":"ReferenceFrameRotations.ddcm","text":"ddcm(Dba::DCM, wba_b::AbstractArray)\n\nCompute the time-derivative of the dcm that rotates a reference frame a into alignment with the reference frame b in which the angular velocity of b with respect to a, and represented in b, is wba_b.\n\nExample\n\njulia> D = DCM(1.0I);\n\njulia> ddcm(D, [1, 0, 0])\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 0.0   0.0  0.0\n 0.0   0.0  1.0\n 0.0  -1.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.dquat-Tuple{Quaternion, AbstractVector{T} where T}","page":"Library","title":"ReferenceFrameRotations.dquat","text":"dquat(qba::Quaternion, wba_b::AbstractVector)\n\nCompute the time-derivative of the quaternion qba that rotates a reference frame a into alignment to the reference frame b in which the angular velocity of b with respect to a, and represented in b, is wba_b.\n\nExamples\n\njulia> q = Quaternion(1.0I);\n\njulia> dquat(q,[1;0;0])\nQuaternion{Float64}:\n  - 0.0 + 0.5⋅i + 0.0⋅j + 0.0⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}","page":"Library","title":"ReferenceFrameRotations.inv_rotation","text":"inv_rotation(R)\n\nCompute the inverse rotation of R, which can be:\n\nA direction cosina matrix (DCM);\nAn Euler angle and axis (EulerAngleAxis);\nA set of Euler anlges (EulerAngles); or\nA quaternion (Quaternion).\n\nThe output will have the same type as R.\n\nnote: Note\nIf R is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the user.\n\nnote: Note\nIf R is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the used.\n\nExample\n\njulia> D = angle_to_dcm(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> inv_rotation(D)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.353553  -0.492816  0.795068\n  0.612372   0.764452  0.201527\n -0.707107   0.415627  0.572061\n\njulia> ea = EulerAngleAxis(30 * pi / 180, [1, 0, 0]);\n\njulia> inv_rotation(ea)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.523599 rad  (30.0°)\n  Euler axis  : [-1.0, -0.0, -0.0]\n\njulia> Θ = EulerAngles(-pi / 3, -pi / 2, -pi, :YXZ);\n\njulia> inv_rotation(Θ)\nEulerAngles{Float64}:\n  R(Z) :  3.14159 rad  ( 180.0°)\n  R(X) :  1.5708  rad  ( 90.0°)\n  R(Y) :  1.0472  rad  ( 60.0°)\n\njulia> q = angle_to_quat(pi / 3, pi / 4, pi / 5, :ZYX);\n\njulia> inv_rotation(q)\nQuaternion{Float64}:\n  + 0.820071 - 0.0652687⋅i - 0.45794⋅j - 0.45794⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SMatrix{3, 3, T, 9} where T}","page":"Library","title":"ReferenceFrameRotations.orthonormalize","text":"orthonormalize(dcm::DCM)\n\nPerform the Gram-Schmidt orthonormalization process in the dcm and return the new matrix.\n\nwarning: Warning\nThis function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have NaN. Notice, however, that such input matrix is not a valid direction cosine matrix.\n\nExample\n\njulia> D = DCM(3I)\n\njulia> orthonormalize(D)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_angle","page":"Library","title":"ReferenceFrameRotations.quat_to_angle","text":"quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX)\n\nConvert the quaternion q to Euler Angles (see EulerAngles) given a rotation sequence rot_seq.\n\nThe rotation sequence is defined by a :Symbol. The possible values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, and :ZYZ. If no value is specified, then it defaults to :ZYX.\n\nExamples\n\njulia> q = Quaternion(cosd(45/2), sind(45/2), 0, 0);\n\njulia> quat_to_angle(q, :XYZ)\nEulerAngles{Float64}:\n  R(X) :  0.785398 rad  ( 45.0°)\n  R(Y) :  0.0      rad  ( 0.0°)\n  R(Z) :  0.0      rad  ( 0.0°)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Library","title":"ReferenceFrameRotations.quat_to_angleaxis","text":"quat_to_angleaxis(q::Quaternion{T}) where T\n\nConvert the quaternion q to a Euler angle and axis representation (see EulerAngleAxis). By convention, the Euler angle will be kept between [0, π] rad.\n\nRemarks\n\nThis function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.\n\nExamples\n\njulia> q = Quaternion(cosd(45/2), sind(45/2), 0, 0);\n\njulia> quat_to_angleaxis(q)\nEulerAngleAxis{Float64}:\n  Euler angle : 0.785398 rad  (45.0°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}","page":"Library","title":"ReferenceFrameRotations.quat_to_dcm","text":"quat_to_dcm(q::Quaternion)\n\nConvert the quaternion q to a Direction Cosine Matrix (DCM).\n\nExamples\n\njulia> q = Quaternion(cosd(45/2), sind(45/2), 0, 0);\n\njulia> quat_to_dcm(q)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0   0.0       0.0\n 0.0   0.707107  0.707107\n 0.0  -0.707107  0.707107\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number, Number, Number}","page":"Library","title":"ReferenceFrameRotations.smallangle_to_dcm","text":"smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)\n\nCreate a direction cosine matrix from three small rotations of angles θx, θy, and θz [rad] about the axes X, Y, and Z, respectively.\n\nIf the keyword normalize is true, then the matrix will be normalized using the function orthonormalize.\n\nExample\n\njulia> smallangle_to_dcm(+0.01, -0.01, +0.01)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.9999     0.00989903  0.010098\n -0.009999   0.999901    0.00989802\n -0.009999  -0.009998    0.9999\n\njulia> smallangle_to_dcm(+0.01, -0.01, +0.01; normalize = false)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0    0.01  0.01\n -0.01   1.0   0.01\n -0.01  -0.01  1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.smallangle_to_quat-Tuple{Number, Number, Number}","page":"Library","title":"ReferenceFrameRotations.smallangle_to_quat","text":"smallangle_to_quat(θx::Number, θy::Number, θz::Number)\n\nCreate a quaternion from three small rotations of angles θx, θy, and θz [rad] about the axes X, Y, and Z, respectively.\n\nnote: Note\nThe quaternion is always normalized.\n\nExample\n\njulia> smallangle_to_quat(+0.01, -0.01, +0.01)\nQuaternion{Float64}:\n  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j - 0.00499981⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number, Number, Number}","page":"Library","title":"ReferenceFrameRotations.smallangle_to_rot","text":"smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number[; normalize = true])\n\nCreate a rotation description of type T from three small rotations of angles θx, θy, and θz [rad] about the axes X, Y, and Z, respectively.\n\nThe type T of the rotation description can be DCM or Quaternion. If the type T is not specified, then if defaults to DCM.\n\nIf T is DCM, then the resulting matrix will be orthonormalized using the orthonormalize function if the keyword normalize is true.\n\nExample\n\njulia> dcm = smallangle_to_rot(+0.01, -0.01, +0.01)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.9999     0.00989903  0.010098\n -0.009999   0.999901    0.00989802\n -0.009999  -0.009998    0.9999\n\njulia> dcm = smallangle_to_rot(+0.01, -0.01, +0.01; normalize = false)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0    0.01  0.01\n -0.01   1.0   0.01\n -0.01  -0.01  1.0\n\njulia> q = smallangle_to_rot(Quaternion, +0.01, -0.01, +0.01)\nQuaternion{Float64}:\n  + 0.999963 + 0.00499981⋅i - 0.00499981⋅j - 0.00499981⋅k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#ReferenceFrameRotations.vect-Tuple{Quaternion}","page":"Library","title":"ReferenceFrameRotations.vect","text":"vect(q::Quaternion)\n\nReturn the vectorial or imaginary part of the quaternion q represented by a 3 × 1 vector of type SVector{3}.\n\nSee also: imag, real\n\nExamples\n\njulia> q = Quaternion(cosd(75), 0, sind(75), 0)\nQuaternion{Float64}:\n  + 0.258819 + 0.0⋅i + 0.965926⋅j + 0.965926⋅k\n\njulia> vect(q)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.9659258262890683\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"man/dcm/#Direction-Cosine-Matrices","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"","category":"section"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"Direction cosine matrices, or DCMs, are 3 times 3 matrices that represent a coordinate transformation between two orthonormal reference frames. Let those frames be right-handed, then it can be shown that this transformation is always a rotation. Thus, a DCM that rotates the reference frame a into alignment with the reference frame b is:","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"mathbfD_ba = leftbeginmatrix\n    a_11  a_12  a_13 \n    a_21  a_22  a_23 \n    a_31  a_32  a_33\n    endmatrixright","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"In ReferenceFrameRotations.jl, a DCM is a 3 times 3 static matrix:","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"DCM{T} = SMatrix{3,3,T,9}","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"which means that DCM is immutable.","category":"page"},{"location":"man/dcm/#Initialization","page":"Direction Cosine Matrices","title":"Initialization","text":"","category":"section"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"Usually, a DCM is initialized by converting a more \"visual\" rotation representation, such as the Euler angles (see Conversions). However, it can be initialized by the following methods:","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"Identity DCM.","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"julia> DCM(I)  # Create a Boolean DCM, this can be used to save space.\n3×3 StaticArrays.SMatrix{3, 3, Bool, 9} with indices SOneTo(3)×SOneTo(3):\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> DCM(Int64(1)I)  # Create an Integer DCM.\n3×3 StaticArrays.SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> DCM(1.f0I) # Create a Float32 DCM.\n3×3 StaticArrays.SMatrix{3, 3, Float32, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> DCM(1.0I)  # Create a Float64 DCM.\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"User-defined DCM.","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"julia> DCM([-1 0 0; 0 -1 0; 0 0 1])\n3×3 StaticArrays.SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):\n -1   0  0\n  0  -1  0\n  0   0  1\n\njulia> DCM([-1.f0 0.f0 0.f0; 0.f0 -1.f0 0.f0; 0.f0 0.f0 1.f0])\n3×3 StaticArrays.SMatrix{3, 3, Float32, 9} with indices SOneTo(3)×SOneTo(3):\n -1.0   0.0  0.0\n  0.0  -1.0  0.0\n  0.0   0.0  1.0\n\njulia> DCM([-1.0 0.0 0.0; 0.0 -1.0 0.0; 0.0 0.0 1.0])\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n -1.0   0.0  0.0\n  0.0  -1.0  0.0\n  0.0   0.0  1.0","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"note: Note\nThe type of the DCM will depend on the type of the input.","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"warning: Warning\nThis initialization method will not verify if the input data is indeed a DCM.","category":"page"},{"location":"man/dcm/#Operations","page":"Direction Cosine Matrices","title":"Operations","text":"","category":"section"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"Since a DCM is an Static Matrix (SMatrix), then all the operations available for general matrices in Julia are also available for DCMs.","category":"page"},{"location":"man/dcm/#Orthonomalization","page":"Direction Cosine Matrices","title":"Orthonomalization","text":"","category":"section"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"A DCM can be orthonormalized using the Gram-Schmidt algorithm by the function:","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"function orthonormalize(dcm::DCM)","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"julia> D = DCM([2 0 0; 0 2 0; 0 0 2]);\n\njulia> orthonormalize(D)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> D = DCM(3.0f0I);\n\njulia> orthonormalize(D)\n3×3 StaticArrays.SMatrix{3, 3, Float32, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> D = DCM(1,1,2,2,3,3,4,4,5);\n\njulia> Dn = orthonormalize(D)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 0.408248   0.123091   0.904534\n 0.408248   0.86164   -0.301511\n 0.816497  -0.492366  -0.301511\n\njulia> Dn*Dn'\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0          -2.87528e-16  -8.47673e-16\n -2.87528e-16   1.0           3.31283e-16\n -9.03184e-16   3.31283e-16   1.0","category":"page"},{"location":"man/dcm/","page":"Direction Cosine Matrices","title":"Direction Cosine Matrices","text":"warning: Warning\nThis function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have NaN. Notice, however, that such input matrix is not a valid direction cosine matrix.","category":"page"},{"location":"man/kinematics/#Kinematics","page":"Kinematics","title":"Kinematics","text":"","category":"section"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"Currently, only the kinematics of Direction Cosine Matrices and Quaternions are implemented.","category":"page"},{"location":"man/kinematics/#Direction-Cosine-Matrices","page":"Kinematics","title":"Direction Cosine Matrices","text":"","category":"section"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"Let A and B be two reference frames in which the angular velocity of B with respect to A, and represented in B, is given by","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"boldsymbolomega_bab = leftbeginarrayc\n    omega_babx \n    omega_baby \n    omega_babz\nendarrayright","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"If mathbfD_b^a is the DCM that rotates the reference frame A into alignment with the reference frame B, then its time-derivative is","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"dotmathbfD_b^a = -leftbeginarrayccc\n           0          -omega_babz  +omega_baby \n    +omega_babz         0          -omega_babx \n    -omega_baby  +omega_babx         0\nendarrayright cdot mathbfD_b^a","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"In this package, the time-derivative of this DCM can be computed using the function:","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"function ddcm(Dba, wba_b)","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"julia> wba_b = [0.01, 0, 0];\n\njulia> Dba = angle_to_dcm(0.5, 0, 0, :XYZ)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0   0.0       0.0\n -0.0   0.877583  0.479426\n  0.0  -0.479426  0.877583\n\njulia> ddcm(Dba, wba_b)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n -0.0   0.0          0.0\n  0.0  -0.00479426   0.00877583\n  0.0  -0.00877583  -0.00479426","category":"page"},{"location":"man/kinematics/#Quaternions","page":"Kinematics","title":"Quaternions","text":"","category":"section"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"Let A and B be two reference frames in which the angular velocity of B with respect to A, and represented in B, is given by","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"boldsymbolomega_bab = leftbeginarrayc\n    omega_babx \n    omega_baby \n    omega_babz\nendarrayright","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"If mathbfq_ba is the quaternion that rotates the reference frame A into alignment with the reference frame B, then its time-derivative is","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"dotmathbfq_ba = frac12 cdot leftbeginarraycccc\n           0           -omega_babx   -omega_baby  -omega_babz \n    +omega_babx          0           +omega_babz  -omega_baby \n    +omega_baby   -omega_babz          0          +omega_babx \n    +omega_babz   +omega_baby   -omega_babx         0\nendarrayright cdot mathbfq_ba","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"In this package, the time-derivative of this quaternion can be computed using the function:","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"function dquat(qba, wba_b)","category":"page"},{"location":"man/kinematics/","page":"Kinematics","title":"Kinematics","text":"julia> wba_b = [0.01, 0, 0];\n\njulia> qba = angle_to_quat(0.5, 0, 0, :XYZ);\n\njulia> dquat(qba, wba_b)\nQuaternion{Float64}:\n  - 0.00123702 + 0.00484456⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/inv_rotations/#Inverting-rotations","page":"Inverting rotations","title":"Inverting rotations","text":"","category":"section"},{"location":"man/inv_rotations/","page":"Inverting rotations","title":"Inverting rotations","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/inv_rotations/","page":"Inverting rotations","title":"Inverting rotations","text":"A rotation represented by direction cosine matrix or quaternion can be inverted using the function:","category":"page"},{"location":"man/inv_rotations/","page":"Inverting rotations","title":"Inverting rotations","text":"inv_rotation(R)","category":"page"},{"location":"man/inv_rotations/","page":"Inverting rotations","title":"Inverting rotations","text":"in which R must be a DCM or a Quaternion.","category":"page"},{"location":"man/inv_rotations/","page":"Inverting rotations","title":"Inverting rotations","text":"note: Note\nIf R is a DCM, then the transpose matrix will be returned. Hence, the user must ensure that the input matrix is ortho-normalized. Otherwise, the result will not be the inverse matrix of the input.If R is a Quaternion, then the conjugate quaternion will be returned. Hence, the user must ensure that the input quaternion is normalized (have unit norm). Otherwise, the result will not be the inverse quaternion of the input.These behaviors were selected to alleviate the computational burden.","category":"page"},{"location":"man/inv_rotations/","page":"Inverting rotations","title":"Inverting rotations","text":"julia> D1 = angle_to_dcm(0.5, 0.5, 0.5, :XYZ);\n\njulia> D2 = inv_rotation(D1)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.770151  -0.420735   0.479426\n  0.622447   0.659956  -0.420735\n -0.139381   0.622447   0.770151\n\njulia> D2 * D1\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0          3.41413e-17  -1.73278e-17\n  3.41413e-17  1.0           1.97327e-17\n -1.73278e-17  1.97327e-17   1.0\n\njulia> q1 = angle_to_quat(0.5, 0.5, 0.5, :XYZ);\n\njulia> q2 = inv_rotation(q1)\nQuaternion{Float64}:\n  + 0.894463 - 0.291567⋅i - 0.172955⋅j - 0.172955⋅k\n\njulia> q2 * q1\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i - 1.38778e-17⋅j - 1.38778e-17⋅k","category":"page"},{"location":"man/quaternions/#Quaternion","page":"Quaternions","title":"Quaternion","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Quaternions are hypercomplex number with 4 dimensions that can be used to represent 3D rotations. In this package, a quaternion mathbfq is represented by","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfq = q_0 + q_1 cdot mathbfi + q_2 cdot mathbfj + q_3 cdot mathbfk = r + mathbfv","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"using the following immutable structure:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"struct Quaternion{T} <: AbstractVector{T}\n    q0::T\n    q1::T\n    q2::T\n    q3::T\nend","category":"page"},{"location":"man/quaternions/#Initialization","page":"Quaternions","title":"Initialization","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"There are several ways to create a quaternion.","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Provide all the elements:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q = Quaternion(1.0, 0.0, 0.0, 0.0)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Provide the real and imaginary parts as separated numbers:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> r = sqrt(2) / 2;\n\njulia> v = [sqrt(2) / 2, 0, 0];\n\njulia> q = Quaternion(r,v)\nQuaternion{Float64}:\n  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Provide the real and imaginary parts as one single vector:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> v = [1., 2., 3., 4.];\n\njulia> q = Quaternion(v)\nQuaternion{Float64}:\n  + 1.0 + 2.0⋅i + 3.0⋅j + 3.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Provide just the imaginary part, in this case the real part will be 0:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> v = [1., 0., 0.];\n\njulia> q = Quaternion(v)\nQuaternion{Float64}:\n  + 0.0 + 1.0⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Create an identity quaternion:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q = Quaternion{Float64}(I)  # Creates an identity quaternion of type `Float64`.\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = Quaternion(1.0I)  # Creates an identity quaternion of type `Float64`.\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = Quaternion{Float32}(I)  # Creates an identity quaternion of type `Float32`.\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = Quaternion(1.0f0I)  # Creates an identity quaternion of type `Float32`.\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> a = Quaternion(I,q)  # Creates an identity quaternion with the same type of `q`.\nQuaternion{Float32}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = Quaternion(I)\nQuaternion{Bool}:\n  + true + false⋅i + false⋅j + false⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Create a zero quaternion using the zeros function:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q = zeros(Quaternion)  # Creates a zero quaternion of type `Float64`.\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q = zeros(Quaternion{Float32})  # Creates a zero quaternion of type `Float32`.\nQuaternion{Float32}:\n  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k\n\njulia> a = zeros(q)  # Creates a zero quaternion with the same type of `q`.\nQuaternion{Float32}:\n  + 0.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"note: Note\nIndividual elements of the quaternion can be accessed by:q.q0\nq.q1\nq.q2\nq.q3or using linear indexing:q[1]\nq[2]\nq[3]\nq[4]Notice that, in this case, the index 1 refers to the real part of the quaternion.","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"warning: Warning\nSince the type Quaternion is immutable, its components cannot be changed individually after the creation. Hence, the following operation will lead to an error:q.q0 = 1.0  # This is not defined and will not work.If you want to modify a single value for the quaternion, then you need to create another one:q = Quaternion(1.0, q.q1, q.q2, q.q3)This can be annoying sometimes, but using an immutable type provided a huge performance boost for the algorithm.","category":"page"},{"location":"man/quaternions/#Operations","page":"Quaternions","title":"Operations","text":"","category":"section"},{"location":"man/quaternions/#Sum,-subtraction,-and-scalar-multiplication","page":"Quaternions","title":"Sum, subtraction, and scalar multiplication","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"The sum between quaternions, the subtraction between quaternions, and the multiplication between a quaternion and a scalar are defined as usual:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"beginaligned\n  mathbfq_a + mathbfq_b = (q_a0 + q_b0) +\n                                 (q_a1 + q_b1) cdot mathbfi +\n                                 (q_a2 + q_b2) cdot mathbfj +\n                                 (q_a3 + q_b3) cdot mathbfk \n  mathbfq_a - mathbfq_b = (q_a0 - q_b0) +\n                                 (q_a1 - q_b1) cdot mathbfi +\n                                 (q_a2 - q_b2) cdot mathbfj +\n                                 (q_a3 - q_b3) cdot mathbfk \n  lambda cdot mathbfq = (lambda cdot q_0) +\n                              (lambda cdot q_1) cdot mathbfi +\n                              (lambda cdot q_2) cdot mathbfj +\n                              (lambda cdot q_3) cdot mathbfk\nendaligned","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q1 = Quaternion(1.0,1.0,0.0,0.0);\n\njulia> q2 = Quaternion(1.0,2.0,3.0,4.0);\n\njulia> q1 + q2\nQuaternion{Float64}:\n  + 2.0 + 3.0⋅i + 3.0⋅j + 3.0⋅k\n\njulia> q1 - q2\nQuaternion{Float64}:\n  + 0.0 - 1.0⋅i - 3.0⋅j - 3.0⋅k\n\njulia> q1 = Quaternion(1.0,2.0,3.0,4.0);\n\njulia> q1 * 3\nQuaternion{Float64}:\n  + 3.0 + 6.0⋅i + 9.0⋅j + 9.0⋅k\n\njulia> 4 * q1\nQuaternion{Float64}:\n  + 4.0 + 8.0⋅i + 12.0⋅j + 12.0⋅k\n\njulia> 5q1\nQuaternion{Float64}:\n  + 5.0 + 10.0⋅i + 15.0⋅j + 15.0⋅k","category":"page"},{"location":"man/quaternions/#Multiplication-between-quaternions","page":"Quaternions","title":"Multiplication between quaternions","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"The multiplication between quaternions is defined using the Hamilton product:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"beginaligned\n  mathbfq_1 = r_1 + mathbfv_1 \n  mathbfq_2 = r_2 + mathbfv_2 \n  mathbfq_1 cdot mathbfq_2 = r_1 cdot r_2 -\n                                     mathbfv_1 cdot mathbfv_2 +\n                                     r_1 cdot mathbfv_2 +\n                                     r_2 cdot mathbfv_1 +\n                                     mathbfv_1 times mathbfv_2\nendaligned","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q1 = Quaternion(cosd(15), sind(15), 0.0, 0.0);\n\njulia> q2 = Quaternion(cosd(30), sind(30), 0.0, 0.0);\n\njulia> q1 * q2\nQuaternion{Float64}:\n  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"If a quaternion mathbfq is multiplied by a vector mathbfv, then the vector is converted to a quaternion with real part 0, mathbfq_v = 0 + mathbfv, and the quaternion multiplication is performed as usual:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"beginaligned\nmathbfq   = r + mathbfw \nmathbfq_v = 0 + mathbfv \nmathbfq cdot mathbfv triangleq mathbfq cdot mathbfq_v = - mathbfw cdot mathbfv + r cdot mathbfv + mathbfw times mathbfv \nmathbfv cdot mathbfq triangleq mathbfq_v cdot mathbfq = - mathbfv cdot mathbfw + r cdot mathbfv + mathbfv times mathbfw\nendaligned","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q1 = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);\n\njulia> v = [0;1;0];\n\njulia> v * q1\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.92388⋅j + 0.92388⋅k\n\njulia> q1 * v\nQuaternion{Float64}:\n  - 0.0 + 0.0⋅i + 0.92388⋅j + 0.92388⋅k","category":"page"},{"location":"man/quaternions/#Division-between-quaternions","page":"Quaternions","title":"Division between quaternions","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Given this definition of the product between two quaternions, we can define the multiplicative inverse of a quaternion by:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfq^-1 triangleq fracbarmathbfqmathbfq^2 =\n  fracq_0 - q_1 cdot mathbfi - q_2 cdot mathbfj - q_3 cdot mathbfk\n       q_0^2 + q_1^2 + q_2^2 + q_3^2","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Notice that, in this case, one gets:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfq cdot mathbfq^-1 = 1","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"note: Note\nbarmathbfq, which is the quaternion conjugate, can be computed using conj(q).mathbfq, which is the quaternion norm, can be computed using norm(q).The quaternion inverse can be computed using inv(q).","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"warning: Warning\nThe exponentiation operator is not defined for quaternions. Hence, q^(-1) or q^2 will throw an error.","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"The right division (/) between two quaternions mathbfq_1 and mathbfq_2 is defined as the following Hamilton product:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfq_1mathbfq_2 = mathbfq_1 cdot mathbfq_2^-1","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"The left division (\\) between two quaternions mathbfq_1 and mathbfq_2 is defined as the following Hamilton product:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfq_1backslashmathbfq_2 = mathbfq_1^-1 cdot mathbfq_2","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q1 = Quaternion(cosd(45+22.5), sind(45+22.5), 0.0, 0.0);\n\njulia> q2 = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);\n\njulia> q1 / q2\nQuaternion{Float64}:\n  + 0.707107 + 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q1 \\ q2\nQuaternion{Float64}:\n  + 0.707107 - 0.707107⋅i + 0.0⋅j + 0.0⋅k\n\njulia> q1 \\ q2 * q1 / q2\nQuaternion{Float64}:\n  + 1.0 + 5.55112e-17⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"If a division operation (right-division or left-division) is performed between a vector mathbfv and a quaternion, then the vector mathbfv is converted to a quaternion real part 0, mathbfq_v = 0 + mathbfv, and the division operation is performed as defined earlier.","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"beginaligned\n  mathbfvmathbfq          triangleq mathbfq_v      cdot mathbfq^-1   \n  mathbfvbackslashmathbfq triangleq mathbfq_v^-1 cdot mathbfq        \n  mathbfqmathbfv          triangleq mathbfq        cdot mathbfq_v^-1 \n  mathbfqbackslashmathbfv triangleq mathbfq^-1   cdot mathbfq_v\nendaligned","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q1 = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);\n\njulia> v  = [0;1;0];\n\njulia> q1 \\ v\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i + 0.92388⋅j + 0.92388⋅k\n\njulia> v \\ q1\nQuaternion{Float64}:\n  + 0.0 + 0.0⋅i - 0.92388⋅j - 0.92388⋅k","category":"page"},{"location":"man/quaternions/#Other-operations","page":"Quaternions","title":"Other operations","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"There are also the following functions available:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> q = Quaternion(1.0,2.0,3.0,4.0);\n\njulia> conj(q)  # Returns the complex conjugate of the quaternion.\nQuaternion{Float64}:\n  + 1.0 - 2.0⋅i - 3.0⋅j - 3.0⋅k\n\njulia> copy(q)  # Creates a copy of the quaternion.\nQuaternion{Float64}:\n  + 1.0 + 2.0⋅i + 3.0⋅j + 3.0⋅k\n\njulia> inv(q)   # Computes the multiplicative inverse of the quaternion.\nQuaternion{Float64}:\n  + 0.0333333 - 0.0666667⋅i - 0.1⋅j - 0.1⋅k\n\njulia> inv(q)*q\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 5.55112e-17⋅j + 5.55112e-17⋅k\n\njulia> imag(q)  # Returns the vectorial / imaginary part of the quaternion.\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 2.0\n 3.0\n 4.0\n\njulia> norm(q)  # Computes the norm of the quaternion.\n5.477225575051661\n\njulia> real(q)  # Returns the real part of the quaternion.\n1.0\n\njulia> vect(q)  # Returns the vectorial / imaginary part of the quaternion.\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"note: Note\nThe operation a/q is equal to a*inv(q) if a is a scalar.","category":"page"},{"location":"man/quaternions/#Converting-reference-frames-using-quaternions","page":"Quaternions","title":"Converting reference frames using quaternions","text":"","category":"section"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Given the reference frames A and B, let mathbfw be a unitary vector in which a rotation about it of an angle theta aligns the reference frame A with the reference frame B (in this case, mathbfw is aligned with the Euler Axis and theta is the Euler angle). Construct the following quaternion:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfq_ba = cosleft(fractheta2right) + sinleft(fractheta2right) cdot mathbfw","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Then, a vector mathbfv represented in reference frame A (mathbfv_a) can be represented in reference frame B using:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"mathbfv_b = textttvectleft(mathbfq_ba^-1 cdot mathbfv_a cdot mathbfq_baright)","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"Hence:","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"julia> qBA = Quaternion(cosd(22.5), sind(22.5), 0.0, 0.0);\n\njulia> vA  = [0, 1, 0];\n\njulia> vB  = vect(qBA \\ vA * qBA); # Equivalent to: vect(inv(qBA)*vA*qBA);\n\njulia> vB\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n  0.0\n  0.7071067811865475\n -0.7071067811865476","category":"page"},{"location":"man/quaternions/","page":"Quaternions","title":"Quaternions","text":"note: Note\nA SArray is returned instead of the usual Array. This is a static vector created by the package StaticArrays. Generally, you can treat this vector as any other one. The only downside is that you cannot modify individual components because it is immutable.","category":"page"},{"location":"man/composing_rotations/#Composing-rotations","page":"Composing rotations","title":"Composing rotations","text":"","category":"section"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"Multiple rotations represented can be composed using the function:","category":"page"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"compose_rotation(R1,R2,R3,R4...)","category":"page"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"in which R1, R2, R3, ..., must be of the same type. This method returns the following rotation:","category":"page"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"(Image: )","category":"page"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"Currently, this method supports DCMs, Euler angle and axis, Euler angles, and Quaternions.","category":"page"},{"location":"man/composing_rotations/","page":"Composing rotations","title":"Composing rotations","text":"julia> D1 = angle_to_dcm(0.5, 0.5, 0.5, :XYZ)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.770151   0.622447  -0.139381\n -0.420735   0.659956   0.622447\n  0.479426  -0.420735   0.770151\n\njulia> D2 = angle_to_dcm(-0.5, -0.5, -0.5, :ZYX)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.770151  -0.420735   0.479426\n  0.622447   0.659956  -0.420735\n -0.139381   0.622447   0.770151\n\njulia> compose_rotation(D1, D2)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0          3.41413e-17  -1.73278e-17\n  3.41413e-17  1.0           1.97327e-17\n -1.73278e-17  1.97327e-17   1.0\n\njulia> ea1 = EulerAngleAxis(30 * pi / 180, [0, 1, 0]);\n\njulia> ea2 = EulerAngleAxis(45 * pi / 180, [0, 1, 0]);\n\njulia> compose_rotation(ea1, ea2)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.309 rad  (75.0°)\n  Euler axis  : [0.0, 1.0, 0.0]\n\njulia> Θ1 = EulerAngles(1, 2, 3, :ZYX);\n\njulia> Θ2 = EulerAngles(-3, -2, -1, :XYZ);\n\njulia> compose_rotation(Θ1, Θ2)\nEulerAngles{Float64}:\n  R(X) : -1.66533e-16 rad  (-9.54166e-15°)\n  R(Y) :  9.24446e-33 rad  ( 5.29669e-31°)\n  R(Z) : -1.11022e-16 rad  (-6.36111e-15°)\n\njulia> q1 = angle_to_quat(0.5, 0.5, 0.5, :XYZ);\n\njulia> q2 = angle_to_quat(-0.5, -0.5, -0.5, :ZYX);\n\njulia> compose_rotation(q1, q2)\nQuaternion{Float64}:\n  + 1.0 + 0.0⋅i + 0.0⋅j + 0.0⋅k","category":"page"},{"location":"#ReferenceFrameRotations.jl","page":"Home","title":"ReferenceFrameRotations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This module contains functions related to 3D rotations of reference frames. It is used on a daily basis on projects at the Brazilian National Institute for Space Research (INPE).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.update()\njulia> Pkg.add(\"ReferenceFrameRotations\")","category":"page"},{"location":"#Status","page":"Home","title":"Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This packages supports the following representations of 3D rotations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Euler Angle and Axis;\nEuler Angles;\nDirection Cosine Matrices (DCMs);\nQuaternions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, composing rotations is only currently supported for DCMs and Quaternions.","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package will be continuously enhanced. Next steps will be to add other representations of 3D rotations such as Rodrigues parameters, etc.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/dcm.md\",\n    \"man/euler_angle_axis.md\",\n    \"man/euler_angles.md\",\n    \"man/quaternions.md\",\n    \"man/conversions.md\",\n    \"man/kinematics.md\",\n    \"man/composing_rotations.md\",\n    \"man/inv_rotations.md\",\n]\nDepth = 2","category":"page"},{"location":"#Library-documentation","page":"Home","title":"Library documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/library.md\"]","category":"page"},{"location":"man/euler_angle_axis/#Euler-Angle-and-Axis","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"","category":"section"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"CurrentModule = ReferenceFrameRotations\nDocTestSetup = quote\n    using ReferenceFrameRotations\nend","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"The Euler angle and axis representation is defined by the following immutable structure:","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"struct EulerAngleAxis{T}\n    a::T\n    v::SVector{3,T}\nend","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"in which a is the Euler Angle and v is a unitary vector aligned with the Euler axis.","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"The constructor for this structure is:","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"function EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"in which a EulerAngleAxis with angle a [rad] and vector v will be created. Notice that the type of the returned structure will be selected according to the input types T1 and T2. Furthermore, the vector v will not be normalized.","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"julia> EulerAngleAxis(1, [1, 1, 1])\nEulerAngleAxis{Int64}:\n  Euler angle : 1 rad  (57.2958°)\n  Euler axis  : [1, 1, 1]\n\njulia> EulerAngleAxis(1.f0, [1, 1, 1])\nEulerAngleAxis{Float32}:\n  Euler angle : 1.0 rad  (57.2958°)\n  Euler axis  : [1.0, 1.0, 1.0]\n\njulia> EulerAngleAxis(1, [1, 1, 1.f0])\nEulerAngleAxis{Float32}:\n  Euler angle : 1.0 rad  (57.2958°)\n  Euler axis  : [1.0, 1.0, 1.0]\n\njulia> EulerAngleAxis(1.0, [1, 1, 1])\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0 rad  (57.2958°)\n  Euler axis  : [1.0, 1.0, 1.0]","category":"page"},{"location":"man/euler_angle_axis/#Operations","page":"Euler Angle and Axis","title":"Operations","text":"","category":"section"},{"location":"man/euler_angle_axis/#Multiplication","page":"Euler Angle and Axis","title":"Multiplication","text":"","category":"section"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"The multiplication of two Euler angle and axis sets is defined here as the composition of the rotations. Let Theta_1 and Theta_2 be two Euler angle and axis sets (instances of the structure EulerAngleAxis).  Thus, the operation:","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"Theta_21 = Theta_2 cdot Theta_1","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"will return a new set of Euler angle and axis Theta_21 that represents the composed rotation of Theta_1 followed by Theta_2. By convention, the Euler angle of the result will always be in the interval 0 pi rad.","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"warning: Warning\nThis operation is only valid if the vector of the Euler angle and axis set is unitary. The multiplication function does not verify this and does not normalize the vector.","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"julia> ea1 = EulerAngleAxis(30 * pi / 180, [1.0;0.0;0.0])\nEulerAngleAxis{Float64}:\n  Euler angle : 0.523599 rad  (30.0°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\njulia> ea2 = EulerAngleAxis(60 * pi / 180, [1.0;0.0;0.0])\nEulerAngleAxis{Float64}:\n  Euler angle : 1.0472 rad  (60.0°)\n  Euler axis  : [1.0, 0.0, 0.0]\n\njulia> ea2 * ea1\nEulerAngleAxis{Float64}:\n  Euler angle : 1.5708 rad  (90.0°)\n  Euler axis  : [1.0, 0.0, 0.0]","category":"page"},{"location":"man/euler_angle_axis/#Inversion","page":"Euler Angle and Axis","title":"Inversion","text":"","category":"section"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"The inv function applied to Euler angle and axis will return the inverse rotation. Hence, if the Euler angle is a and the Euler axis is aligned with the unitary vector v, then it will return a as the Euler angle and -v as the Euler axis. By convention, the Euler angle of the result will always be in the interval 0 pi rad.","category":"page"},{"location":"man/euler_angle_axis/","page":"Euler Angle and Axis","title":"Euler Angle and Axis","text":"julia> ea = EulerAngleAxis(1.3, [1.0, 0, 0]);\n\njulia> inv(ea)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.3 rad  (74.4845°)\n  Euler axis  : [-1.0, -0.0, -0.0]\n\njulia> ea = EulerAngleAxis(-π, [sqrt(3), sqrt(3), sqrt(3)]);\n\njulia> inv(ea)\nEulerAngleAxis{Float64}:\n  Euler angle : 3.14159 rad  (180.0°)\n  Euler axis  : [-1.73205, -1.73205, -1.73205]\n\njulia> ea = EulerAngleAxis(-3π / 2, [sqrt(3), sqrt(3), sqrt(3)]);\n\njulia> inv(ea)\nEulerAngleAxis{Float64}:\n  Euler angle : 1.5708 rad  (90.0°)\n  Euler axis  : [-1.73205, -1.73205, -1.73205]","category":"page"}]
}
